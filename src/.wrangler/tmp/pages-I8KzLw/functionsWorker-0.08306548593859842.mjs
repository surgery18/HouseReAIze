var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../.wrangler/tmp/bundle-a4mJSG/checked-fetch.js
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  "../.wrangler/tmp/bundle-a4mJSG/checked-fetch.js"() {
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init] = argArray;
        checkURL(request, init);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "../node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// ../node_modules/bson/dist/bson.browser.esm.js
var bson_browser_esm_exports = {};
__export(bson_browser_esm_exports, {
  BSONError: () => BSONError,
  BSONRegExp: () => BSONRegExp,
  BSONSymbol: () => BSONSymbol,
  BSONTypeError: () => BSONTypeError,
  BSON_BINARY_SUBTYPE_BYTE_ARRAY: () => BSON_BINARY_SUBTYPE_BYTE_ARRAY,
  BSON_BINARY_SUBTYPE_COLUMN: () => BSON_BINARY_SUBTYPE_COLUMN,
  BSON_BINARY_SUBTYPE_DEFAULT: () => BSON_BINARY_SUBTYPE_DEFAULT,
  BSON_BINARY_SUBTYPE_ENCRYPTED: () => BSON_BINARY_SUBTYPE_ENCRYPTED,
  BSON_BINARY_SUBTYPE_FUNCTION: () => BSON_BINARY_SUBTYPE_FUNCTION,
  BSON_BINARY_SUBTYPE_MD5: () => BSON_BINARY_SUBTYPE_MD5,
  BSON_BINARY_SUBTYPE_USER_DEFINED: () => BSON_BINARY_SUBTYPE_USER_DEFINED,
  BSON_BINARY_SUBTYPE_UUID: () => BSON_BINARY_SUBTYPE_UUID,
  BSON_BINARY_SUBTYPE_UUID_NEW: () => BSON_BINARY_SUBTYPE_UUID_NEW,
  BSON_DATA_ARRAY: () => BSON_DATA_ARRAY,
  BSON_DATA_BINARY: () => BSON_DATA_BINARY,
  BSON_DATA_BOOLEAN: () => BSON_DATA_BOOLEAN,
  BSON_DATA_CODE: () => BSON_DATA_CODE,
  BSON_DATA_CODE_W_SCOPE: () => BSON_DATA_CODE_W_SCOPE,
  BSON_DATA_DATE: () => BSON_DATA_DATE,
  BSON_DATA_DBPOINTER: () => BSON_DATA_DBPOINTER,
  BSON_DATA_DECIMAL128: () => BSON_DATA_DECIMAL128,
  BSON_DATA_INT: () => BSON_DATA_INT,
  BSON_DATA_LONG: () => BSON_DATA_LONG,
  BSON_DATA_MAX_KEY: () => BSON_DATA_MAX_KEY,
  BSON_DATA_MIN_KEY: () => BSON_DATA_MIN_KEY,
  BSON_DATA_NULL: () => BSON_DATA_NULL,
  BSON_DATA_NUMBER: () => BSON_DATA_NUMBER,
  BSON_DATA_OBJECT: () => BSON_DATA_OBJECT,
  BSON_DATA_OID: () => BSON_DATA_OID,
  BSON_DATA_REGEXP: () => BSON_DATA_REGEXP,
  BSON_DATA_STRING: () => BSON_DATA_STRING,
  BSON_DATA_SYMBOL: () => BSON_DATA_SYMBOL,
  BSON_DATA_TIMESTAMP: () => BSON_DATA_TIMESTAMP,
  BSON_DATA_UNDEFINED: () => BSON_DATA_UNDEFINED,
  BSON_INT32_MAX: () => BSON_INT32_MAX$1,
  BSON_INT32_MIN: () => BSON_INT32_MIN$1,
  BSON_INT64_MAX: () => BSON_INT64_MAX$1,
  BSON_INT64_MIN: () => BSON_INT64_MIN$1,
  Binary: () => Binary,
  Code: () => Code,
  DBRef: () => DBRef,
  Decimal128: () => Decimal128,
  Double: () => Double,
  EJSON: () => EJSON,
  Int32: () => Int32,
  Long: () => Long,
  LongWithoutOverridesClass: () => LongWithoutOverridesClass,
  Map: () => bsonMap,
  MaxKey: () => MaxKey,
  MinKey: () => MinKey,
  ObjectID: () => ObjectId,
  ObjectId: () => ObjectId,
  Timestamp: () => Timestamp,
  UUID: () => UUID,
  calculateObjectSize: () => calculateObjectSize,
  default: () => bson_browser_esm_default,
  deserialize: () => deserialize,
  deserializeStream: () => deserializeStream,
  serialize: () => serialize,
  serializeWithBufferAndIndex: () => serializeWithBufferAndIndex,
  setInternalBufferSize: () => setInternalBufferSize
});
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
function __extends(d2, b2) {
  _extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function checkForMath(potentialGlobal) {
  return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;
}
function getGlobal() {
  return checkForMath(typeof globalThis === "object" && globalThis) || checkForMath(typeof window === "object" && window) || checkForMath(typeof self === "object" && self) || checkForMath(typeof global === "object" && global) || // eslint-disable-next-line @typescript-eslint/no-implied-eval
  Function("return this")();
}
function normalizedFunctionString(fn) {
  return fn.toString().replace("function(", "function (");
}
function isReactNative() {
  var g2 = getGlobal();
  return typeof g2.navigator === "object" && g2.navigator.product === "ReactNative";
}
function isAnyArrayBuffer(value) {
  return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value));
}
function isUint8Array(value) {
  return Object.prototype.toString.call(value) === "[object Uint8Array]";
}
function isBigInt64Array(value) {
  return Object.prototype.toString.call(value) === "[object BigInt64Array]";
}
function isBigUInt64Array(value) {
  return Object.prototype.toString.call(value) === "[object BigUint64Array]";
}
function isRegExp(d2) {
  return Object.prototype.toString.call(d2) === "[object RegExp]";
}
function isMap(d2) {
  return Object.prototype.toString.call(d2) === "[object Map]";
}
function isDate(d2) {
  return isObjectLike(d2) && Object.prototype.toString.call(d2) === "[object Date]";
}
function isObjectLike(candidate) {
  return typeof candidate === "object" && candidate !== null;
}
function deprecate(fn, message) {
  var warned = false;
  function deprecated() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    if (!warned) {
      console.warn(message);
      warned = true;
    }
    return fn.apply(this, args);
  }
  return deprecated;
}
function ensureBuffer(potentialBuffer) {
  if (ArrayBuffer.isView(potentialBuffer)) {
    return buffer_1.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
  }
  if (isAnyArrayBuffer(potentialBuffer)) {
    return buffer_1.from(potentialBuffer);
  }
  throw new BSONTypeError("Must use either Buffer or TypedArray");
}
function isDBRefLike(value) {
  return isObjectLike(value) && value.$id != null && typeof value.$ref === "string" && (value.$db == null || typeof value.$db === "string");
}
function isDigit(value) {
  return !isNaN(parseInt(value, 10));
}
function divideu128(value) {
  var DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
  var _rem = Long.fromNumber(0);
  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
    return { quotient: value, rem: _rem };
  }
  for (var i2 = 0; i2 <= 3; i2++) {
    _rem = _rem.shiftLeft(32);
    _rem = _rem.add(new Long(value.parts[i2], 0));
    value.parts[i2] = _rem.div(DIVISOR).low;
    _rem = _rem.modulo(DIVISOR);
  }
  return { quotient: value, rem: _rem };
}
function multiply64x2(left, right) {
  if (!left && !right) {
    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
  }
  var leftHigh = left.shiftRightUnsigned(32);
  var leftLow = new Long(left.getLowBits(), 0);
  var rightHigh = right.shiftRightUnsigned(32);
  var rightLow = new Long(right.getLowBits(), 0);
  var productHigh = leftHigh.multiply(rightHigh);
  var productMid = leftHigh.multiply(rightLow);
  var productMid2 = leftLow.multiply(rightHigh);
  var productLow = leftLow.multiply(rightLow);
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
  return { high: productHigh, low: productLow };
}
function lessThan(left, right) {
  var uhleft = left.high >>> 0;
  var uhright = right.high >>> 0;
  if (uhleft < uhright) {
    return true;
  } else if (uhleft === uhright) {
    var ulleft = left.low >>> 0;
    var ulright = right.low >>> 0;
    if (ulleft < ulright)
      return true;
  }
  return false;
}
function invalidErr(string, message) {
  throw new BSONTypeError('"'.concat(string, '" is not a valid Decimal128 string - ').concat(message));
}
function alphabetize(str) {
  return str.split("").sort().join("");
}
function isBSONType(value) {
  return isObjectLike(value) && Reflect.has(value, "_bsontype") && typeof value._bsontype === "string";
}
function deserializeValue(value, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof value === "number") {
    if (options.relaxed || options.legacy) {
      return value;
    }
    if (Math.floor(value) === value) {
      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)
        return new Int32(value);
      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)
        return Long.fromNumber(value);
    }
    return new Double(value);
  }
  if (value == null || typeof value !== "object")
    return value;
  if (value.$undefined)
    return null;
  var keys = Object.keys(value).filter(function(k2) {
    return k2.startsWith("$") && value[k2] != null;
  });
  for (var i2 = 0; i2 < keys.length; i2++) {
    var c2 = keysToCodecs[keys[i2]];
    if (c2)
      return c2.fromExtendedJSON(value, options);
  }
  if (value.$date != null) {
    var d2 = value.$date;
    var date = /* @__PURE__ */ new Date();
    if (options.legacy) {
      if (typeof d2 === "number")
        date.setTime(d2);
      else if (typeof d2 === "string")
        date.setTime(Date.parse(d2));
    } else {
      if (typeof d2 === "string")
        date.setTime(Date.parse(d2));
      else if (Long.isLong(d2))
        date.setTime(d2.toNumber());
      else if (typeof d2 === "number" && options.relaxed)
        date.setTime(d2);
    }
    return date;
  }
  if (value.$code != null) {
    var copy = Object.assign({}, value);
    if (value.$scope) {
      copy.$scope = deserializeValue(value.$scope);
    }
    return Code.fromExtendedJSON(value);
  }
  if (isDBRefLike(value) || value.$dbPointer) {
    var v2 = value.$ref ? value : value.$dbPointer;
    if (v2 instanceof DBRef)
      return v2;
    var dollarKeys = Object.keys(v2).filter(function(k2) {
      return k2.startsWith("$");
    });
    var valid_1 = true;
    dollarKeys.forEach(function(k2) {
      if (["$ref", "$id", "$db"].indexOf(k2) === -1)
        valid_1 = false;
    });
    if (valid_1)
      return DBRef.fromExtendedJSON(v2);
  }
  return value;
}
function serializeArray(array, options) {
  return array.map(function(v2, index) {
    options.seenObjects.push({ propertyName: "index ".concat(index), obj: null });
    try {
      return serializeValue(v2, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}
function getISOString(date) {
  var isoStr = date.toISOString();
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
}
function serializeValue(value, options) {
  if ((typeof value === "object" || typeof value === "function") && value !== null) {
    var index = options.seenObjects.findIndex(function(entry) {
      return entry.obj === value;
    });
    if (index !== -1) {
      var props = options.seenObjects.map(function(entry) {
        return entry.propertyName;
      });
      var leadingPart = props.slice(0, index).map(function(prop) {
        return "".concat(prop, " -> ");
      }).join("");
      var alreadySeen = props[index];
      var circularPart = " -> " + props.slice(index + 1, props.length - 1).map(function(prop) {
        return "".concat(prop, " -> ");
      }).join("");
      var current = props[props.length - 1];
      var leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
      var dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
      throw new BSONTypeError("Converting circular structure to EJSON:\n" + "    ".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, "\n") + "    ".concat(leadingSpace, "\\").concat(dashes, "/"));
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }
  if (Array.isArray(value))
    return serializeArray(value, options);
  if (value === void 0)
    return null;
  if (value instanceof Date || isDate(value)) {
    var dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
    if (options.legacy) {
      return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
    }
    return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
  }
  if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
    if (Math.floor(value) === value) {
      var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX, int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;
      if (int32Range)
        return { $numberInt: value.toString() };
      if (int64Range)
        return { $numberLong: value.toString() };
    }
    return { $numberDouble: value.toString() };
  }
  if (value instanceof RegExp || isRegExp(value)) {
    var flags2 = value.flags;
    if (flags2 === void 0) {
      var match2 = value.toString().match(/[gimuy]*$/);
      if (match2) {
        flags2 = match2[0];
      }
    }
    var rx = new BSONRegExp(value.source, flags2);
    return rx.toExtendedJSON(options);
  }
  if (value != null && typeof value === "object")
    return serializeDocument(value, options);
  return value;
}
function serializeDocument(doc, options) {
  if (doc == null || typeof doc !== "object")
    throw new BSONError("not an object instance");
  var bsontype = doc._bsontype;
  if (typeof bsontype === "undefined") {
    var _doc = {};
    for (var name in doc) {
      options.seenObjects.push({ propertyName: name, obj: null });
      try {
        var value = serializeValue(doc[name], options);
        if (name === "__proto__") {
          Object.defineProperty(_doc, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (isBSONType(doc)) {
    var outDoc = doc;
    if (typeof outDoc.toExtendedJSON !== "function") {
      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONTypeError("Unrecognized or invalid _bsontype: " + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }
    if (bsontype === "Code" && outDoc.scope) {
      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === "DBRef" && outDoc.oid) {
      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
    }
    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
  }
}
function calculateObjectSize$1(object, serializeFunctions, ignoreUndefined) {
  var totalLength = 4 + 1;
  if (Array.isArray(object)) {
    for (var i2 = 0; i2 < object.length; i2++) {
      totalLength += calculateElement(i2.toString(), object[i2], serializeFunctions, true, ignoreUndefined);
    }
  } else {
    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === "function") {
      object = object.toBSON();
    }
    for (var key in object) {
      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
    }
  }
  return totalLength;
}
function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
  if (serializeFunctions === void 0) {
    serializeFunctions = false;
  }
  if (isArray === void 0) {
    isArray = false;
  }
  if (ignoreUndefined === void 0) {
    ignoreUndefined = false;
  }
  if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
    value = value.toBSON();
  }
  switch (typeof value) {
    case "string":
      return 1 + buffer_1.byteLength(name, "utf8") + 1 + 4 + buffer_1.byteLength(value, "utf8") + 1;
    case "number":
      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
        if (value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
        } else {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        }
      } else {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
      }
    case "undefined":
      if (isArray || !ignoreUndefined)
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1;
      return 0;
    case "boolean":
      return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
    case "object":
      if (value == null || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1;
      } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
      } else if (value instanceof Date || isDate(value)) {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.byteLength;
      } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
      } else if (value["_bsontype"] === "Decimal128") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
      } else if (value["_bsontype"] === "Code") {
        if (value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);
        } else {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.byteLength(value.code.toString(), "utf8") + 1;
        }
      } else if (value["_bsontype"] === "Binary") {
        var binary = value;
        if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
        } else {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + (binary.position + 1 + 4 + 1);
        }
      } else if (value["_bsontype"] === "Symbol") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + buffer_1.byteLength(value.value, "utf8") + 4 + 1 + 1;
      } else if (value["_bsontype"] === "DBRef") {
        var ordered_values = Object.assign({
          $ref: value.collection,
          $id: value.oid
        }, value.fields);
        if (value.db != null) {
          ordered_values["$db"] = value.db;
        }
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize$1(ordered_values, serializeFunctions, ignoreUndefined);
      } else if (value instanceof RegExp || isRegExp(value)) {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
      } else if (value["_bsontype"] === "BSONRegExp") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.byteLength(value.pattern, "utf8") + 1 + buffer_1.byteLength(value.options, "utf8") + 1;
      } else {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize$1(value, serializeFunctions, ignoreUndefined) + 1;
      }
    case "function":
      if (value instanceof RegExp || isRegExp(value) || String.call(value) === "[object RegExp]") {
        return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
      } else {
        if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);
        } else if (serializeFunctions) {
          return (name != null ? buffer_1.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.byteLength(normalizedFunctionString(value), "utf8") + 1;
        }
      }
  }
  return 0;
}
function validateUtf8(bytes, start, end) {
  var continuation = 0;
  for (var i2 = start; i2 < end; i2 += 1) {
    var byte = bytes[i2];
    if (continuation) {
      if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
        return false;
      }
      continuation -= 1;
    } else if (byte & FIRST_BIT) {
      if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
        continuation = 1;
      } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
        continuation = 2;
      } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
        continuation = 3;
      } else {
        return false;
      }
    }
  }
  return !continuation;
}
function deserialize$1(buffer2, options, isArray) {
  options = options == null ? {} : options;
  var index = options && options.index ? options.index : 0;
  var size = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
  if (size < 5) {
    throw new BSONError("bson size must be >= 5, is ".concat(size));
  }
  if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
    throw new BSONError("buffer length ".concat(buffer2.length, " must be >= bson size ").concat(size));
  }
  if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
    throw new BSONError("buffer length ".concat(buffer2.length, " must === bson size ").concat(size));
  }
  if (size + index > buffer2.byteLength) {
    throw new BSONError("(bson size ".concat(size, " + options.index ").concat(index, " must be <= buffer length ").concat(buffer2.byteLength, ")"));
  }
  if (buffer2[index + size - 1] !== 0) {
    throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
  }
  return deserializeObject(buffer2, index, options, isArray);
}
function deserializeObject(buffer2, index, options, isArray) {
  if (isArray === void 0) {
    isArray = false;
  }
  var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
  var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
  var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
  var raw = options["raw"] == null ? false : options["raw"];
  var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
  var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
  var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
  var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
  var validation = options.validation == null ? { utf8: true } : options.validation;
  var globalUTFValidation = true;
  var validationSetting;
  var utf8KeysSet = /* @__PURE__ */ new Set();
  var utf8ValidatedKeys = validation.utf8;
  if (typeof utf8ValidatedKeys === "boolean") {
    validationSetting = utf8ValidatedKeys;
  } else {
    globalUTFValidation = false;
    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key2) {
      return utf8ValidatedKeys[key2];
    });
    if (utf8ValidationValues.length === 0) {
      throw new BSONError("UTF-8 validation setting cannot be empty");
    }
    if (typeof utf8ValidationValues[0] !== "boolean") {
      throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
    }
    validationSetting = utf8ValidationValues[0];
    if (!utf8ValidationValues.every(function(item) {
      return item === validationSetting;
    })) {
      throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
    }
  }
  if (!globalUTFValidation) {
    for (var _i2 = 0, _a2 = Object.keys(utf8ValidatedKeys); _i2 < _a2.length; _i2++) {
      var key = _a2[_i2];
      utf8KeysSet.add(key);
    }
  }
  var startIndex = index;
  if (buffer2.length < 5)
    throw new BSONError("corrupt bson message < 5 bytes long");
  var size = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
  if (size < 5 || size > buffer2.length)
    throw new BSONError("corrupt bson message");
  var object = isArray ? [] : {};
  var arrayIndex = 0;
  var done = false;
  var isPossibleDBRef = isArray ? false : null;
  var dataview = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  while (!done) {
    var elementType = buffer2[index++];
    if (elementType === 0)
      break;
    var i2 = index;
    while (buffer2[i2] !== 0 && i2 < buffer2.length) {
      i2++;
    }
    if (i2 >= buffer2.byteLength)
      throw new BSONError("Bad BSON Document: illegal CString");
    var name = isArray ? arrayIndex++ : buffer2.toString("utf8", index, i2);
    var shouldValidateKey = true;
    if (globalUTFValidation || utf8KeysSet.has(name)) {
      shouldValidateKey = validationSetting;
    } else {
      shouldValidateKey = !validationSetting;
    }
    if (isPossibleDBRef !== false && name[0] === "$") {
      isPossibleDBRef = allowedDBRefKeys.test(name);
    }
    var value = void 0;
    index = i2 + 1;
    if (elementType === BSON_DATA_STRING) {
      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      value = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_OID) {
      var oid = buffer_1.alloc(12);
      buffer2.copy(oid, 0, index, index + 12);
      value = new ObjectId(oid);
      index = index + 12;
    } else if (elementType === BSON_DATA_INT && promoteValues === false) {
      value = new Int32(buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24);
    } else if (elementType === BSON_DATA_INT) {
      value = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {
      value = new Double(dataview.getFloat64(index, true));
      index = index + 8;
    } else if (elementType === BSON_DATA_NUMBER) {
      value = dataview.getFloat64(index, true);
      index = index + 8;
    } else if (elementType === BSON_DATA_DATE) {
      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      value = new Date(new Long(lowBits, highBits).toNumber());
    } else if (elementType === BSON_DATA_BOOLEAN) {
      if (buffer2[index] !== 0 && buffer2[index] !== 1)
        throw new BSONError("illegal boolean type value");
      value = buffer2[index++] === 1;
    } else if (elementType === BSON_DATA_OBJECT) {
      var _index = index;
      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
      if (objectSize <= 0 || objectSize > buffer2.length - index)
        throw new BSONError("bad embedded document length in bson");
      if (raw) {
        value = buffer2.slice(index, index + objectSize);
      } else {
        var objectOptions = options;
        if (!globalUTFValidation) {
          objectOptions = _assign(_assign({}, options), { validation: { utf8: shouldValidateKey } });
        }
        value = deserializeObject(buffer2, _index, objectOptions, false);
      }
      index = index + objectSize;
    } else if (elementType === BSON_DATA_ARRAY) {
      var _index = index;
      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
      var arrayOptions = options;
      var stopIndex = index + objectSize;
      if (fieldsAsRaw && fieldsAsRaw[name]) {
        arrayOptions = {};
        for (var n2 in options) {
          arrayOptions[n2] = options[n2];
        }
        arrayOptions["raw"] = true;
      }
      if (!globalUTFValidation) {
        arrayOptions = _assign(_assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });
      }
      value = deserializeObject(buffer2, _index, arrayOptions, true);
      index = index + objectSize;
      if (buffer2[index - 1] !== 0)
        throw new BSONError("invalid array terminator byte");
      if (index !== stopIndex)
        throw new BSONError("corrupted array bson");
    } else if (elementType === BSON_DATA_UNDEFINED) {
      value = void 0;
    } else if (elementType === BSON_DATA_NULL) {
      value = null;
    } else if (elementType === BSON_DATA_LONG) {
      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      var long = new Long(lowBits, highBits);
      if (promoteLongs && promoteValues === true) {
        value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
      } else {
        value = long;
      }
    } else if (elementType === BSON_DATA_DECIMAL128) {
      var bytes = buffer_1.alloc(16);
      buffer2.copy(bytes, 0, index, index + 16);
      index = index + 16;
      var decimal128 = new Decimal128(bytes);
      if ("toObject" in decimal128 && typeof decimal128.toObject === "function") {
        value = decimal128.toObject();
      } else {
        value = decimal128;
      }
    } else if (elementType === BSON_DATA_BINARY) {
      var binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      var totalBinarySize = binarySize;
      var subType = buffer2[index++];
      if (binarySize < 0)
        throw new BSONError("Negative binary type element size found");
      if (binarySize > buffer2.byteLength)
        throw new BSONError("Binary type size larger than document size");
      if (buffer2["slice"] != null) {
        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found for subtype 0x02");
          if (binarySize > totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
          if (binarySize < totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
        }
        if (promoteBuffers && promoteValues) {
          value = buffer2.slice(index, index + binarySize);
        } else {
          value = new Binary(buffer2.slice(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {
            value = value.toUUID();
          }
        }
      } else {
        var _buffer = buffer_1.alloc(binarySize);
        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found for subtype 0x02");
          if (binarySize > totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
          if (binarySize < totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
        }
        for (i2 = 0; i2 < binarySize; i2++) {
          _buffer[i2] = buffer2[index + i2];
        }
        if (promoteBuffers && promoteValues) {
          value = _buffer;
        } else if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {
          value = new Binary(buffer2.slice(index, index + binarySize), subType).toUUID();
        } else {
          value = new Binary(buffer2.slice(index, index + binarySize), subType);
        }
      }
      index = index + binarySize;
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
      i2 = index;
      while (buffer2[i2] !== 0 && i2 < buffer2.length) {
        i2++;
      }
      if (i2 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      var source = buffer2.toString("utf8", index, i2);
      index = i2 + 1;
      i2 = index;
      while (buffer2[i2] !== 0 && i2 < buffer2.length) {
        i2++;
      }
      if (i2 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      var regExpOptions = buffer2.toString("utf8", index, i2);
      index = i2 + 1;
      var optionsArray = new Array(regExpOptions.length);
      for (i2 = 0; i2 < regExpOptions.length; i2++) {
        switch (regExpOptions[i2]) {
          case "m":
            optionsArray[i2] = "m";
            break;
          case "s":
            optionsArray[i2] = "g";
            break;
          case "i":
            optionsArray[i2] = "i";
            break;
        }
      }
      value = new RegExp(source, optionsArray.join(""));
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
      i2 = index;
      while (buffer2[i2] !== 0 && i2 < buffer2.length) {
        i2++;
      }
      if (i2 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      var source = buffer2.toString("utf8", index, i2);
      index = i2 + 1;
      i2 = index;
      while (buffer2[i2] !== 0 && i2 < buffer2.length) {
        i2++;
      }
      if (i2 >= buffer2.length)
        throw new BSONError("Bad BSON Document: illegal CString");
      var regExpOptions = buffer2.toString("utf8", index, i2);
      index = i2 + 1;
      value = new BSONRegExp(source, regExpOptions);
    } else if (elementType === BSON_DATA_SYMBOL) {
      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      var symbol = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
      value = promoteValues ? symbol : new BSONSymbol(symbol);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_TIMESTAMP) {
      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      value = new Timestamp(lowBits, highBits);
    } else if (elementType === BSON_DATA_MIN_KEY) {
      value = new MinKey();
    } else if (elementType === BSON_DATA_MAX_KEY) {
      value = new MaxKey();
    } else if (elementType === BSON_DATA_CODE) {
      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
      if (evalFunctions) {
        if (cacheFunctions) {
          value = isolateEval(functionString, functionCache, object);
        } else {
          value = isolateEval(functionString);
        }
      } else {
        value = new Code(functionString);
      }
      index = index + stringSize;
    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
      var totalSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (totalSize < 4 + 4 + 4 + 1) {
        throw new BSONError("code_w_scope total size shorter minimum expected length");
      }
      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
        throw new BSONError("bad string length in bson");
      }
      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
      var _index = index;
      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
      var scopeObject = deserializeObject(buffer2, _index, options, false);
      index = index + objectSize;
      if (totalSize < 4 + 4 + objectSize + stringSize) {
        throw new BSONError("code_w_scope total size is too short, truncating scope");
      }
      if (totalSize > 4 + 4 + objectSize + stringSize) {
        throw new BSONError("code_w_scope total size is too long, clips outer document");
      }
      if (evalFunctions) {
        if (cacheFunctions) {
          value = isolateEval(functionString, functionCache, object);
        } else {
          value = isolateEval(functionString);
        }
        value.scope = scopeObject;
      } else {
        value = new Code(functionString, scopeObject);
      }
    } else if (elementType === BSON_DATA_DBPOINTER) {
      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
        throw new BSONError("bad string length in bson");
      if (validation != null && validation.utf8) {
        if (!validateUtf8(buffer2, index, index + stringSize - 1)) {
          throw new BSONError("Invalid UTF-8 string in BSON document");
        }
      }
      var namespace = buffer2.toString("utf8", index, index + stringSize - 1);
      index = index + stringSize;
      var oidBuffer = buffer_1.alloc(12);
      buffer2.copy(oidBuffer, 0, index, index + 12);
      var oid = new ObjectId(oidBuffer);
      index = index + 12;
      value = new DBRef(namespace, oid);
    } else {
      throw new BSONError("Detected unknown BSON type ".concat(elementType.toString(16), ' for fieldname "').concat(name, '"'));
    }
    if (name === "__proto__") {
      Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      object[name] = value;
    }
  }
  if (size !== index - startIndex) {
    if (isArray)
      throw new BSONError("corrupt array bson");
    throw new BSONError("corrupt object bson");
  }
  if (!isPossibleDBRef)
    return object;
  if (isDBRefLike(object)) {
    var copy = Object.assign({}, object);
    delete copy.$ref;
    delete copy.$id;
    delete copy.$db;
    return new DBRef(object.$ref, object.$id, object.$db, copy);
  }
  return object;
}
function isolateEval(functionString, functionCache2, object) {
  if (!functionCache2)
    return new Function(functionString);
  if (functionCache2[functionString] == null) {
    functionCache2[functionString] = new Function(functionString);
  }
  return functionCache2[functionString].bind(object);
}
function getValidatedString(buffer2, start, end, shouldValidateUtf8) {
  var value = buffer2.toString("utf8", start, end);
  if (shouldValidateUtf8) {
    for (var i2 = 0; i2 < value.length; i2++) {
      if (value.charCodeAt(i2) === 65533) {
        if (!validateUtf8(buffer2, start, end)) {
          throw new BSONError("Invalid UTF-8 string in BSON document");
        }
        break;
      }
    }
  }
  return value;
}
function serializeString(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_STRING;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes + 1;
  buffer2[index - 1] = 0;
  var size = buffer2.write(value, index + 4, void 0, "utf8");
  buffer2[index + 3] = size + 1 >> 24 & 255;
  buffer2[index + 2] = size + 1 >> 16 & 255;
  buffer2[index + 1] = size + 1 >> 8 & 255;
  buffer2[index] = size + 1 & 255;
  index = index + 4 + size;
  buffer2[index++] = 0;
  return index;
}
function serializeNumber(buffer2, key, value, index, isArray) {
  if (Number.isInteger(value) && value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {
    buffer2[index++] = BSON_DATA_INT;
    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value & 255;
    buffer2[index++] = value >> 8 & 255;
    buffer2[index++] = value >> 16 & 255;
    buffer2[index++] = value >> 24 & 255;
  } else {
    buffer2[index++] = BSON_DATA_NUMBER;
    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    DV_FOR_FLOAT64.setFloat64(0, value, true);
    buffer2.set(SPACE_FOR_FLOAT64, index);
    index = index + 8;
  }
  return index;
}
function serializeNull(buffer2, key, _, index, isArray) {
  buffer2[index++] = BSON_DATA_NULL;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  return index;
}
function serializeBoolean(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_BOOLEAN;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  buffer2[index++] = value ? 1 : 0;
  return index;
}
function serializeDate(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_DATE;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var dateInMilis = Long.fromNumber(value.getTime());
  var lowBits = dateInMilis.getLowBits();
  var highBits = dateInMilis.getHighBits();
  buffer2[index++] = lowBits & 255;
  buffer2[index++] = lowBits >> 8 & 255;
  buffer2[index++] = lowBits >> 16 & 255;
  buffer2[index++] = lowBits >> 24 & 255;
  buffer2[index++] = highBits & 255;
  buffer2[index++] = highBits >> 8 & 255;
  buffer2[index++] = highBits >> 16 & 255;
  buffer2[index++] = highBits >> 24 & 255;
  return index;
}
function serializeRegExp(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
    throw Error("value " + value.source + " must not contain null bytes");
  }
  index = index + buffer2.write(value.source, index, void 0, "utf8");
  buffer2[index++] = 0;
  if (value.ignoreCase)
    buffer2[index++] = 105;
  if (value.global)
    buffer2[index++] = 115;
  if (value.multiline)
    buffer2[index++] = 109;
  buffer2[index++] = 0;
  return index;
}
function serializeBSONRegExp(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (value.pattern.match(regexp) != null) {
    throw Error("pattern " + value.pattern + " must not contain null bytes");
  }
  index = index + buffer2.write(value.pattern, index, void 0, "utf8");
  buffer2[index++] = 0;
  index = index + buffer2.write(value.options.split("").sort().join(""), index, void 0, "utf8");
  buffer2[index++] = 0;
  return index;
}
function serializeMinMax(buffer2, key, value, index, isArray) {
  if (value === null) {
    buffer2[index++] = BSON_DATA_NULL;
  } else if (value._bsontype === "MinKey") {
    buffer2[index++] = BSON_DATA_MIN_KEY;
  } else {
    buffer2[index++] = BSON_DATA_MAX_KEY;
  }
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  return index;
}
function serializeObjectId(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_OID;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  if (typeof value.id === "string") {
    buffer2.write(value.id, index, void 0, "binary");
  } else if (isUint8Array(value.id)) {
    buffer2.set(value.id.subarray(0, 12), index);
  } else {
    throw new BSONTypeError("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
  }
  return index + 12;
}
function serializeBuffer(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var size = value.length;
  buffer2[index++] = size & 255;
  buffer2[index++] = size >> 8 & 255;
  buffer2[index++] = size >> 16 & 255;
  buffer2[index++] = size >> 24 & 255;
  buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
  buffer2.set(ensureBuffer(value), index);
  index = index + size;
  return index;
}
function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
  if (checkKeys === void 0) {
    checkKeys = false;
  }
  if (depth === void 0) {
    depth = 0;
  }
  if (serializeFunctions === void 0) {
    serializeFunctions = false;
  }
  if (ignoreUndefined === void 0) {
    ignoreUndefined = true;
  }
  if (isArray === void 0) {
    isArray = false;
  }
  if (path === void 0) {
    path = [];
  }
  for (var i2 = 0; i2 < path.length; i2++) {
    if (path[i2] === value)
      throw new BSONError("cyclic dependency detected");
  }
  path.push(value);
  buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
  path.pop();
  return endIndex;
}
function serializeDecimal128(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_DECIMAL128;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  buffer2.set(value.bytes.subarray(0, 16), index);
  return index + 16;
}
function serializeLong(buffer2, key, value, index, isArray) {
  buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var lowBits = value.getLowBits();
  var highBits = value.getHighBits();
  buffer2[index++] = lowBits & 255;
  buffer2[index++] = lowBits >> 8 & 255;
  buffer2[index++] = lowBits >> 16 & 255;
  buffer2[index++] = lowBits >> 24 & 255;
  buffer2[index++] = highBits & 255;
  buffer2[index++] = highBits >> 8 & 255;
  buffer2[index++] = highBits >> 16 & 255;
  buffer2[index++] = highBits >> 24 & 255;
  return index;
}
function serializeInt32(buffer2, key, value, index, isArray) {
  value = value.valueOf();
  buffer2[index++] = BSON_DATA_INT;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  buffer2[index++] = value & 255;
  buffer2[index++] = value >> 8 & 255;
  buffer2[index++] = value >> 16 & 255;
  buffer2[index++] = value >> 24 & 255;
  return index;
}
function serializeDouble(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_NUMBER;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  DV_FOR_FLOAT64.setFloat64(0, value.value, true);
  buffer2.set(SPACE_FOR_FLOAT64, index);
  index = index + 8;
  return index;
}
function serializeFunction(buffer2, key, value, index, _checkKeys, _depth, isArray) {
  buffer2[index++] = BSON_DATA_CODE;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var functionString = normalizedFunctionString(value);
  var size = buffer2.write(functionString, index + 4, void 0, "utf8") + 1;
  buffer2[index] = size & 255;
  buffer2[index + 1] = size >> 8 & 255;
  buffer2[index + 2] = size >> 16 & 255;
  buffer2[index + 3] = size >> 24 & 255;
  index = index + 4 + size - 1;
  buffer2[index++] = 0;
  return index;
}
function serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
  if (checkKeys === void 0) {
    checkKeys = false;
  }
  if (depth === void 0) {
    depth = 0;
  }
  if (serializeFunctions === void 0) {
    serializeFunctions = false;
  }
  if (ignoreUndefined === void 0) {
    ignoreUndefined = true;
  }
  if (isArray === void 0) {
    isArray = false;
  }
  if (value.scope && typeof value.scope === "object") {
    buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    var startIndex = index;
    var functionString = typeof value.code === "string" ? value.code : value.code.toString();
    index = index + 4;
    var codeSize = buffer2.write(functionString, index + 4, void 0, "utf8") + 1;
    buffer2[index] = codeSize & 255;
    buffer2[index + 1] = codeSize >> 8 & 255;
    buffer2[index + 2] = codeSize >> 16 & 255;
    buffer2[index + 3] = codeSize >> 24 & 255;
    buffer2[index + 4 + codeSize - 1] = 0;
    index = index + codeSize + 4;
    var endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
    index = endIndex - 1;
    var totalSize = endIndex - startIndex;
    buffer2[startIndex++] = totalSize & 255;
    buffer2[startIndex++] = totalSize >> 8 & 255;
    buffer2[startIndex++] = totalSize >> 16 & 255;
    buffer2[startIndex++] = totalSize >> 24 & 255;
    buffer2[index++] = 0;
  } else {
    buffer2[index++] = BSON_DATA_CODE;
    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    var functionString = value.code.toString();
    var size = buffer2.write(functionString, index + 4, void 0, "utf8") + 1;
    buffer2[index] = size & 255;
    buffer2[index + 1] = size >> 8 & 255;
    buffer2[index + 2] = size >> 16 & 255;
    buffer2[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
  }
  return index;
}
function serializeBinary(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var data = value.value(true);
  var size = value.position;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
    size = size + 4;
  buffer2[index++] = size & 255;
  buffer2[index++] = size >> 8 & 255;
  buffer2[index++] = size >> 16 & 255;
  buffer2[index++] = size >> 24 & 255;
  buffer2[index++] = value.sub_type;
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    buffer2[index++] = size & 255;
    buffer2[index++] = size >> 8 & 255;
    buffer2[index++] = size >> 16 & 255;
    buffer2[index++] = size >> 24 & 255;
  }
  buffer2.set(data, index);
  index = index + value.position;
  return index;
}
function serializeSymbol(buffer2, key, value, index, isArray) {
  buffer2[index++] = BSON_DATA_SYMBOL;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var size = buffer2.write(value.value, index + 4, void 0, "utf8") + 1;
  buffer2[index] = size & 255;
  buffer2[index + 1] = size >> 8 & 255;
  buffer2[index + 2] = size >> 16 & 255;
  buffer2[index + 3] = size >> 24 & 255;
  index = index + 4 + size - 1;
  buffer2[index++] = 0;
  return index;
}
function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, isArray) {
  buffer2[index++] = BSON_DATA_OBJECT;
  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, "utf8") : buffer2.write(key, index, void 0, "ascii");
  index = index + numberOfWrittenBytes;
  buffer2[index++] = 0;
  var startIndex = index;
  var output = {
    $ref: value.collection || value.namespace,
    $id: value.oid
  };
  if (value.db != null) {
    output.$db = value.db;
  }
  output = Object.assign(output, value.fields);
  var endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions);
  var size = endIndex - startIndex;
  buffer2[startIndex++] = size & 255;
  buffer2[startIndex++] = size >> 8 & 255;
  buffer2[startIndex++] = size >> 16 & 255;
  buffer2[startIndex++] = size >> 24 & 255;
  return endIndex;
}
function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
  if (checkKeys === void 0) {
    checkKeys = false;
  }
  if (startingIndex === void 0) {
    startingIndex = 0;
  }
  if (depth === void 0) {
    depth = 0;
  }
  if (serializeFunctions === void 0) {
    serializeFunctions = false;
  }
  if (ignoreUndefined === void 0) {
    ignoreUndefined = true;
  }
  if (path === void 0) {
    path = [];
  }
  startingIndex = startingIndex || 0;
  path = path || [];
  path.push(object);
  var index = startingIndex + 4;
  if (Array.isArray(object)) {
    for (var i2 = 0; i2 < object.length; i2++) {
      var key = "".concat(i2);
      var value = object[i2];
      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      if (typeof value === "string") {
        index = serializeString(buffer2, key, value, index, true);
      } else if (typeof value === "number") {
        index = serializeNumber(buffer2, key, value, index, true);
      } else if (typeof value === "bigint") {
        throw new BSONTypeError("Unsupported type BigInt, please use Decimal128");
      } else if (typeof value === "boolean") {
        index = serializeBoolean(buffer2, key, value, index, true);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer2, key, value, index, true);
      } else if (value === void 0) {
        index = serializeNull(buffer2, key, value, index, true);
      } else if (value === null) {
        index = serializeNull(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
        index = serializeObjectId(buffer2, key, value, index, true);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer2, key, value, index, true);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer2, key, value, index, true);
      } else if (typeof value === "object" && value["_bsontype"] == null) {
        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
      } else if (typeof value === "object" && isBSONType(value) && value._bsontype === "Decimal128") {
        index = serializeDecimal128(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
        index = serializeLong(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "Double") {
        index = serializeDouble(buffer2, key, value, index, true);
      } else if (typeof value === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, true);
      } else if (value["_bsontype"] === "Code") {
        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
      } else if (value["_bsontype"] === "Binary") {
        index = serializeBinary(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "Symbol") {
        index = serializeSymbol(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "DBRef") {
        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, true);
      } else if (value["_bsontype"] === "BSONRegExp") {
        index = serializeBSONRegExp(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "Int32") {
        index = serializeInt32(buffer2, key, value, index, true);
      } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
        index = serializeMinMax(buffer2, key, value, index, true);
      } else if (typeof value["_bsontype"] !== "undefined") {
        throw new BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
      }
    }
  } else if (object instanceof bsonMap || isMap(object)) {
    var iterator = object.entries();
    var done = false;
    while (!done) {
      var entry = iterator.next();
      done = !!entry.done;
      if (done)
        continue;
      var key = entry.value[0];
      var value = entry.value[1];
      var type = typeof value;
      if (typeof key === "string" && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          throw Error("key " + key + " must not contain null bytes");
        }
        if (checkKeys) {
          if ("$" === key[0]) {
            throw Error("key " + key + " must not start with '$'");
          } else if (~key.indexOf(".")) {
            throw Error("key " + key + " must not contain '.'");
          }
        }
      }
      if (type === "string") {
        index = serializeString(buffer2, key, value, index);
      } else if (type === "number") {
        index = serializeNumber(buffer2, key, value, index);
      } else if (type === "bigint" || isBigInt64Array(value) || isBigUInt64Array(value)) {
        throw new BSONTypeError("Unsupported type BigInt, please use Decimal128");
      } else if (type === "boolean") {
        index = serializeBoolean(buffer2, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer2, key, value, index);
      } else if (value === null || value === void 0 && ignoreUndefined === false) {
        index = serializeNull(buffer2, key, value, index);
      } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
        index = serializeObjectId(buffer2, key, value, index);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer2, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer2, key, value, index);
      } else if (type === "object" && value["_bsontype"] == null) {
        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
      } else if (type === "object" && value["_bsontype"] === "Decimal128") {
        index = serializeDecimal128(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
        index = serializeLong(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Double") {
        index = serializeDouble(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Code") {
        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if (typeof value === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value["_bsontype"] === "Binary") {
        index = serializeBinary(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Symbol") {
        index = serializeSymbol(buffer2, key, value, index);
      } else if (value["_bsontype"] === "DBRef") {
        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);
      } else if (value["_bsontype"] === "BSONRegExp") {
        index = serializeBSONRegExp(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Int32") {
        index = serializeInt32(buffer2, key, value, index);
      } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
        index = serializeMinMax(buffer2, key, value, index);
      } else if (typeof value["_bsontype"] !== "undefined") {
        throw new BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
      }
    }
  } else {
    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === "function") {
      object = object.toBSON();
      if (object != null && typeof object !== "object") {
        throw new BSONTypeError("toBSON function did not return an object");
      }
    }
    for (var key in object) {
      var value = object[key];
      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      var type = typeof value;
      if (typeof key === "string" && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          throw Error("key " + key + " must not contain null bytes");
        }
        if (checkKeys) {
          if ("$" === key[0]) {
            throw Error("key " + key + " must not start with '$'");
          } else if (~key.indexOf(".")) {
            throw Error("key " + key + " must not contain '.'");
          }
        }
      }
      if (type === "string") {
        index = serializeString(buffer2, key, value, index);
      } else if (type === "number") {
        index = serializeNumber(buffer2, key, value, index);
      } else if (type === "bigint") {
        throw new BSONTypeError("Unsupported type BigInt, please use Decimal128");
      } else if (type === "boolean") {
        index = serializeBoolean(buffer2, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer2, key, value, index);
      } else if (value === void 0) {
        if (ignoreUndefined === false)
          index = serializeNull(buffer2, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer2, key, value, index);
      } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
        index = serializeObjectId(buffer2, key, value, index);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer2, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer2, key, value, index);
      } else if (type === "object" && value["_bsontype"] == null) {
        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
      } else if (type === "object" && value["_bsontype"] === "Decimal128") {
        index = serializeDecimal128(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
        index = serializeLong(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Double") {
        index = serializeDouble(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Code") {
        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
      } else if (typeof value === "function" && serializeFunctions) {
        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value["_bsontype"] === "Binary") {
        index = serializeBinary(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Symbol") {
        index = serializeSymbol(buffer2, key, value, index);
      } else if (value["_bsontype"] === "DBRef") {
        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);
      } else if (value["_bsontype"] === "BSONRegExp") {
        index = serializeBSONRegExp(buffer2, key, value, index);
      } else if (value["_bsontype"] === "Int32") {
        index = serializeInt32(buffer2, key, value, index);
      } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
        index = serializeMinMax(buffer2, key, value, index);
      } else if (typeof value["_bsontype"] !== "undefined") {
        throw new BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
      }
    }
  }
  path.pop();
  buffer2[index++] = 0;
  var size = index - startingIndex;
  buffer2[startingIndex++] = size & 255;
  buffer2[startingIndex++] = size >> 8 & 255;
  buffer2[startingIndex++] = size >> 16 & 255;
  buffer2[startingIndex++] = size >> 24 & 255;
  return index;
}
function setInternalBufferSize(size) {
  if (buffer.length < size) {
    buffer = buffer_1.alloc(size);
  }
}
function serialize(object, options) {
  if (options === void 0) {
    options = {};
  }
  var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
  if (buffer.length < minInternalBufferSize) {
    buffer = buffer_1.alloc(minInternalBufferSize);
  }
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
  var finishedBuffer = buffer_1.alloc(serializationIndex);
  buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
  return finishedBuffer;
}
function serializeWithBufferAndIndex(object, finalBuffer, options) {
  if (options === void 0) {
    options = {};
  }
  var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  var startIndex = typeof options.index === "number" ? options.index : 0;
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined);
  buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
  return startIndex + serializationIndex - 1;
}
function deserialize(buffer2, options) {
  if (options === void 0) {
    options = {};
  }
  return deserialize$1(buffer2 instanceof buffer_1 ? buffer2 : ensureBuffer(buffer2), options);
}
function calculateObjectSize(object, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
  return calculateObjectSize$1(object, serializeFunctions, ignoreUndefined);
}
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  var internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
  var bufferData = ensureBuffer(data);
  var index = startIndex;
  for (var i2 = 0; i2 < numberOfDocuments; i2++) {
    var size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;
    internalOptions.index = index;
    documents[docStartIndex + i2] = deserialize$1(bufferData, internalOptions);
    index = index + size;
  }
  return index;
}
var byteLength_1, toByteArray_1, fromByteArray_1, lookup, revLookup, Arr, code, i2, len, base64Js, read, write, ieee754, buffer$1, buffer_1, _extendStatics, _assign, BSONError, BSONTypeError, insecureRandomBytes, detectRandomBytes, randomBytes, VALIDATION_REGEX, uuidValidateString, uuidHexStringToBuffer, bufferToUuidHexString, BSON_INT32_MAX$1, BSON_INT32_MIN$1, BSON_INT64_MAX$1, BSON_INT64_MIN$1, JS_INT_MAX, JS_INT_MIN, BSON_DATA_NUMBER, BSON_DATA_STRING, BSON_DATA_OBJECT, BSON_DATA_ARRAY, BSON_DATA_BINARY, BSON_DATA_UNDEFINED, BSON_DATA_OID, BSON_DATA_BOOLEAN, BSON_DATA_DATE, BSON_DATA_NULL, BSON_DATA_REGEXP, BSON_DATA_DBPOINTER, BSON_DATA_CODE, BSON_DATA_SYMBOL, BSON_DATA_CODE_W_SCOPE, BSON_DATA_INT, BSON_DATA_TIMESTAMP, BSON_DATA_LONG, BSON_DATA_DECIMAL128, BSON_DATA_MIN_KEY, BSON_DATA_MAX_KEY, BSON_BINARY_SUBTYPE_DEFAULT, BSON_BINARY_SUBTYPE_FUNCTION, BSON_BINARY_SUBTYPE_BYTE_ARRAY, BSON_BINARY_SUBTYPE_UUID, BSON_BINARY_SUBTYPE_UUID_NEW, BSON_BINARY_SUBTYPE_MD5, BSON_BINARY_SUBTYPE_ENCRYPTED, BSON_BINARY_SUBTYPE_COLUMN, BSON_BINARY_SUBTYPE_USER_DEFINED, Binary, UUID_BYTE_LENGTH, UUID, Code, DBRef, wasm, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, INT_CACHE, UINT_CACHE, Long, PARSE_STRING_REGEXP, PARSE_INF_REGEXP, PARSE_NAN_REGEXP, EXPONENT_MAX, EXPONENT_MIN, EXPONENT_BIAS, MAX_DIGITS, NAN_BUFFER, INF_NEGATIVE_BUFFER, INF_POSITIVE_BUFFER, EXPONENT_REGEX, COMBINATION_MASK, EXPONENT_MASK, COMBINATION_INFINITY, COMBINATION_NAN, Decimal128, Double, Int32, MaxKey, MinKey, checkForHexRegExp, PROCESS_UNIQUE, kId, ObjectId, BSONRegExp, BSONSymbol, LongWithoutOverridesClass, Timestamp, BSON_INT32_MAX, BSON_INT32_MIN, BSON_INT64_MAX, BSON_INT64_MIN, keysToCodecs, BSON_TYPE_MAPPINGS, EJSON, bsonMap, bsonGlobal, FIRST_BIT, FIRST_TWO_BITS, FIRST_THREE_BITS, FIRST_FOUR_BITS, FIRST_FIVE_BITS, TWO_BIT_CHAR, THREE_BIT_CHAR, FOUR_BIT_CHAR, CONTINUING_CHAR, JS_INT_MAX_LONG, JS_INT_MIN_LONG, functionCache, allowedDBRefKeys, regexp, ignoreKeys, SPACE_FOR_FLOAT64, DV_FOR_FLOAT64, MAXSIZE, buffer, BSON, bson_browser_esm_default;
var init_bson_browser_esm = __esm({
  "../node_modules/bson/dist/bson.browser.esm.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    byteLength_1 = byteLength;
    toByteArray_1 = toByteArray;
    fromByteArray_1 = fromByteArray;
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    base64Js = {
      byteLength: byteLength_1,
      toByteArray: toByteArray_1,
      fromByteArray: fromByteArray_1
    };
    read = function read2(buffer2, offset, isLE, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer2[offset + i2];
      i2 += d2;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    write = function write2(buffer2, value, offset, isLE, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d2] |= s2 * 128;
    };
    ieee754 = {
      read,
      write
    };
    buffer$1 = createCommonjsModule(function(module, exports) {
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? (
        // eslint-disable-line dot-notation
        Symbol["for"]("nodejs.util.inspect.custom")
      ) : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = {
            foo: function foo() {
              return 42;
            }
          };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function get2() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function get2() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + babelHelpers["typeof"](value));
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        var b2 = fromObject(value);
        if (b2)
          return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + babelHelpers["typeof"](value));
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength2(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a2, b2) {
        if (isInstance(a2, Uint8Array))
          a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
        if (isInstance(b2, Uint8Array))
          b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
        if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a2 === b2)
          return 0;
        var x2 = a2.length;
        var y2 = b2.length;
        for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
          if (a2[i2] !== b2[i2]) {
            x2 = a2[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        var buffer2 = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          var buf = list[i2];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              Buffer2.from(buf).copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(buffer2, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength2(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + babelHelpers["typeof"](string));
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength2;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b2, n2, m2) {
        var i2 = b2[n2];
        b2[n2] = b2[m2];
        b2[m2] = i2;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i2 = 0; i2 < len; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b2) {
        if (!Buffer2.isBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + babelHelpers["typeof"](target));
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i2 = 0; i2 < len; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val2, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val2 === "string") {
          val2 = Buffer2.from(val2, encoding);
        }
        if (Buffer2.isBuffer(val2)) {
          if (val2.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val2, byteOffset, encoding, dir);
        } else if (typeof val2 === "number") {
          val2 = val2 & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val2, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val2, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val2], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val2.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val2.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read3(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        var i2;
        if (dir) {
          var foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read3(arr, i2) === read3(val2, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            var found = true;
            for (var j2 = 0; j2 < valLength; j2++) {
              if (read3(arr, i2 + j2) !== read3(val2, j2)) {
                found = false;
                break;
              }
            }
            if (found)
              return i2;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
        return this.indexOf(val2, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i2 = 0; i2 < length; ++i2) {
          var parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write3(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64Js.fromByteArray(buf);
        } else {
          return base64Js.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i2 = start;
        while (i2 < end) {
          var firstByte = buf[i2];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i2 = 0;
        while (i2 < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i2 = start; i2 < end; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var val2 = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val2 += this[offset + i2] * mul;
        }
        return val2;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        var val2 = this[offset + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val2 += this[offset + --byteLength3] * mul;
        }
        return val2;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var val2 = this[offset];
        var mul = 1;
        var i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val2 += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val2 >= mul)
          val2 -= Math.pow(2, 8 * byteLength3);
        return val2;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        var i2 = byteLength3;
        var mul = 1;
        var val2 = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val2 += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val2 >= mul)
          val2 -= Math.pow(2, 8 * byteLength3);
        return val2;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val2 = this[offset] | this[offset + 1] << 8;
        return val2 & 32768 ? val2 | 4294901760 : val2;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val2 = this[offset + 1] | this[offset] << 8;
        return val2 & 32768 ? val2 | 4294901760 : val2;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        var i2 = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val2, start, end, encoding) {
        if (typeof val2 === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val2.length === 1) {
            var code2 = val2.charCodeAt(0);
            if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
              val2 = code2;
            }
          }
        } else if (typeof val2 === "number") {
          val2 = val2 & 255;
        } else if (typeof val2 === "boolean") {
          val2 = Number(val2);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val2)
          val2 = 0;
        var i2;
        if (typeof val2 === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val2;
          }
        } else {
          var bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c2, hi, lo;
        var byteArray = [];
        for (var i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0)
            break;
          c2 = str.charCodeAt(i2);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64Js.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src.length)
            break;
          dst[i2 + offset] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i2 = 0; i2 < 16; ++i2) {
          var i16 = i2 * 16;
          for (var j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i2] + alphabet[j2];
          }
        }
        return table;
      }();
    });
    buffer_1 = buffer$1.Buffer;
    buffer$1.SlowBuffer;
    buffer$1.INSPECT_MAX_BYTES;
    buffer$1.kMaxLength;
    _extendStatics = function extendStatics(d2, b2) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) {
          if (b3.hasOwnProperty(p2))
            d3[p2] = b3[p2];
        }
      };
      return _extendStatics(d2, b2);
    };
    _assign = function __assign() {
      _assign = Object.assign || function __assign2(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) {
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
          }
        }
        return t2;
      };
      return _assign.apply(this, arguments);
    };
    BSONError = /** @class */
    function(_super) {
      __extends(BSONError2, _super);
      function BSONError2(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, BSONError2.prototype);
        return _this;
      }
      Object.defineProperty(BSONError2.prototype, "name", {
        get: function() {
          return "BSONError";
        },
        enumerable: false,
        configurable: true
      });
      return BSONError2;
    }(Error);
    BSONTypeError = /** @class */
    function(_super) {
      __extends(BSONTypeError2, _super);
      function BSONTypeError2(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, BSONTypeError2.prototype);
        return _this;
      }
      Object.defineProperty(BSONTypeError2.prototype, "name", {
        get: function() {
          return "BSONTypeError";
        },
        enumerable: false,
        configurable: true
      });
      return BSONTypeError2;
    }(TypeError);
    insecureRandomBytes = function insecureRandomBytes2(size) {
      var insecureWarning = isReactNative() ? "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values." : "BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.";
      console.warn(insecureWarning);
      var result = buffer_1.alloc(size);
      for (var i2 = 0; i2 < size; ++i2)
        result[i2] = Math.floor(Math.random() * 256);
      return result;
    };
    detectRandomBytes = function() {
      {
        if (typeof window !== "undefined") {
          var target_1 = window.crypto || window.msCrypto;
          if (target_1 && target_1.getRandomValues) {
            return function(size) {
              return target_1.getRandomValues(buffer_1.alloc(size));
            };
          }
        }
        if (typeof global !== "undefined" && global.crypto && global.crypto.getRandomValues) {
          return function(size) {
            return global.crypto.getRandomValues(buffer_1.alloc(size));
          };
        }
        return insecureRandomBytes;
      }
    };
    randomBytes = detectRandomBytes();
    VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
    uuidValidateString = function(str) {
      return typeof str === "string" && VALIDATION_REGEX.test(str);
    };
    uuidHexStringToBuffer = function(hexString) {
      if (!uuidValidateString(hexString)) {
        throw new BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
      }
      var sanitizedHexString = hexString.replace(/-/g, "");
      return buffer_1.from(sanitizedHexString, "hex");
    };
    bufferToUuidHexString = function(buffer2, includeDashes) {
      if (includeDashes === void 0) {
        includeDashes = true;
      }
      return includeDashes ? buffer2.toString("hex", 0, 4) + "-" + buffer2.toString("hex", 4, 6) + "-" + buffer2.toString("hex", 6, 8) + "-" + buffer2.toString("hex", 8, 10) + "-" + buffer2.toString("hex", 10, 16) : buffer2.toString("hex");
    };
    BSON_INT32_MAX$1 = 2147483647;
    BSON_INT32_MIN$1 = -2147483648;
    BSON_INT64_MAX$1 = Math.pow(2, 63) - 1;
    BSON_INT64_MIN$1 = -Math.pow(2, 63);
    JS_INT_MAX = Math.pow(2, 53);
    JS_INT_MIN = -Math.pow(2, 53);
    BSON_DATA_NUMBER = 1;
    BSON_DATA_STRING = 2;
    BSON_DATA_OBJECT = 3;
    BSON_DATA_ARRAY = 4;
    BSON_DATA_BINARY = 5;
    BSON_DATA_UNDEFINED = 6;
    BSON_DATA_OID = 7;
    BSON_DATA_BOOLEAN = 8;
    BSON_DATA_DATE = 9;
    BSON_DATA_NULL = 10;
    BSON_DATA_REGEXP = 11;
    BSON_DATA_DBPOINTER = 12;
    BSON_DATA_CODE = 13;
    BSON_DATA_SYMBOL = 14;
    BSON_DATA_CODE_W_SCOPE = 15;
    BSON_DATA_INT = 16;
    BSON_DATA_TIMESTAMP = 17;
    BSON_DATA_LONG = 18;
    BSON_DATA_DECIMAL128 = 19;
    BSON_DATA_MIN_KEY = 255;
    BSON_DATA_MAX_KEY = 127;
    BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON_BINARY_SUBTYPE_UUID = 3;
    BSON_BINARY_SUBTYPE_UUID_NEW = 4;
    BSON_BINARY_SUBTYPE_MD5 = 5;
    BSON_BINARY_SUBTYPE_ENCRYPTED = 6;
    BSON_BINARY_SUBTYPE_COLUMN = 7;
    BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    Binary = /** @class */
    function() {
      function Binary2(buffer2, subType) {
        if (!(this instanceof Binary2))
          return new Binary2(buffer2, subType);
        if (!(buffer2 == null) && !(typeof buffer2 === "string") && !ArrayBuffer.isView(buffer2) && !(buffer2 instanceof ArrayBuffer) && !Array.isArray(buffer2)) {
          throw new BSONTypeError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");
        }
        this.sub_type = subType !== null && subType !== void 0 ? subType : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer2 == null) {
          this.buffer = buffer_1.alloc(Binary2.BUFFER_SIZE);
          this.position = 0;
        } else {
          if (typeof buffer2 === "string") {
            this.buffer = buffer_1.from(buffer2, "binary");
          } else if (Array.isArray(buffer2)) {
            this.buffer = buffer_1.from(buffer2);
          } else {
            this.buffer = ensureBuffer(buffer2);
          }
          this.position = this.buffer.byteLength;
        }
      }
      Binary2.prototype.put = function(byteValue) {
        if (typeof byteValue === "string" && byteValue.length !== 1) {
          throw new BSONTypeError("only accepts single character String");
        } else if (typeof byteValue !== "number" && byteValue.length !== 1)
          throw new BSONTypeError("only accepts single character Uint8Array or Array");
        var decodedByte;
        if (typeof byteValue === "string") {
          decodedByte = byteValue.charCodeAt(0);
        } else if (typeof byteValue === "number") {
          decodedByte = byteValue;
        } else {
          decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
          throw new BSONTypeError("only accepts number in a valid unsigned byte range 0-255");
        }
        if (this.buffer.length > this.position) {
          this.buffer[this.position++] = decodedByte;
        } else {
          var buffer2 = buffer_1.alloc(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer2, 0, 0, this.buffer.length);
          this.buffer = buffer2;
          this.buffer[this.position++] = decodedByte;
        }
      };
      Binary2.prototype.write = function(sequence, offset) {
        offset = typeof offset === "number" ? offset : this.position;
        if (this.buffer.length < offset + sequence.length) {
          var buffer2 = buffer_1.alloc(this.buffer.length + sequence.length);
          this.buffer.copy(buffer2, 0, 0, this.buffer.length);
          this.buffer = buffer2;
        }
        if (ArrayBuffer.isView(sequence)) {
          this.buffer.set(ensureBuffer(sequence), offset);
          this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        } else if (typeof sequence === "string") {
          this.buffer.write(sequence, offset, sequence.length, "binary");
          this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;
        }
      };
      Binary2.prototype.read = function(position, length) {
        length = length && length > 0 ? length : this.position;
        return this.buffer.slice(position, position + length);
      };
      Binary2.prototype.value = function(asRaw) {
        asRaw = !!asRaw;
        if (asRaw && this.buffer.length === this.position) {
          return this.buffer;
        }
        if (asRaw) {
          return this.buffer.slice(0, this.position);
        }
        return this.buffer.toString("binary", 0, this.position);
      };
      Binary2.prototype.length = function() {
        return this.position;
      };
      Binary2.prototype.toJSON = function() {
        return this.buffer.toString("base64");
      };
      Binary2.prototype.toString = function(format) {
        return this.buffer.toString(format);
      };
      Binary2.prototype.toExtendedJSON = function(options) {
        options = options || {};
        var base64String = this.buffer.toString("base64");
        var subType = Number(this.sub_type).toString(16);
        if (options.legacy) {
          return {
            $binary: base64String,
            $type: subType.length === 1 ? "0" + subType : subType
          };
        }
        return {
          $binary: {
            base64: base64String,
            subType: subType.length === 1 ? "0" + subType : subType
          }
        };
      };
      Binary2.prototype.toUUID = function() {
        if (this.sub_type === Binary2.SUBTYPE_UUID) {
          return new UUID(this.buffer.slice(0, this.position));
        }
        throw new BSONError('Binary sub_type "'.concat(this.sub_type, '" is not supported for converting to UUID. Only "').concat(Binary2.SUBTYPE_UUID, '" is currently supported.'));
      };
      Binary2.fromExtendedJSON = function(doc, options) {
        options = options || {};
        var data;
        var type;
        if ("$binary" in doc) {
          if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
            type = doc.$type ? parseInt(doc.$type, 16) : 0;
            data = buffer_1.from(doc.$binary, "base64");
          } else {
            if (typeof doc.$binary !== "string") {
              type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
              data = buffer_1.from(doc.$binary.base64, "base64");
            }
          }
        } else if ("$uuid" in doc) {
          type = 4;
          data = uuidHexStringToBuffer(doc.$uuid);
        }
        if (!data) {
          throw new BSONTypeError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
        }
        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary2(data, type);
      };
      Binary2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Binary2.prototype.inspect = function() {
        var asBuffer = this.value(true);
        return 'new Binary(Buffer.from("'.concat(asBuffer.toString("hex"), '", "hex"), ').concat(this.sub_type, ")");
      };
      Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
      Binary2.BUFFER_SIZE = 256;
      Binary2.SUBTYPE_DEFAULT = 0;
      Binary2.SUBTYPE_FUNCTION = 1;
      Binary2.SUBTYPE_BYTE_ARRAY = 2;
      Binary2.SUBTYPE_UUID_OLD = 3;
      Binary2.SUBTYPE_UUID = 4;
      Binary2.SUBTYPE_MD5 = 5;
      Binary2.SUBTYPE_ENCRYPTED = 6;
      Binary2.SUBTYPE_COLUMN = 7;
      Binary2.SUBTYPE_USER_DEFINED = 128;
      return Binary2;
    }();
    Object.defineProperty(Binary.prototype, "_bsontype", { value: "Binary" });
    UUID_BYTE_LENGTH = 16;
    UUID = /** @class */
    function(_super) {
      __extends(UUID2, _super);
      function UUID2(input) {
        var _this = this;
        var bytes;
        var hexStr;
        if (input == null) {
          bytes = UUID2.generate();
        } else if (input instanceof UUID2) {
          bytes = buffer_1.from(input.buffer);
          hexStr = input.__id;
        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
          bytes = ensureBuffer(input);
        } else if (typeof input === "string") {
          bytes = uuidHexStringToBuffer(input);
        } else {
          throw new BSONTypeError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
        }
        _this = _super.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW) || this;
        _this.__id = hexStr;
        return _this;
      }
      Object.defineProperty(UUID2.prototype, "id", {
        /**
         * The UUID bytes
         * @readonly
         */
        get: function() {
          return this.buffer;
        },
        set: function(value) {
          this.buffer = value;
          if (UUID2.cacheHexString) {
            this.__id = bufferToUuidHexString(value);
          }
        },
        enumerable: false,
        configurable: true
      });
      UUID2.prototype.toHexString = function(includeDashes) {
        if (includeDashes === void 0) {
          includeDashes = true;
        }
        if (UUID2.cacheHexString && this.__id) {
          return this.__id;
        }
        var uuidHexString = bufferToUuidHexString(this.id, includeDashes);
        if (UUID2.cacheHexString) {
          this.__id = uuidHexString;
        }
        return uuidHexString;
      };
      UUID2.prototype.toString = function(encoding) {
        return encoding ? this.id.toString(encoding) : this.toHexString();
      };
      UUID2.prototype.toJSON = function() {
        return this.toHexString();
      };
      UUID2.prototype.equals = function(otherId) {
        if (!otherId) {
          return false;
        }
        if (otherId instanceof UUID2) {
          return otherId.id.equals(this.id);
        }
        try {
          return new UUID2(otherId).id.equals(this.id);
        } catch (_a2) {
          return false;
        }
      };
      UUID2.prototype.toBinary = function() {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
      };
      UUID2.generate = function() {
        var bytes = randomBytes(UUID_BYTE_LENGTH);
        bytes[6] = bytes[6] & 15 | 64;
        bytes[8] = bytes[8] & 63 | 128;
        return buffer_1.from(bytes);
      };
      UUID2.isValid = function(input) {
        if (!input) {
          return false;
        }
        if (input instanceof UUID2) {
          return true;
        }
        if (typeof input === "string") {
          return uuidValidateString(input);
        }
        if (isUint8Array(input)) {
          if (input.length !== UUID_BYTE_LENGTH) {
            return false;
          }
          return (input[6] & 240) === 64 && (input[8] & 128) === 128;
        }
        return false;
      };
      UUID2.createFromHexString = function(hexString) {
        var buffer2 = uuidHexStringToBuffer(hexString);
        return new UUID2(buffer2);
      };
      UUID2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      UUID2.prototype.inspect = function() {
        return 'new UUID("'.concat(this.toHexString(), '")');
      };
      return UUID2;
    }(Binary);
    Code = /** @class */
    function() {
      function Code2(code2, scope) {
        if (!(this instanceof Code2))
          return new Code2(code2, scope);
        this.code = code2;
        this.scope = scope;
      }
      Code2.prototype.toJSON = function() {
        return { code: this.code, scope: this.scope };
      };
      Code2.prototype.toExtendedJSON = function() {
        if (this.scope) {
          return { $code: this.code, $scope: this.scope };
        }
        return { $code: this.code };
      };
      Code2.fromExtendedJSON = function(doc) {
        return new Code2(doc.$code, doc.$scope);
      };
      Code2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Code2.prototype.inspect = function() {
        var codeJson = this.toJSON();
        return 'new Code("'.concat(String(codeJson.code), '"').concat(codeJson.scope ? ", ".concat(JSON.stringify(codeJson.scope)) : "", ")");
      };
      return Code2;
    }();
    Object.defineProperty(Code.prototype, "_bsontype", { value: "Code" });
    DBRef = /** @class */
    function() {
      function DBRef2(collection, oid, db, fields) {
        if (!(this instanceof DBRef2))
          return new DBRef2(collection, oid, db, fields);
        var parts = collection.split(".");
        if (parts.length === 2) {
          db = parts.shift();
          collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
      }
      Object.defineProperty(DBRef2.prototype, "namespace", {
        // Property provided for compatibility with the 1.x parser
        // the 1.x parser used a "namespace" property, while 4.x uses "collection"
        /** @internal */
        get: function() {
          return this.collection;
        },
        set: function(value) {
          this.collection = value;
        },
        enumerable: false,
        configurable: true
      });
      DBRef2.prototype.toJSON = function() {
        var o2 = Object.assign({
          $ref: this.collection,
          $id: this.oid
        }, this.fields);
        if (this.db != null)
          o2.$db = this.db;
        return o2;
      };
      DBRef2.prototype.toExtendedJSON = function(options) {
        options = options || {};
        var o2 = {
          $ref: this.collection,
          $id: this.oid
        };
        if (options.legacy) {
          return o2;
        }
        if (this.db)
          o2.$db = this.db;
        o2 = Object.assign(o2, this.fields);
        return o2;
      };
      DBRef2.fromExtendedJSON = function(doc) {
        var copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);
      };
      DBRef2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      DBRef2.prototype.inspect = function() {
        var oid = this.oid === void 0 || this.oid.toString === void 0 ? this.oid : this.oid.toString();
        return 'new DBRef("'.concat(this.namespace, '", new ObjectId("').concat(String(oid), '")').concat(this.db ? ', "'.concat(this.db, '"') : "", ")");
      };
      return DBRef2;
    }();
    Object.defineProperty(DBRef.prototype, "_bsontype", { value: "DBRef" });
    wasm = void 0;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(
        // prettier-ignore
        new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])
      ), {}).exports;
    } catch (_a2) {
    }
    TWO_PWR_16_DBL = 1 << 16;
    TWO_PWR_24_DBL = 1 << 24;
    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    INT_CACHE = {};
    UINT_CACHE = {};
    Long = /** @class */
    function() {
      function Long2(low, high, unsigned) {
        if (low === void 0) {
          low = 0;
        }
        if (!(this instanceof Long2))
          return new Long2(low, high, unsigned);
        if (typeof low === "bigint") {
          Object.assign(this, Long2.fromBigInt(low, !!high));
        } else if (typeof low === "string") {
          Object.assign(this, Long2.fromString(low, !!high));
        } else {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Object.defineProperty(this, "__isLong__", {
          value: true,
          configurable: false,
          writable: false,
          enumerable: false
        });
      }
      Long2.fromBits = function(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      };
      Long2.fromInt = function(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      };
      Long2.fromNumber = function(value, unsigned) {
        if (isNaN(value))
          return unsigned ? Long2.UZERO : Long2.ZERO;
        if (unsigned) {
          if (value < 0)
            return Long2.UZERO;
          if (value >= TWO_PWR_64_DBL)
            return Long2.MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return Long2.MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return Long2.MAX_VALUE;
        }
        if (value < 0)
          return Long2.fromNumber(-value, unsigned).neg();
        return Long2.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      };
      Long2.fromBigInt = function(value, unsigned) {
        return Long2.fromString(value.toString(), unsigned);
      };
      Long2.fromString = function(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return Long2.ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p2;
        if ((p2 = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p2 === 0) {
          return Long2.fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
        var result = Long2.ZERO;
        for (var i2 = 0; i2 < str.length; i2 += 8) {
          var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
          if (size < 8) {
            var power = Long2.fromNumber(Math.pow(radix, size));
            result = result.mul(power).add(Long2.fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(Long2.fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      };
      Long2.fromBytes = function(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      Long2.isLong = function(value) {
        return isObjectLike(value) && value["__isLong__"] === true;
      };
      Long2.fromValue = function(val2, unsigned) {
        if (typeof val2 === "number")
          return Long2.fromNumber(val2, unsigned);
        if (typeof val2 === "string")
          return Long2.fromString(val2, unsigned);
        return Long2.fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
      };
      Long2.prototype.add = function(addend) {
        if (!Long2.isLong(addend))
          addend = Long2.fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      Long2.prototype.and = function(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      Long2.prototype.compare = function(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      Long2.prototype.comp = function(other) {
        return this.compare(other);
      };
      Long2.prototype.divide = function(divisor) {
        if (!Long2.isLong(divisor))
          divisor = Long2.fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return Long2.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? Long2.UZERO : Long2.ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(Long2.MIN_VALUE)) {
            if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))
              return Long2.MIN_VALUE;
            else if (divisor.eq(Long2.MIN_VALUE))
              return Long2.ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(Long2.ZERO)) {
                return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(Long2.MIN_VALUE))
            return this.unsigned ? Long2.UZERO : Long2.ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = Long2.ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return Long2.UZERO;
          if (divisor.gt(this.shru(1)))
            return Long2.UONE;
          res = Long2.UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2);
          var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          var approxRes = Long2.fromNumber(approx);
          var approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = Long2.fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = Long2.ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      Long2.prototype.div = function(divisor) {
        return this.divide(divisor);
      };
      Long2.prototype.equals = function(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      Long2.prototype.eq = function(other) {
        return this.equals(other);
      };
      Long2.prototype.getHighBits = function() {
        return this.high;
      };
      Long2.prototype.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      };
      Long2.prototype.getLowBits = function() {
        return this.low;
      };
      Long2.prototype.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      };
      Long2.prototype.getNumBitsAbs = function() {
        if (this.isNegative()) {
          return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        }
        var val2 = this.high !== 0 ? this.high : this.low;
        var bit;
        for (bit = 31; bit > 0; bit--)
          if ((val2 & 1 << bit) !== 0)
            break;
        return this.high !== 0 ? bit + 33 : bit + 1;
      };
      Long2.prototype.greaterThan = function(other) {
        return this.comp(other) > 0;
      };
      Long2.prototype.gt = function(other) {
        return this.greaterThan(other);
      };
      Long2.prototype.greaterThanOrEqual = function(other) {
        return this.comp(other) >= 0;
      };
      Long2.prototype.gte = function(other) {
        return this.greaterThanOrEqual(other);
      };
      Long2.prototype.ge = function(other) {
        return this.greaterThanOrEqual(other);
      };
      Long2.prototype.isEven = function() {
        return (this.low & 1) === 0;
      };
      Long2.prototype.isNegative = function() {
        return !this.unsigned && this.high < 0;
      };
      Long2.prototype.isOdd = function() {
        return (this.low & 1) === 1;
      };
      Long2.prototype.isPositive = function() {
        return this.unsigned || this.high >= 0;
      };
      Long2.prototype.isZero = function() {
        return this.high === 0 && this.low === 0;
      };
      Long2.prototype.lessThan = function(other) {
        return this.comp(other) < 0;
      };
      Long2.prototype.lt = function(other) {
        return this.lessThan(other);
      };
      Long2.prototype.lessThanOrEqual = function(other) {
        return this.comp(other) <= 0;
      };
      Long2.prototype.lte = function(other) {
        return this.lessThanOrEqual(other);
      };
      Long2.prototype.modulo = function(divisor) {
        if (!Long2.isLong(divisor))
          divisor = Long2.fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return Long2.fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      Long2.prototype.mod = function(divisor) {
        return this.modulo(divisor);
      };
      Long2.prototype.rem = function(divisor) {
        return this.modulo(divisor);
      };
      Long2.prototype.multiply = function(multiplier) {
        if (this.isZero())
          return Long2.ZERO;
        if (!Long2.isLong(multiplier))
          multiplier = Long2.fromValue(multiplier);
        if (wasm) {
          var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return Long2.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return Long2.ZERO;
        if (this.eq(Long2.MIN_VALUE))
          return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
        if (multiplier.eq(Long2.MIN_VALUE))
          return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))
          return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      Long2.prototype.mul = function(multiplier) {
        return this.multiply(multiplier);
      };
      Long2.prototype.negate = function() {
        if (!this.unsigned && this.eq(Long2.MIN_VALUE))
          return Long2.MIN_VALUE;
        return this.not().add(Long2.ONE);
      };
      Long2.prototype.neg = function() {
        return this.negate();
      };
      Long2.prototype.not = function() {
        return Long2.fromBits(~this.low, ~this.high, this.unsigned);
      };
      Long2.prototype.notEquals = function(other) {
        return !this.equals(other);
      };
      Long2.prototype.neq = function(other) {
        return this.notEquals(other);
      };
      Long2.prototype.ne = function(other) {
        return this.notEquals(other);
      };
      Long2.prototype.or = function(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      Long2.prototype.shiftLeft = function(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      Long2.prototype.shl = function(numBits) {
        return this.shiftLeft(numBits);
      };
      Long2.prototype.shiftRight = function(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      Long2.prototype.shr = function(numBits) {
        return this.shiftRight(numBits);
      };
      Long2.prototype.shiftRightUnsigned = function(numBits) {
        if (Long2.isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return Long2.fromBits(high, 0, this.unsigned);
          else
            return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      Long2.prototype.shr_u = function(numBits) {
        return this.shiftRightUnsigned(numBits);
      };
      Long2.prototype.shru = function(numBits) {
        return this.shiftRightUnsigned(numBits);
      };
      Long2.prototype.subtract = function(subtrahend) {
        if (!Long2.isLong(subtrahend))
          subtrahend = Long2.fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      Long2.prototype.sub = function(subtrahend) {
        return this.subtract(subtrahend);
      };
      Long2.prototype.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      Long2.prototype.toNumber = function() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      Long2.prototype.toBigInt = function() {
        return BigInt(this.toString());
      };
      Long2.prototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      Long2.prototype.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      Long2.prototype.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long2.prototype.toSigned = function() {
        if (!this.unsigned)
          return this;
        return Long2.fromBits(this.low, this.high, false);
      };
      Long2.prototype.toString = function(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(Long2.MIN_VALUE)) {
            var radixLong = Long2.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);
        var rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower);
          var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
          var digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) {
            return digits + result;
          } else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      Long2.prototype.toUnsigned = function() {
        if (this.unsigned)
          return this;
        return Long2.fromBits(this.low, this.high, true);
      };
      Long2.prototype.xor = function(other) {
        if (!Long2.isLong(other))
          other = Long2.fromValue(other);
        return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      Long2.prototype.eqz = function() {
        return this.isZero();
      };
      Long2.prototype.le = function(other) {
        return this.lessThanOrEqual(other);
      };
      Long2.prototype.toExtendedJSON = function(options) {
        if (options && options.relaxed)
          return this.toNumber();
        return { $numberLong: this.toString() };
      };
      Long2.fromExtendedJSON = function(doc, options) {
        var result = Long2.fromString(doc.$numberLong);
        return options && options.relaxed ? result.toNumber() : result;
      };
      Long2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Long2.prototype.inspect = function() {
        return 'new Long("'.concat(this.toString(), '"').concat(this.unsigned ? ", true" : "", ")");
      };
      Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);
      Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.ZERO = Long2.fromInt(0);
      Long2.UZERO = Long2.fromInt(0, true);
      Long2.ONE = Long2.fromInt(1);
      Long2.UONE = Long2.fromInt(1, true);
      Long2.NEG_ONE = Long2.fromInt(-1);
      Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
      return Long2;
    }();
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    Object.defineProperty(Long.prototype, "_bsontype", { value: "Long" });
    PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    EXPONENT_MAX = 6111;
    EXPONENT_MIN = -6176;
    EXPONENT_BIAS = 6176;
    MAX_DIGITS = 34;
    NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    COMBINATION_MASK = 31;
    EXPONENT_MASK = 16383;
    COMBINATION_INFINITY = 30;
    COMBINATION_NAN = 31;
    Decimal128 = /** @class */
    function() {
      function Decimal1282(bytes) {
        if (!(this instanceof Decimal1282))
          return new Decimal1282(bytes);
        if (typeof bytes === "string") {
          this.bytes = Decimal1282.fromString(bytes).bytes;
        } else if (isUint8Array(bytes)) {
          if (bytes.byteLength !== 16) {
            throw new BSONTypeError("Decimal128 must take a Buffer of 16 bytes");
          }
          this.bytes = bytes;
        } else {
          throw new BSONTypeError("Decimal128 must take a Buffer or string");
        }
      }
      Decimal1282.fromString = function(representation) {
        var isNegative = false;
        var sawRadix = false;
        var foundNonZero = false;
        var significantDigits = 0;
        var nDigitsRead = 0;
        var nDigits = 0;
        var radixPosition = 0;
        var firstNonZero = 0;
        var digits = [0];
        var nDigitsStored = 0;
        var digitsInsert = 0;
        var firstDigit = 0;
        var lastDigit = 0;
        var exponent = 0;
        var i2 = 0;
        var significandHigh = new Long(0, 0);
        var significandLow = new Long(0, 0);
        var biasedExponent = 0;
        var index = 0;
        if (representation.length >= 7e3) {
          throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
        }
        var stringMatch = representation.match(PARSE_STRING_REGEXP);
        var infMatch = representation.match(PARSE_INF_REGEXP);
        var nanMatch = representation.match(PARSE_NAN_REGEXP);
        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
          throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
        }
        if (stringMatch) {
          var unsignedNumber = stringMatch[2];
          var e2 = stringMatch[4];
          var expSign = stringMatch[5];
          var expNumber = stringMatch[6];
          if (e2 && expNumber === void 0)
            invalidErr(representation, "missing exponent power");
          if (e2 && unsignedNumber === void 0)
            invalidErr(representation, "missing exponent base");
          if (e2 === void 0 && (expSign || expNumber)) {
            invalidErr(representation, "missing e before exponent");
          }
        }
        if (representation[index] === "+" || representation[index] === "-") {
          isNegative = representation[index++] === "-";
        }
        if (!isDigit(representation[index]) && representation[index] !== ".") {
          if (representation[index] === "i" || representation[index] === "I") {
            return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          } else if (representation[index] === "N") {
            return new Decimal1282(buffer_1.from(NAN_BUFFER));
          }
        }
        while (isDigit(representation[index]) || representation[index] === ".") {
          if (representation[index] === ".") {
            if (sawRadix)
              invalidErr(representation, "contains multiple periods");
            sawRadix = true;
            index = index + 1;
            continue;
          }
          if (nDigitsStored < 34) {
            if (representation[index] !== "0" || foundNonZero) {
              if (!foundNonZero) {
                firstNonZero = nDigitsRead;
              }
              foundNonZero = true;
              digits[digitsInsert++] = parseInt(representation[index], 10);
              nDigitsStored = nDigitsStored + 1;
            }
          }
          if (foundNonZero)
            nDigits = nDigits + 1;
          if (sawRadix)
            radixPosition = radixPosition + 1;
          nDigitsRead = nDigitsRead + 1;
          index = index + 1;
        }
        if (sawRadix && !nDigitsRead)
          throw new BSONTypeError("" + representation + " not a valid Decimal128 string");
        if (representation[index] === "e" || representation[index] === "E") {
          var match2 = representation.substr(++index).match(EXPONENT_REGEX);
          if (!match2 || !match2[2])
            return new Decimal1282(buffer_1.from(NAN_BUFFER));
          exponent = parseInt(match2[0], 10);
          index = index + match2[0].length;
        }
        if (representation[index])
          return new Decimal1282(buffer_1.from(NAN_BUFFER));
        firstDigit = 0;
        if (!nDigitsStored) {
          firstDigit = 0;
          lastDigit = 0;
          digits[0] = 0;
          nDigits = 1;
          nDigitsStored = 1;
          significantDigits = 0;
        } else {
          lastDigit = nDigitsStored - 1;
          significantDigits = nDigits;
          if (significantDigits !== 1) {
            while (digits[firstNonZero + significantDigits - 1] === 0) {
              significantDigits = significantDigits - 1;
            }
          }
        }
        if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
          exponent = EXPONENT_MIN;
        } else {
          exponent = exponent - radixPosition;
        }
        while (exponent > EXPONENT_MAX) {
          lastDigit = lastDigit + 1;
          if (lastDigit - firstDigit > MAX_DIGITS) {
            var digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
          exponent = exponent - 1;
        }
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            var digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit - firstDigit + 1 < significantDigits) {
          var endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (isNegative) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          var roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (i2 = firstNonZero + lastDigit + 2; i2 < endOfString; i2++) {
                if (parseInt(representation[i2], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            var dIdx = lastDigit;
            for (; dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                  }
                }
              }
            }
          }
        }
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
        if (significantDigits === 0) {
          significandHigh = Long.fromNumber(0);
          significandLow = Long.fromNumber(0);
        } else if (lastDigit - firstDigit < 17) {
          var dIdx = firstDigit;
          significandLow = Long.fromNumber(digits[dIdx++]);
          significandHigh = new Long(0, 0);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        } else {
          var dIdx = firstDigit;
          significandHigh = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit - 17; dIdx++) {
            significandHigh = significandHigh.multiply(Long.fromNumber(10));
            significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
          }
          significandLow = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        }
        var significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
        significand.low = significand.low.add(significandLow);
        if (lessThan(significand.low, significandLow)) {
          significand.high = significand.high.add(Long.fromNumber(1));
        }
        biasedExponent = exponent + EXPONENT_BIAS;
        var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
          dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
          dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
        } else {
          dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
        }
        dec.low = significand.low;
        if (isNegative) {
          dec.high = dec.high.or(Long.fromString("9223372036854775808"));
        }
        var buffer2 = buffer_1.alloc(16);
        index = 0;
        buffer2[index++] = dec.low.low & 255;
        buffer2[index++] = dec.low.low >> 8 & 255;
        buffer2[index++] = dec.low.low >> 16 & 255;
        buffer2[index++] = dec.low.low >> 24 & 255;
        buffer2[index++] = dec.low.high & 255;
        buffer2[index++] = dec.low.high >> 8 & 255;
        buffer2[index++] = dec.low.high >> 16 & 255;
        buffer2[index++] = dec.low.high >> 24 & 255;
        buffer2[index++] = dec.high.low & 255;
        buffer2[index++] = dec.high.low >> 8 & 255;
        buffer2[index++] = dec.high.low >> 16 & 255;
        buffer2[index++] = dec.high.low >> 24 & 255;
        buffer2[index++] = dec.high.high & 255;
        buffer2[index++] = dec.high.high >> 8 & 255;
        buffer2[index++] = dec.high.high >> 16 & 255;
        buffer2[index++] = dec.high.high >> 24 & 255;
        return new Decimal1282(buffer2);
      };
      Decimal1282.prototype.toString = function() {
        var biased_exponent;
        var significand_digits = 0;
        var significand = new Array(36);
        for (var i2 = 0; i2 < significand.length; i2++)
          significand[i2] = 0;
        var index = 0;
        var is_zero = false;
        var significand_msb;
        var significand128 = { parts: [0, 0, 0, 0] };
        var j2, k2;
        var string = [];
        index = 0;
        var buffer2 = this.bytes;
        var low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        var midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        var midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        var high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        index = 0;
        var dec = {
          low: new Long(low, midl),
          high: new Long(midh, high)
        };
        if (dec.high.lessThan(Long.ZERO)) {
          string.push("-");
        }
        var combination = high >> 26 & COMBINATION_MASK;
        if (combination >> 3 === 3) {
          if (combination === COMBINATION_INFINITY) {
            return string.join("") + "Infinity";
          } else if (combination === COMBINATION_NAN) {
            return "NaN";
          } else {
            biased_exponent = high >> 15 & EXPONENT_MASK;
            significand_msb = 8 + (high >> 14 & 1);
          }
        } else {
          significand_msb = high >> 14 & 7;
          biased_exponent = high >> 17 & EXPONENT_MASK;
        }
        var exponent = biased_exponent - EXPONENT_BIAS;
        significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
        significand128.parts[1] = midh;
        significand128.parts[2] = midl;
        significand128.parts[3] = low;
        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
          is_zero = true;
        } else {
          for (k2 = 3; k2 >= 0; k2--) {
            var least_digits = 0;
            var result = divideu128(significand128);
            significand128 = result.quotient;
            least_digits = result.rem.low;
            if (!least_digits)
              continue;
            for (j2 = 8; j2 >= 0; j2--) {
              significand[k2 * 9 + j2] = least_digits % 10;
              least_digits = Math.floor(least_digits / 10);
            }
          }
        }
        if (is_zero) {
          significand_digits = 1;
          significand[index] = 0;
        } else {
          significand_digits = 36;
          while (!significand[index]) {
            significand_digits = significand_digits - 1;
            index = index + 1;
          }
        }
        var scientific_exponent = significand_digits - 1 + exponent;
        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
          if (significand_digits > 34) {
            string.push("".concat(0));
            if (exponent > 0)
              string.push("E+".concat(exponent));
            else if (exponent < 0)
              string.push("E".concat(exponent));
            return string.join("");
          }
          string.push("".concat(significand[index++]));
          significand_digits = significand_digits - 1;
          if (significand_digits) {
            string.push(".");
          }
          for (var i2 = 0; i2 < significand_digits; i2++) {
            string.push("".concat(significand[index++]));
          }
          string.push("E");
          if (scientific_exponent > 0) {
            string.push("+".concat(scientific_exponent));
          } else {
            string.push("".concat(scientific_exponent));
          }
        } else {
          if (exponent >= 0) {
            for (var i2 = 0; i2 < significand_digits; i2++) {
              string.push("".concat(significand[index++]));
            }
          } else {
            var radix_position = significand_digits + exponent;
            if (radix_position > 0) {
              for (var i2 = 0; i2 < radix_position; i2++) {
                string.push("".concat(significand[index++]));
              }
            } else {
              string.push("0");
            }
            string.push(".");
            while (radix_position++ < 0) {
              string.push("0");
            }
            for (var i2 = 0; i2 < significand_digits - Math.max(radix_position - 1, 0); i2++) {
              string.push("".concat(significand[index++]));
            }
          }
        }
        return string.join("");
      };
      Decimal1282.prototype.toJSON = function() {
        return { $numberDecimal: this.toString() };
      };
      Decimal1282.prototype.toExtendedJSON = function() {
        return { $numberDecimal: this.toString() };
      };
      Decimal1282.fromExtendedJSON = function(doc) {
        return Decimal1282.fromString(doc.$numberDecimal);
      };
      Decimal1282.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Decimal1282.prototype.inspect = function() {
        return 'new Decimal128("'.concat(this.toString(), '")');
      };
      return Decimal1282;
    }();
    Object.defineProperty(Decimal128.prototype, "_bsontype", { value: "Decimal128" });
    Double = /** @class */
    function() {
      function Double2(value) {
        if (!(this instanceof Double2))
          return new Double2(value);
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value;
      }
      Double2.prototype.valueOf = function() {
        return this.value;
      };
      Double2.prototype.toJSON = function() {
        return this.value;
      };
      Double2.prototype.toString = function(radix) {
        return this.value.toString(radix);
      };
      Double2.prototype.toExtendedJSON = function(options) {
        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
          return this.value;
        }
        if (Object.is(Math.sign(this.value), -0)) {
          return { $numberDouble: "-".concat(this.value.toFixed(1)) };
        }
        return {
          $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
        };
      };
      Double2.fromExtendedJSON = function(doc, options) {
        var doubleValue = parseFloat(doc.$numberDouble);
        return options && options.relaxed ? doubleValue : new Double2(doubleValue);
      };
      Double2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Double2.prototype.inspect = function() {
        var eJSON = this.toExtendedJSON();
        return "new Double(".concat(eJSON.$numberDouble, ")");
      };
      return Double2;
    }();
    Object.defineProperty(Double.prototype, "_bsontype", { value: "Double" });
    Int32 = /** @class */
    function() {
      function Int322(value) {
        if (!(this instanceof Int322))
          return new Int322(value);
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value | 0;
      }
      Int322.prototype.valueOf = function() {
        return this.value;
      };
      Int322.prototype.toString = function(radix) {
        return this.value.toString(radix);
      };
      Int322.prototype.toJSON = function() {
        return this.value;
      };
      Int322.prototype.toExtendedJSON = function(options) {
        if (options && (options.relaxed || options.legacy))
          return this.value;
        return { $numberInt: this.value.toString() };
      };
      Int322.fromExtendedJSON = function(doc, options) {
        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int322(doc.$numberInt);
      };
      Int322.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Int322.prototype.inspect = function() {
        return "new Int32(".concat(this.valueOf(), ")");
      };
      return Int322;
    }();
    Object.defineProperty(Int32.prototype, "_bsontype", { value: "Int32" });
    MaxKey = /** @class */
    function() {
      function MaxKey2() {
        if (!(this instanceof MaxKey2))
          return new MaxKey2();
      }
      MaxKey2.prototype.toExtendedJSON = function() {
        return { $maxKey: 1 };
      };
      MaxKey2.fromExtendedJSON = function() {
        return new MaxKey2();
      };
      MaxKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      MaxKey2.prototype.inspect = function() {
        return "new MaxKey()";
      };
      return MaxKey2;
    }();
    Object.defineProperty(MaxKey.prototype, "_bsontype", { value: "MaxKey" });
    MinKey = /** @class */
    function() {
      function MinKey2() {
        if (!(this instanceof MinKey2))
          return new MinKey2();
      }
      MinKey2.prototype.toExtendedJSON = function() {
        return { $minKey: 1 };
      };
      MinKey2.fromExtendedJSON = function() {
        return new MinKey2();
      };
      MinKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      MinKey2.prototype.inspect = function() {
        return "new MinKey()";
      };
      return MinKey2;
    }();
    Object.defineProperty(MinKey.prototype, "_bsontype", { value: "MinKey" });
    checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    PROCESS_UNIQUE = null;
    kId = Symbol("id");
    ObjectId = /** @class */
    function() {
      function ObjectId2(inputId) {
        if (!(this instanceof ObjectId2))
          return new ObjectId2(inputId);
        var workingId;
        if (typeof inputId === "object" && inputId && "id" in inputId) {
          if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
            throw new BSONTypeError("Argument passed in must have an id that is of type string or Buffer");
          }
          if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
            workingId = buffer_1.from(inputId.toHexString(), "hex");
          } else {
            workingId = inputId.id;
          }
        } else {
          workingId = inputId;
        }
        if (workingId == null || typeof workingId === "number") {
          this[kId] = ObjectId2.generate(typeof workingId === "number" ? workingId : void 0);
        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
          this[kId] = workingId instanceof buffer_1 ? workingId : ensureBuffer(workingId);
        } else if (typeof workingId === "string") {
          if (workingId.length === 12) {
            var bytes = buffer_1.from(workingId);
            if (bytes.byteLength === 12) {
              this[kId] = bytes;
            } else {
              throw new BSONTypeError("Argument passed in must be a string of 12 bytes");
            }
          } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
            this[kId] = buffer_1.from(workingId, "hex");
          } else {
            throw new BSONTypeError("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer");
          }
        } else {
          throw new BSONTypeError("Argument passed in does not match the accepted types");
        }
        if (ObjectId2.cacheHexString) {
          this.__id = this.id.toString("hex");
        }
      }
      Object.defineProperty(ObjectId2.prototype, "id", {
        /**
         * The ObjectId bytes
         * @readonly
         */
        get: function() {
          return this[kId];
        },
        set: function(value) {
          this[kId] = value;
          if (ObjectId2.cacheHexString) {
            this.__id = value.toString("hex");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObjectId2.prototype, "generationTime", {
        /**
         * The generation time of this ObjectId instance
         * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch
         */
        get: function() {
          return this.id.readInt32BE(0);
        },
        set: function(value) {
          this.id.writeUInt32BE(value, 0);
        },
        enumerable: false,
        configurable: true
      });
      ObjectId2.prototype.toHexString = function() {
        if (ObjectId2.cacheHexString && this.__id) {
          return this.__id;
        }
        var hexString = this.id.toString("hex");
        if (ObjectId2.cacheHexString && !this.__id) {
          this.__id = hexString;
        }
        return hexString;
      };
      ObjectId2.getInc = function() {
        return ObjectId2.index = (ObjectId2.index + 1) % 16777215;
      };
      ObjectId2.generate = function(time) {
        if ("number" !== typeof time) {
          time = Math.floor(Date.now() / 1e3);
        }
        var inc = ObjectId2.getInc();
        var buffer2 = buffer_1.alloc(12);
        buffer2.writeUInt32BE(time, 0);
        if (PROCESS_UNIQUE === null) {
          PROCESS_UNIQUE = randomBytes(5);
        }
        buffer2[4] = PROCESS_UNIQUE[0];
        buffer2[5] = PROCESS_UNIQUE[1];
        buffer2[6] = PROCESS_UNIQUE[2];
        buffer2[7] = PROCESS_UNIQUE[3];
        buffer2[8] = PROCESS_UNIQUE[4];
        buffer2[11] = inc & 255;
        buffer2[10] = inc >> 8 & 255;
        buffer2[9] = inc >> 16 & 255;
        return buffer2;
      };
      ObjectId2.prototype.toString = function(format) {
        if (format)
          return this.id.toString(format);
        return this.toHexString();
      };
      ObjectId2.prototype.toJSON = function() {
        return this.toHexString();
      };
      ObjectId2.prototype.equals = function(otherId) {
        if (otherId === void 0 || otherId === null) {
          return false;
        }
        if (otherId instanceof ObjectId2) {
          return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);
        }
        if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {
          return otherId === buffer_1.prototype.toString.call(this.id, "latin1");
        }
        if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 24) {
          return otherId.toLowerCase() === this.toHexString();
        }
        if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12) {
          return buffer_1.from(otherId).equals(this.id);
        }
        if (typeof otherId === "object" && "toHexString" in otherId && typeof otherId.toHexString === "function") {
          var otherIdString = otherId.toHexString();
          var thisIdString = this.toHexString().toLowerCase();
          return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
        }
        return false;
      };
      ObjectId2.prototype.getTimestamp = function() {
        var timestamp = /* @__PURE__ */ new Date();
        var time = this.id.readUInt32BE(0);
        timestamp.setTime(Math.floor(time) * 1e3);
        return timestamp;
      };
      ObjectId2.createPk = function() {
        return new ObjectId2();
      };
      ObjectId2.createFromTime = function(time) {
        var buffer2 = buffer_1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        buffer2.writeUInt32BE(time, 0);
        return new ObjectId2(buffer2);
      };
      ObjectId2.createFromHexString = function(hexString) {
        if (typeof hexString === "undefined" || hexString != null && hexString.length !== 24) {
          throw new BSONTypeError("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
        }
        return new ObjectId2(buffer_1.from(hexString, "hex"));
      };
      ObjectId2.isValid = function(id) {
        if (id == null)
          return false;
        try {
          new ObjectId2(id);
          return true;
        } catch (_a2) {
          return false;
        }
      };
      ObjectId2.prototype.toExtendedJSON = function() {
        if (this.toHexString)
          return { $oid: this.toHexString() };
        return { $oid: this.toString("hex") };
      };
      ObjectId2.fromExtendedJSON = function(doc) {
        return new ObjectId2(doc.$oid);
      };
      ObjectId2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      ObjectId2.prototype.inspect = function() {
        return 'new ObjectId("'.concat(this.toHexString(), '")');
      };
      ObjectId2.index = Math.floor(Math.random() * 16777215);
      return ObjectId2;
    }();
    Object.defineProperty(ObjectId.prototype, "generate", {
      value: deprecate(function(time) {
        return ObjectId.generate(time);
      }, "Please use the static `ObjectId.generate(time)` instead")
    });
    Object.defineProperty(ObjectId.prototype, "getInc", {
      value: deprecate(function() {
        return ObjectId.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId.prototype, "get_inc", {
      value: deprecate(function() {
        return ObjectId.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId, "get_inc", {
      value: deprecate(function() {
        return ObjectId.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId.prototype, "_bsontype", { value: "ObjectID" });
    BSONRegExp = /** @class */
    function() {
      function BSONRegExp2(pattern, options) {
        if (!(this instanceof BSONRegExp2))
          return new BSONRegExp2(pattern, options);
        this.pattern = pattern;
        this.options = alphabetize(options !== null && options !== void 0 ? options : "");
        if (this.pattern.indexOf("\0") !== -1) {
          throw new BSONError("BSON Regex patterns cannot contain null bytes, found: ".concat(JSON.stringify(this.pattern)));
        }
        if (this.options.indexOf("\0") !== -1) {
          throw new BSONError("BSON Regex options cannot contain null bytes, found: ".concat(JSON.stringify(this.options)));
        }
        for (var i2 = 0; i2 < this.options.length; i2++) {
          if (!(this.options[i2] === "i" || this.options[i2] === "m" || this.options[i2] === "x" || this.options[i2] === "l" || this.options[i2] === "s" || this.options[i2] === "u")) {
            throw new BSONError("The regular expression option [".concat(this.options[i2], "] is not supported"));
          }
        }
      }
      BSONRegExp2.parseOptions = function(options) {
        return options ? options.split("").sort().join("") : "";
      };
      BSONRegExp2.prototype.toExtendedJSON = function(options) {
        options = options || {};
        if (options.legacy) {
          return { $regex: this.pattern, $options: this.options };
        }
        return { $regularExpression: { pattern: this.pattern, options: this.options } };
      };
      BSONRegExp2.fromExtendedJSON = function(doc) {
        if ("$regex" in doc) {
          if (typeof doc.$regex !== "string") {
            if (doc.$regex._bsontype === "BSONRegExp") {
              return doc;
            }
          } else {
            return new BSONRegExp2(doc.$regex, BSONRegExp2.parseOptions(doc.$options));
          }
        }
        if ("$regularExpression" in doc) {
          return new BSONRegExp2(doc.$regularExpression.pattern, BSONRegExp2.parseOptions(doc.$regularExpression.options));
        }
        throw new BSONTypeError("Unexpected BSONRegExp EJSON object form: ".concat(JSON.stringify(doc)));
      };
      return BSONRegExp2;
    }();
    Object.defineProperty(BSONRegExp.prototype, "_bsontype", { value: "BSONRegExp" });
    BSONSymbol = /** @class */
    function() {
      function BSONSymbol2(value) {
        if (!(this instanceof BSONSymbol2))
          return new BSONSymbol2(value);
        this.value = value;
      }
      BSONSymbol2.prototype.valueOf = function() {
        return this.value;
      };
      BSONSymbol2.prototype.toString = function() {
        return this.value;
      };
      BSONSymbol2.prototype.inspect = function() {
        return 'new BSONSymbol("'.concat(this.value, '")');
      };
      BSONSymbol2.prototype.toJSON = function() {
        return this.value;
      };
      BSONSymbol2.prototype.toExtendedJSON = function() {
        return { $symbol: this.value };
      };
      BSONSymbol2.fromExtendedJSON = function(doc) {
        return new BSONSymbol2(doc.$symbol);
      };
      BSONSymbol2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      return BSONSymbol2;
    }();
    Object.defineProperty(BSONSymbol.prototype, "_bsontype", { value: "Symbol" });
    LongWithoutOverridesClass = Long;
    Timestamp = /** @class */
    function(_super) {
      __extends(Timestamp2, _super);
      function Timestamp2(low, high) {
        var _this = this;
        if (!(_this instanceof Timestamp2))
          return new Timestamp2(low, high);
        if (Long.isLong(low)) {
          _this = _super.call(this, low.low, low.high, true) || this;
        } else if (isObjectLike(low) && typeof low.t !== "undefined" && typeof low.i !== "undefined") {
          _this = _super.call(this, low.i, low.t, true) || this;
        } else {
          _this = _super.call(this, low, high, true) || this;
        }
        Object.defineProperty(_this, "_bsontype", {
          value: "Timestamp",
          writable: false,
          configurable: false,
          enumerable: false
        });
        return _this;
      }
      Timestamp2.prototype.toJSON = function() {
        return {
          $timestamp: this.toString()
        };
      };
      Timestamp2.fromInt = function(value) {
        return new Timestamp2(Long.fromInt(value, true));
      };
      Timestamp2.fromNumber = function(value) {
        return new Timestamp2(Long.fromNumber(value, true));
      };
      Timestamp2.fromBits = function(lowBits, highBits) {
        return new Timestamp2(lowBits, highBits);
      };
      Timestamp2.fromString = function(str, optRadix) {
        return new Timestamp2(Long.fromString(str, true, optRadix));
      };
      Timestamp2.prototype.toExtendedJSON = function() {
        return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
      };
      Timestamp2.fromExtendedJSON = function(doc) {
        return new Timestamp2(doc.$timestamp);
      };
      Timestamp2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return this.inspect();
      };
      Timestamp2.prototype.inspect = function() {
        return "new Timestamp({ t: ".concat(this.getHighBits(), ", i: ").concat(this.getLowBits(), " })");
      };
      Timestamp2.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
      return Timestamp2;
    }(LongWithoutOverridesClass);
    BSON_INT32_MAX = 2147483647;
    BSON_INT32_MIN = -2147483648;
    BSON_INT64_MAX = 9223372036854776e3;
    BSON_INT64_MIN = -9223372036854776e3;
    keysToCodecs = {
      $oid: ObjectId,
      $binary: Binary,
      $uuid: Binary,
      $symbol: BSONSymbol,
      $numberInt: Int32,
      $numberDecimal: Decimal128,
      $numberDouble: Double,
      $numberLong: Long,
      $minKey: MinKey,
      $maxKey: MaxKey,
      $regex: BSONRegExp,
      $regularExpression: BSONRegExp,
      $timestamp: Timestamp
    };
    BSON_TYPE_MAPPINGS = {
      Binary: function(o2) {
        return new Binary(o2.value(), o2.sub_type);
      },
      Code: function(o2) {
        return new Code(o2.code, o2.scope);
      },
      DBRef: function(o2) {
        return new DBRef(o2.collection || o2.namespace, o2.oid, o2.db, o2.fields);
      },
      Decimal128: function(o2) {
        return new Decimal128(o2.bytes);
      },
      Double: function(o2) {
        return new Double(o2.value);
      },
      Int32: function(o2) {
        return new Int32(o2.value);
      },
      Long: function(o2) {
        return Long.fromBits(
          // underscore variants for 1.x backwards compatibility
          o2.low != null ? o2.low : o2.low_,
          o2.low != null ? o2.high : o2.high_,
          o2.low != null ? o2.unsigned : o2.unsigned_
        );
      },
      MaxKey: function() {
        return new MaxKey();
      },
      MinKey: function() {
        return new MinKey();
      },
      ObjectID: function(o2) {
        return new ObjectId(o2);
      },
      ObjectId: function(o2) {
        return new ObjectId(o2);
      },
      BSONRegExp: function(o2) {
        return new BSONRegExp(o2.pattern, o2.options);
      },
      Symbol: function(o2) {
        return new BSONSymbol(o2.value);
      },
      Timestamp: function(o2) {
        return Timestamp.fromBits(o2.low, o2.high);
      }
    };
    (function(EJSON2) {
      function parse2(text, options) {
        var finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);
        if (typeof finalOptions.relaxed === "boolean")
          finalOptions.strict = !finalOptions.relaxed;
        if (typeof finalOptions.strict === "boolean")
          finalOptions.relaxed = !finalOptions.strict;
        return JSON.parse(text, function(key, value) {
          if (key.indexOf("\0") !== -1) {
            throw new BSONError("BSON Document field names cannot contain null bytes, found: ".concat(JSON.stringify(key)));
          }
          return deserializeValue(value, finalOptions);
        });
      }
      EJSON2.parse = parse2;
      function stringify(value, replacer, space, options) {
        if (space != null && typeof space === "object") {
          options = space;
          space = 0;
        }
        if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
          options = replacer;
          replacer = void 0;
          space = 0;
        }
        var serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
          seenObjects: [{ propertyName: "(root)", obj: null }]
        });
        var doc = serializeValue(value, serializeOptions);
        return JSON.stringify(doc, replacer, space);
      }
      EJSON2.stringify = stringify;
      function serialize3(value, options) {
        options = options || {};
        return JSON.parse(stringify(value, options));
      }
      EJSON2.serialize = serialize3;
      function deserialize3(ejson, options) {
        options = options || {};
        return parse2(JSON.stringify(ejson), options);
      }
      EJSON2.deserialize = deserialize3;
    })(EJSON || (EJSON = {}));
    bsonGlobal = getGlobal();
    if (bsonGlobal.Map) {
      bsonMap = bsonGlobal.Map;
    } else {
      bsonMap = /** @class */
      function() {
        function Map2(array) {
          if (array === void 0) {
            array = [];
          }
          this._keys = [];
          this._values = {};
          for (var i2 = 0; i2 < array.length; i2++) {
            if (array[i2] == null)
              continue;
            var entry = array[i2];
            var key = entry[0];
            var value = entry[1];
            this._keys.push(key);
            this._values[key] = { v: value, i: this._keys.length - 1 };
          }
        }
        Map2.prototype.clear = function() {
          this._keys = [];
          this._values = {};
        };
        Map2.prototype.delete = function(key) {
          var value = this._values[key];
          if (value == null)
            return false;
          delete this._values[key];
          this._keys.splice(value.i, 1);
          return true;
        };
        Map2.prototype.entries = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? [key, _this._values[key].v] : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Map2.prototype.forEach = function(callback, self2) {
          self2 = self2 || this;
          for (var i2 = 0; i2 < this._keys.length; i2++) {
            var key = this._keys[i2];
            callback.call(self2, this._values[key].v, key, self2);
          }
        };
        Map2.prototype.get = function(key) {
          return this._values[key] ? this._values[key].v : void 0;
        };
        Map2.prototype.has = function(key) {
          return this._values[key] != null;
        };
        Map2.prototype.keys = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? key : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Map2.prototype.set = function(key, value) {
          if (this._values[key]) {
            this._values[key].v = value;
            return this;
          }
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
          return this;
        };
        Map2.prototype.values = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? _this._values[key].v : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: false,
          configurable: true
        });
        return Map2;
      }();
    }
    FIRST_BIT = 128;
    FIRST_TWO_BITS = 192;
    FIRST_THREE_BITS = 224;
    FIRST_FOUR_BITS = 240;
    FIRST_FIVE_BITS = 248;
    TWO_BIT_CHAR = 192;
    THREE_BIT_CHAR = 224;
    FOUR_BIT_CHAR = 240;
    CONTINUING_CHAR = 128;
    JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
    JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
    functionCache = {};
    allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
    regexp = /\x00/;
    ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
    SPACE_FOR_FLOAT64 = new Uint8Array(8);
    DV_FOR_FLOAT64 = new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);
    MAXSIZE = 1024 * 1024 * 17;
    buffer = buffer_1.alloc(MAXSIZE);
    BSON = {
      Binary,
      Code,
      DBRef,
      Decimal128,
      Double,
      Int32,
      Long,
      UUID,
      Map: bsonMap,
      MaxKey,
      MinKey,
      ObjectId,
      ObjectID: ObjectId,
      BSONRegExp,
      BSONSymbol,
      Timestamp,
      EJSON,
      setInternalBufferSize,
      serialize,
      serializeWithBufferAndIndex,
      deserialize,
      calculateObjectSize,
      deserializeStream,
      BSONError,
      BSONTypeError
    };
    bson_browser_esm_default = BSON;
  }
});

// ../node_modules/realm-web/dist/bundle.dom.es.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent("Cloudflare-Workers");
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a2 = operatingSystemRules[ii2], os = _a2[0], regex = _a2[1];
    var match2 = regex.exec(ua);
    if (match2) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output.push("0");
  }
  return output;
}
function serialize2(obj) {
  return EJSON.serialize(obj, SERIALIZATION_OPTIONS);
}
function deserialize2(obj) {
  if (Array.isArray(obj)) {
    return obj.map((doc) => EJSON.deserialize(doc));
  } else {
    return EJSON.deserialize(obj);
  }
}
function removeKeysWithUndefinedValues(obj) {
  return Object.fromEntries(Object.entries(obj).filter((entry) => typeof entry[1] !== "undefined"));
}
function generateRandomString(length, alphabet) {
  let result = "";
  for (let i2 = 0; i2 < length; i2++) {
    result += alphabet[Math.floor(Math.random() * alphabet.length)];
  }
  return result;
}
function encodeQueryString(params, prefixed = true) {
  const cleanedParams = removeKeysWithUndefinedValues(params);
  const prefix = prefixed && Object.keys(cleanedParams).length > 0 ? "?" : "";
  return prefix + Object.entries(cleanedParams).map(([k2, v2]) => `${k2}=${encodeURIComponent(v2)}`).join("&");
}
function decodeQueryString(str) {
  const cleanStr = str[0] === "?" ? str.substr(1) : str;
  return Object.fromEntries(cleanStr.split("&").filter((s2) => s2.length > 0).map((kvp) => kvp.split("=")).map(([k2, v2]) => [k2, decodeURIComponent(v2)]));
}
function cleanArgs(args) {
  for (const arg of args) {
    if (typeof arg === "object" && arg) {
      for (const [key, value] of Object.entries(arg)) {
        if (value === void 0) {
          delete arg[key];
        }
      }
    }
  }
  return args;
}
function cleanArgsAndSerialize(args) {
  const cleaned = cleanArgs(args);
  return cleaned.map((arg) => typeof arg === "object" ? serialize2(arg) : arg);
}
function api() {
  return {
    path: "/api/client/v2.0",
    /**
     * @param appId The id of the app.
     * @returns The URL of the app endpoint.
     */
    app(appId) {
      return {
        path: this.path + `/app/${appId}`,
        /**
         * @returns The URL of the app location endpoint.
         */
        location() {
          return {
            path: this.path + "/location"
          };
        },
        /**
         * @param providerName The name of the provider.
         * @returns The app url concatinated with the /auth/providers/{providerName}
         */
        authProvider(providerName) {
          return {
            path: this.path + `/auth/providers/${providerName}`,
            /**
             * @returns Get the URL of an authentication provider.
             */
            login() {
              return { path: this.path + "/login" };
            }
          };
        },
        /**
         * @param providerName The name of the provider.
         * @returns The app url concatinated with the /auth/providers/{providerName}
         */
        emailPasswordAuth(providerName) {
          const authProviderRoutes = this.authProvider(providerName);
          return {
            ...authProviderRoutes,
            register() {
              return { path: this.path + "/register" };
            },
            confirm() {
              return { path: this.path + "/confirm" };
            },
            confirmSend() {
              return { path: this.path + "/confirm/send" };
            },
            confirmCall() {
              return { path: this.path + "/confirm/call" };
            },
            reset() {
              return { path: this.path + "/reset" };
            },
            resetSend() {
              return { path: this.path + "/reset/send" };
            },
            resetCall() {
              return { path: this.path + "/reset/call" };
            }
          };
        },
        functionsCall() {
          return {
            path: this.path + "/functions/call"
          };
        }
      };
    },
    auth() {
      return {
        path: this.path + "/auth",
        apiKeys() {
          return {
            path: this.path + "/api_keys",
            key(id) {
              return {
                path: this.path + `/${id}`,
                enable() {
                  return { path: this.path + "/enable" };
                },
                disable() {
                  return { path: this.path + "/disable" };
                }
              };
            }
          };
        },
        profile() {
          return { path: this.path + "/profile" };
        },
        session() {
          return { path: this.path + "/session" };
        },
        delete() {
          return { path: this.path + "/delete" };
        }
      };
    }
  };
}
function setEnvironment(e2) {
  environment = e2;
}
function getEnvironment() {
  if (environment) {
    return environment;
  } else {
    throw new Error("Cannot get environment before it's set");
  }
}
function createCollection(fetcher, serviceName, databaseName, collectionName) {
  return new MongoDBCollection(fetcher, serviceName, databaseName, collectionName);
}
function createDatabase(fetcher, serviceName, databaseName) {
  return {
    collection: createCollection.bind(null, fetcher, serviceName, databaseName)
  };
}
function createService(fetcher, serviceName = "mongo-db") {
  return { db: createDatabase.bind(null, fetcher, serviceName) };
}
function asyncIteratorFromResponseBody(body) {
  if (typeof body !== "object" || body === null) {
    throw new Error("Expected a non-null object");
  } else if (Symbol.asyncIterator in body) {
    return body;
  } else if ("getReader" in body) {
    const stream = body;
    return {
      [Symbol.asyncIterator]() {
        const reader = stream.getReader();
        return {
          next() {
            return reader.read();
          },
          async return() {
            await reader.cancel();
            return { done: true, value: null };
          }
        };
      }
    };
  } else {
    throw new Error("Expected an AsyncIterable or a ReadableStream");
  }
}
function openWindow(url) {
  if (typeof safeGlobalThis$1.open === "function") {
    return safeGlobalThis$1.open(url);
  } else {
    console.log(`Please open ${url}`);
    return null;
  }
}
var __spreadArray, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules, DefaultNetworkTransport, setIsDevelopmentMode, check, safeGlobalThis, version, VERSION, _hasatob, _hasbtoa, _hasBuffer, _TD, _TE, b64ch, b64chs, b64tab, b64re, _fromCC, _U8Afrom, _mkUriSafe, _tidyB64, btoaPolyfill, _btoa, _fromUint8Array, fromUint8Array, cb_utob, re_utob, utob, _encode, encode, encodeURI, re_btou, cb_btou, btou, atobPolyfill, _atob, _toUint8Array, toUint8Array, _decode, _unURI, decode, isValid, _noEnum, extendString, extendUint8Array, extendBuiltins, gBase64, SERIALIZATION_OPTIONS, UserType, DataKey, DATA_MAPPING, UserProfile, PrefixedStorage, MemoryStorage, ACCESS_TOKEN_STORAGE_KEY, REFRESH_TOKEN_STORAGE_KEY, PROFILE_STORAGE_KEY, PROVIDER_TYPE_STORAGE_KEY, UserStorage, RESERVED_NAMES, FunctionsFactory, EmailPasswordAuth, routes2, ApiKeyAuth, environment, WatchError, WatchStreamState, WatchStream, MongoDBCollection, DEFAULT_DEVICE_ID, UserState, UserType$1, User, Credentials, USER_IDS_STORAGE_KEY, DEVICE_ID_STORAGE_KEY, AppStorage, LOWERCASE_LETTERS, CLOSE_CHECK_INTERVAL, REDIRECT_HASH_TO_RESULT, OAuth2Helper, REDIRECT_LOCATION_HEADER, Authenticator, MongoDBRealmError, Fetcher, DEVICE_ID_STORAGE_KEY$1, DeviceFields, DeviceInformation, DEFAULT_BASE_URL, App, setIsDevelopmentMode$1, check$1, safeGlobalThis$1, LocalStorage, browser, DefaultStorage, environment$1;
var init_bundle_dom_es = __esm({
  "../node_modules/realm-web/dist/bundle.dom.es.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_bson_browser_esm();
    init_bson_browser_esm();
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
          if (ar2 || !(i2 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i2);
            ar2[i2] = from[i2];
          }
        }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    BrowserInfo = /** @class */
    function() {
      function BrowserInfo2(name, version2, os) {
        this.name = name;
        this.version = version2;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = /** @class */
    function() {
      function NodeInfo2(version2) {
        this.version = version2;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = /** @class */
    function() {
      function SearchBotDeviceInfo2(name, version2, os, bot) {
        this.name = name;
        this.version = version2;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = /** @class */
    function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = /** @class */
    function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FB[AS]V\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["curl", /^curl\/([0-9\.]+)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
    DefaultNetworkTransport = class {
      constructor() {
        if (!DefaultNetworkTransport.fetch) {
          throw new Error("DefaultNetworkTransport.fetch must be set before it's used");
        }
        if (!DefaultNetworkTransport.AbortController) {
          throw new Error("DefaultNetworkTransport.AbortController must be set before it's used");
        }
      }
      fetchWithCallbacks(request, handler) {
        this.fetch(request).then(async (response) => {
          const decodedBody = await response.text();
          const responseHeaders = {};
          response.headers.forEach((value, key) => {
            responseHeaders[key] = value;
          });
          return {
            statusCode: response.status,
            headers: responseHeaders,
            body: decodedBody
          };
        }).then((r2) => handler.onSuccess(r2)).catch((e2) => handler.onError(e2));
      }
      async fetch(request) {
        const { timeoutMs, url, ...rest } = request;
        const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);
        try {
          return await DefaultNetworkTransport.fetch(url, {
            ...DefaultNetworkTransport.extraFetchOptions,
            signal,
            ...rest
          });
        } finally {
          cancelTimeout();
        }
      }
      createTimeoutSignal(timeoutMs) {
        if (typeof timeoutMs === "number") {
          const controller = new DefaultNetworkTransport.AbortController();
          const timeout = setTimeout(() => {
            controller.abort();
          }, timeoutMs);
          return {
            signal: controller.signal,
            cancelTimeout: () => {
              clearTimeout(timeout);
            }
          };
        } else {
          return {
            signal: void 0,
            cancelTimeout: () => {
            }
          };
        }
      }
    };
    DefaultNetworkTransport.DEFAULT_HEADERS = {
      "Content-Type": "application/json"
    };
    setIsDevelopmentMode = (state) => {
    };
    check = function(it) {
      return it && it.Math == Math && it;
    };
    safeGlobalThis = // eslint-disable-next-line no-restricted-globals
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `self`
    check(typeof self == "object" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `global`
    check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
    setIsDevelopmentMode(typeof __DEV__ !== "undefined" && __DEV__);
    DefaultNetworkTransport.fetch = safeGlobalThis.fetch.bind(safeGlobalThis);
    DefaultNetworkTransport.AbortController = safeGlobalThis.AbortController.bind(safeGlobalThis);
    version = "3.7.2";
    VERSION = version;
    _hasatob = typeof atob === "function";
    _hasbtoa = typeof btoa === "function";
    _hasBuffer = typeof Buffer === "function";
    _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    b64chs = Array.prototype.slice.call(b64ch);
    b64tab = ((a2) => {
      let tab = {};
      a2.forEach((c2, i2) => tab[c2] = i2);
      return tab;
    })(b64chs);
    b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    _fromCC = String.fromCharCode.bind(String);
    _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x2) => x2) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
    _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
    _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
    btoaPolyfill = (bin) => {
      let u32, c0, c1, c2, asc = "";
      const pad = bin.length % 3;
      for (let i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
    _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
      const maxargs = 4096;
      let strs = [];
      for (let i2 = 0, l2 = u8a.length; i2 < l2; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    cb_utob = (c2) => {
      if (c2.length < 2) {
        var cc2 = c2.charCodeAt(0);
        return cc2 < 128 ? c2 : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
      } else {
        var cc2 = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
        return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
      }
    };
    re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    utob = (u2) => u2.replace(re_utob, cb_utob);
    _encode = _hasBuffer ? (s2) => Buffer.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
    encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
    encodeURI = (src) => encode(src, true);
    re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    cb_btou = (cccc) => {
      switch (cccc.length) {
        case 4:
          var cp2 = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp2 - 65536;
          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    btou = (b2) => b2.replace(re_btou, cb_btou);
    atobPolyfill = (asc) => {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      let u24, bin = "", r1, r2;
      for (let i2 = 0; i2 < asc.length; ) {
        u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
    _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer.from(a2, "base64")) : (a2) => _U8Afrom(_atob(a2), (c2) => c2.charCodeAt(0));
    toUint8Array = (a2) => _toUint8Array(_unURI(a2));
    _decode = _hasBuffer ? (a2) => Buffer.from(a2, "base64").toString("utf8") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));
    _unURI = (a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
    decode = (src) => _decode(_unURI(src));
    isValid = (src) => {
      if (typeof src !== "string")
        return false;
      const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
    };
    _noEnum = (v2) => {
      return {
        value: v2,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    extendString = function() {
      const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode(this, true);
      });
      _add("toBase64URL", function() {
        return encode(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    extendUint8Array = function() {
      const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    extendBuiltins = () => {
      extendString();
      extendUint8Array();
    };
    gBase64 = {
      version,
      VERSION,
      atob: _atob,
      atobPolyfill,
      btoa: _btoa,
      btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode,
      encodeURI,
      encodeURL: encodeURI,
      utob,
      btou,
      decode,
      isValid,
      fromUint8Array,
      toUint8Array,
      extendString,
      extendUint8Array,
      extendBuiltins
    };
    SERIALIZATION_OPTIONS = {
      relaxed: false
      // Ensure Canonical mode
    };
    (function(UserType2) {
      UserType2["Normal"] = "normal";
      UserType2["Server"] = "server";
    })(UserType || (UserType = {}));
    (function(DataKey2) {
      DataKey2["NAME"] = "name";
      DataKey2["EMAIL"] = "email";
      DataKey2["PICTURE"] = "picture";
      DataKey2["FIRST_NAME"] = "first_name";
      DataKey2["LAST_NAME"] = "last_name";
      DataKey2["GENDER"] = "gender";
      DataKey2["BIRTHDAY"] = "birthday";
      DataKey2["MIN_AGE"] = "min_age";
      DataKey2["MAX_AGE"] = "max_age";
    })(DataKey || (DataKey = {}));
    DATA_MAPPING = {
      [DataKey.NAME]: "name",
      [DataKey.EMAIL]: "email",
      [DataKey.PICTURE]: "pictureUrl",
      [DataKey.FIRST_NAME]: "firstName",
      [DataKey.LAST_NAME]: "lastName",
      [DataKey.GENDER]: "gender",
      [DataKey.BIRTHDAY]: "birthday",
      [DataKey.MIN_AGE]: "minAge",
      [DataKey.MAX_AGE]: "maxAge"
    };
    UserProfile = class {
      /**
       * @param response The response of a call fetching the users profile.
       */
      constructor(response) {
        this.type = UserType.Normal;
        this.identities = [];
        if (typeof response === "object" && response !== null) {
          const { type, identities, data } = response;
          if (typeof type === "string") {
            this.type = type;
          } else {
            throw new Error("Expected 'type' in the response body");
          }
          if (Array.isArray(identities)) {
            this.identities = identities.map((identity) => {
              const { id, provider_type: providerType } = identity;
              return { id, providerType };
            });
          } else {
            throw new Error("Expected 'identities' in the response body");
          }
          if (typeof data === "object" && data !== null) {
            const mappedData = Object.fromEntries(Object.entries(data).map(([key, value]) => {
              if (key in DATA_MAPPING) {
                return [DATA_MAPPING[key], value];
              } else {
                return [key, value];
              }
            }));
            this.data = deserialize2(mappedData);
          } else {
            throw new Error("Expected 'data' in the response body");
          }
        } else {
          this.data = {};
        }
      }
    };
    PrefixedStorage = class {
      /**
       * Construct a `Storage` which will prefix a key part to every operation.
       *
       * @param storage The underlying storage to use for operations.
       * @param keyPart The part of the key to prefix when performing operations.
       */
      constructor(storage, keyPart) {
        this.storage = storage;
        this.keyPart = keyPart;
      }
      /** @inheritdoc */
      get(key) {
        return this.storage.get(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
      }
      /** @inheritdoc */
      set(key, value) {
        return this.storage.set(this.keyPart + PrefixedStorage.PART_SEPARATOR + key, value);
      }
      /** @inheritdoc */
      remove(key) {
        return this.storage.remove(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
      }
      /** @inheritdoc */
      prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
      }
      /** @inheritdoc */
      clear(prefix = "") {
        return this.storage.clear(this.keyPart + PrefixedStorage.PART_SEPARATOR + prefix);
      }
      /** @inheritdoc */
      addListener(listener) {
        return this.storage.addListener(listener);
      }
      /** @inheritdoc */
      removeListener(listener) {
        return this.storage.addListener(listener);
      }
    };
    PrefixedStorage.PART_SEPARATOR = ":";
    MemoryStorage = class {
      constructor() {
        this.storage = {};
        this.listeners = /* @__PURE__ */ new Set();
      }
      /** @inheritdoc */
      get(key) {
        if (key in this.storage) {
          return this.storage[key];
        } else {
          return null;
        }
      }
      /** @inheritdoc */
      set(key, value) {
        this.storage[key] = value;
        this.fireListeners();
      }
      /** @inheritdoc */
      remove(key) {
        delete this.storage[key];
        this.fireListeners();
      }
      /** @inheritdoc */
      prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
      }
      /** @inheritdoc */
      clear(prefix) {
        for (const key of Object.keys(this.storage)) {
          if (!prefix || key.startsWith(prefix)) {
            delete this.storage[key];
          }
        }
        this.fireListeners();
      }
      /** @inheritdoc */
      addListener(listener) {
        this.listeners.add(listener);
      }
      /** @inheritdoc */
      removeListener(listener) {
        this.listeners.delete(listener);
      }
      /**
       * Tell the listeners that a change occurred.
       */
      fireListeners() {
        this.listeners.forEach((listener) => listener());
      }
    };
    ACCESS_TOKEN_STORAGE_KEY = "accessToken";
    REFRESH_TOKEN_STORAGE_KEY = "refreshToken";
    PROFILE_STORAGE_KEY = "profile";
    PROVIDER_TYPE_STORAGE_KEY = "providerType";
    UserStorage = class extends PrefixedStorage {
      /**
       * Construct a storage for a `User`.
       *
       * @param storage The underlying storage to wrap.
       * @param userId The id of the user.
       */
      constructor(storage, userId) {
        super(storage, `user(${userId})`);
      }
      /**
       * Get the access token from storage.
       *
       * @returns Access token (null if unknown).
       */
      get accessToken() {
        return this.get(ACCESS_TOKEN_STORAGE_KEY);
      }
      /**
       * Set the access token in storage.
       *
       * @param value Access token (null if unknown).
       */
      set accessToken(value) {
        if (value === null) {
          this.remove(ACCESS_TOKEN_STORAGE_KEY);
        } else {
          this.set(ACCESS_TOKEN_STORAGE_KEY, value);
        }
      }
      /**
       * Get the refresh token from storage.
       *
       * @returns Refresh token (null if unknown and user is logged out).
       */
      get refreshToken() {
        return this.get(REFRESH_TOKEN_STORAGE_KEY);
      }
      /**
       * Set the refresh token in storage.
       *
       * @param value Refresh token (null if unknown and user is logged out).
       */
      set refreshToken(value) {
        if (value === null) {
          this.remove(REFRESH_TOKEN_STORAGE_KEY);
        } else {
          this.set(REFRESH_TOKEN_STORAGE_KEY, value);
        }
      }
      /**
       * Get the user profile from storage.
       *
       * @returns User profile (undefined if its unknown).
       */
      get profile() {
        const value = this.get(PROFILE_STORAGE_KEY);
        if (value) {
          const profile = new UserProfile();
          Object.assign(profile, JSON.parse(value));
          return profile;
        }
      }
      /**
       * Set the user profile in storage.
       *
       * @param value User profile (undefined if its unknown).
       */
      set profile(value) {
        if (value) {
          this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));
        } else {
          this.remove(PROFILE_STORAGE_KEY);
        }
      }
      /**
       * Get the type of authentication provider used to authenticate
       *
       * @returns User profile (undefined if its unknown).
       */
      get providerType() {
        const value = this.get(PROVIDER_TYPE_STORAGE_KEY);
        if (value) {
          return value;
        }
      }
      /**
       * Set the type of authentication provider used to authenticate
       *
       * @param value Type of authentication provider.
       */
      set providerType(value) {
        if (value) {
          this.set(PROVIDER_TYPE_STORAGE_KEY, value);
        } else {
          this.remove(PROVIDER_TYPE_STORAGE_KEY);
        }
      }
    };
    RESERVED_NAMES = [
      "inspect",
      "callFunction",
      "callFunctionStreaming",
      // Methods defined on the Object.prototype might be "typeof probed" and called by libraries and runtime environments.
      ...Object.getOwnPropertyNames(Object.prototype)
    ];
    FunctionsFactory = class {
      /**
       * @param fetcher The underlying fetcher to use when sending requests.
       * @param config Additional configuration parameters.
       */
      constructor(fetcher, config = {}) {
        this.fetcher = fetcher;
        this.serviceName = config.serviceName;
        this.argsTransformation = config.argsTransformation || cleanArgsAndSerialize;
      }
      /**
       * Create a factory of functions, wrapped in a Proxy that returns bound copies of `callFunction` on any property.
       *
       * @param fetcher The underlying fetcher to use when requesting.
       * @param config Additional configuration parameters.
       * @returns The newly created factory of functions.
       */
      static create(fetcher, config = {}) {
        const factory = new FunctionsFactory(fetcher, config);
        return new Proxy(factory, {
          get(target, p2, receiver) {
            if (typeof p2 === "string" && RESERVED_NAMES.indexOf(p2) === -1) {
              return target.callFunction.bind(target, p2);
            } else {
              const prop = Reflect.get(target, p2, receiver);
              return typeof prop === "function" ? prop.bind(target) : prop;
            }
          }
        });
      }
      /**
       * Call a remote function by it's name.
       *
       * @param name Name of the remote function.
       * @param args Arguments to pass to the remote function.
       * @returns A promise of the value returned when executing the remote function.
       */
      async callFunction(name, ...args) {
        const body = {
          name,
          arguments: this.argsTransformation ? this.argsTransformation(args) : args
        };
        if (this.serviceName) {
          body.service = this.serviceName;
        }
        const appRoute = this.fetcher.appRoute;
        return this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.functionsCall().path,
          body
        });
      }
      /**
       * Call a remote function by it's name.
       *
       * @param name Name of the remote function.
       * @param args Arguments to pass to the remote function.
       * @returns A promise of the value returned when executing the remote function.
       */
      callFunctionStreaming(name, ...args) {
        const body = {
          name,
          arguments: this.argsTransformation ? this.argsTransformation(args) : args
        };
        if (this.serviceName) {
          body.service = this.serviceName;
        }
        const appRoute = this.fetcher.appRoute;
        const qs = encodeQueryString({
          ["baas_request"]: gBase64.encode(JSON.stringify(body))
        });
        return this.fetcher.fetchStream({
          method: "GET",
          path: appRoute.functionsCall().path + qs
        });
      }
    };
    EmailPasswordAuth = class {
      /**
       * Construct an interface to the email / password authentication provider.
       *
       * @param fetcher The underlying fetcher used to request the services.
       * @param providerName Optional custom name of the authentication provider.
       */
      constructor(fetcher, providerName = "local-userpass") {
        this.fetcher = fetcher;
        this.providerName = providerName;
      }
      /** @inheritdoc */
      async registerUser(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).register().path,
          body: details
        });
      }
      /** @inheritdoc */
      async confirmUser(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).confirm().path,
          body: details
        });
      }
      /** @inheritdoc */
      async resendConfirmationEmail(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).confirmSend().path,
          body: details
        });
      }
      /** @inheritdoc */
      async retryCustomConfirmation(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).confirmCall().path,
          body: details
        });
      }
      /** @inheritdoc */
      async resetPassword(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).reset().path,
          body: details
        });
      }
      /** @inheritdoc */
      async sendResetPasswordEmail(details) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).resetSend().path,
          body: details
        });
      }
      /** @inheritdoc */
      async callResetPasswordFunction(details, ...args) {
        const appRoute = this.fetcher.appRoute;
        await this.fetcher.fetchJSON({
          method: "POST",
          path: appRoute.emailPasswordAuth(this.providerName).resetCall().path,
          body: { ...details, arguments: args }
        });
      }
    };
    routes2 = { api };
    ApiKeyAuth = class {
      /**
       * Construct an interface to the API-key authentication provider.
       *
       * @param fetcher The fetcher used to send requests to services.
       */
      constructor(fetcher) {
        this.fetcher = fetcher;
      }
      /** @inheritdoc */
      create(name) {
        return this.fetcher.fetchJSON({
          method: "POST",
          body: { name },
          path: routes2.api().auth().apiKeys().path,
          tokenType: "refresh"
        });
      }
      /** @inheritdoc */
      fetch(keyId) {
        return this.fetcher.fetchJSON({
          method: "GET",
          path: routes2.api().auth().apiKeys().key(keyId).path,
          tokenType: "refresh"
        });
      }
      /** @inheritdoc */
      fetchAll() {
        return this.fetcher.fetchJSON({
          method: "GET",
          tokenType: "refresh",
          path: routes2.api().auth().apiKeys().path
        });
      }
      /** @inheritdoc */
      async delete(keyId) {
        await this.fetcher.fetchJSON({
          method: "DELETE",
          path: routes2.api().auth().apiKeys().key(keyId).path,
          tokenType: "refresh"
        });
      }
      /** @inheritdoc */
      async enable(keyId) {
        await this.fetcher.fetchJSON({
          method: "PUT",
          path: routes2.api().auth().apiKeys().key(keyId).enable().path,
          tokenType: "refresh"
        });
      }
      /** @inheritdoc */
      async disable(keyId) {
        await this.fetcher.fetchJSON({
          method: "PUT",
          path: routes2.api().auth().apiKeys().key(keyId).disable().path,
          tokenType: "refresh"
        });
      }
    };
    environment = null;
    WatchError = class extends Error {
      constructor({ message, code: code2 }) {
        super(message);
        this.name = "WatchError";
        this.code = code2;
      }
    };
    (function(WatchStreamState2) {
      WatchStreamState2["NEED_DATA"] = "NEED_DATA";
      WatchStreamState2["HAVE_EVENT"] = "HAVE_EVENT";
      WatchStreamState2["HAVE_ERROR"] = "HAVE_ERROR";
    })(WatchStreamState || (WatchStreamState = {}));
    WatchStream = class {
      constructor() {
        this._state = WatchStreamState.NEED_DATA;
        this._error = null;
        this._textDecoder = new (getEnvironment()).TextDecoder();
        this._buffer = "";
        this._bufferOffset = 0;
        this._eventType = "";
        this._dataBuffer = "";
      }
      // Call these when you have data, in whatever shape is easiest for your SDK to get.
      // Pick one, mixing and matching on a single instance isn't supported.
      // These can only be called in NEED_DATA state, which is the initial state.
      feedBuffer(buffer2) {
        this.assertState(WatchStreamState.NEED_DATA);
        this._buffer += this._textDecoder.decode(buffer2, { stream: true });
        this.advanceBufferState();
      }
      feedLine(line) {
        this.assertState(WatchStreamState.NEED_DATA);
        if (line.endsWith("\n"))
          line = line.substr(0, line.length - 1);
        if (line.endsWith("\r"))
          line = line.substr(0, line.length - 1);
        if (line.length === 0) {
          if (this._dataBuffer.length === 0) {
            this._eventType = "";
            return;
          }
          if (this._dataBuffer.endsWith("\n"))
            this._dataBuffer = this._dataBuffer.substr(0, this._dataBuffer.length - 1);
          this.feedSse({
            data: this._dataBuffer,
            eventType: this._eventType
          });
          this._dataBuffer = "";
          this._eventType = "";
        }
        if (line[0] === ":")
          return;
        const colon = line.indexOf(":");
        const field = line.substr(0, colon);
        let value = colon === -1 ? "" : line.substr(colon + 1);
        if (value.startsWith(" "))
          value = value.substr(1);
        if (field === "event") {
          this._eventType = value;
        } else if (field === "data") {
          this._dataBuffer += value;
          this._dataBuffer += "\n";
        } else
          ;
      }
      feedSse(sse) {
        this.assertState(WatchStreamState.NEED_DATA);
        const firstPercentIndex = sse.data.indexOf("%");
        if (firstPercentIndex !== -1) {
          let buffer2 = "";
          let start = 0;
          for (let percentIndex = firstPercentIndex; percentIndex !== -1; percentIndex = sse.data.indexOf("%", start)) {
            buffer2 += sse.data.substr(start, percentIndex - start);
            const encoded = sse.data.substr(percentIndex, 3);
            if (encoded === "%25") {
              buffer2 += "%";
            } else if (encoded === "%0A") {
              buffer2 += "\n";
            } else if (encoded === "%0D") {
              buffer2 += "\r";
            } else {
              buffer2 += encoded;
            }
            start = percentIndex + encoded.length;
          }
          buffer2 += sse.data.substr(start);
          sse.data = buffer2;
        }
        if (!sse.eventType || sse.eventType === "message") {
          try {
            const parsed = EJSON.parse(sse.data);
            if (typeof parsed === "object") {
              this._nextEvent = parsed;
              this._state = WatchStreamState.HAVE_EVENT;
              return;
            }
          } catch {
          }
          this._state = WatchStreamState.HAVE_ERROR;
          this._error = new WatchError({
            message: "server returned malformed event: " + sse.data,
            code: "bad bson parse"
          });
        } else if (sse.eventType === "error") {
          this._state = WatchStreamState.HAVE_ERROR;
          this._error = new WatchError({
            message: sse.data,
            code: "unknown"
          });
          try {
            const { error_code: errorCode, error } = EJSON.parse(sse.data);
            if (typeof errorCode !== "string")
              return;
            if (typeof error !== "string")
              return;
            this._error = new WatchError({
              message: error,
              code: errorCode
            });
          } catch {
            return;
          }
        } else
          ;
      }
      get state() {
        return this._state;
      }
      // Consumes the returned event. If you used feedBuffer(), there may be another event or error after this one,
      // so you need to call state() again to see what to do next.
      nextEvent() {
        this.assertState(WatchStreamState.HAVE_EVENT);
        const out = this._nextEvent;
        this._state = WatchStreamState.NEED_DATA;
        this.advanceBufferState();
        return out;
      }
      // Once this enters the error state, it stays that way. You should not feed any more data.
      get error() {
        return this._error;
      }
      ////////////////////////////////////////////
      advanceBufferState() {
        this.assertState(WatchStreamState.NEED_DATA);
        while (this.state === WatchStreamState.NEED_DATA) {
          if (this._bufferOffset === this._buffer.length) {
            this._buffer = "";
            this._bufferOffset = 0;
            return;
          }
          const nextNewlineIndex = this._buffer.indexOf("\n", this._bufferOffset);
          if (nextNewlineIndex === -1) {
            if (this._bufferOffset !== 0) {
              this._buffer = this._buffer.substr(this._bufferOffset, this._buffer.length - this._bufferOffset);
              this._bufferOffset = 0;
            }
            return;
          }
          this.feedLine(this._buffer.substr(this._bufferOffset, nextNewlineIndex - this._bufferOffset));
          this._bufferOffset = nextNewlineIndex + 1;
        }
      }
      assertState(state) {
        if (this._state !== state) {
          throw Error(`Expected WatchStream to be in state ${state}, but in state ${this._state}`);
        }
      }
    };
    MongoDBCollection = class {
      /**
       * Construct a remote collection of documents.
       *
       * @param fetcher The fetcher to use when requesting the service.
       * @param serviceName The name of the remote service.
       * @param databaseName The name of the database.
       * @param collectionName The name of the remote collection.
       */
      constructor(fetcher, serviceName, databaseName, collectionName) {
        this.functions = FunctionsFactory.create(fetcher, {
          serviceName
        });
        this.databaseName = databaseName;
        this.collectionName = collectionName;
        this.serviceName = serviceName;
        this.fetcher = fetcher;
      }
      /** @inheritdoc */
      find(filter = {}, options = {}) {
        return this.functions.find({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter,
          project: options.projection,
          sort: options.sort,
          limit: options.limit
        });
      }
      /** @inheritdoc */
      findOne(filter = {}, options = {}) {
        return this.functions.findOne({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter,
          project: options.projection,
          sort: options.sort
        });
      }
      /** @inheritdoc */
      findOneAndUpdate(filter = {}, update, options = {}) {
        return this.functions.findOneAndUpdate({
          database: this.databaseName,
          collection: this.collectionName,
          filter,
          update,
          sort: options.sort,
          projection: options.projection,
          upsert: options.upsert,
          returnNewDocument: options.returnNewDocument
        });
      }
      /** @inheritdoc */
      findOneAndReplace(filter = {}, replacement, options = {}) {
        return this.functions.findOneAndReplace({
          database: this.databaseName,
          collection: this.collectionName,
          filter,
          update: replacement,
          sort: options.sort,
          projection: options.projection,
          upsert: options.upsert,
          returnNewDocument: options.returnNewDocument
        });
      }
      /** @inheritdoc */
      findOneAndDelete(filter = {}, options = {}) {
        return this.functions.findOneAndReplace({
          database: this.databaseName,
          collection: this.collectionName,
          filter,
          sort: options.sort,
          projection: options.projection
        });
      }
      /** @inheritdoc */
      aggregate(pipeline) {
        return this.functions.aggregate({
          database: this.databaseName,
          collection: this.collectionName,
          pipeline
        });
      }
      /** @inheritdoc */
      count(filter = {}, options = {}) {
        return this.functions.count({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter,
          limit: options.limit
        });
      }
      /** @inheritdoc */
      insertOne(document2) {
        return this.functions.insertOne({
          database: this.databaseName,
          collection: this.collectionName,
          document: document2
        });
      }
      /** @inheritdoc */
      insertMany(documents) {
        return this.functions.insertMany({
          database: this.databaseName,
          collection: this.collectionName,
          documents
        });
      }
      /** @inheritdoc */
      deleteOne(filter = {}) {
        return this.functions.deleteOne({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter
        });
      }
      /** @inheritdoc */
      deleteMany(filter = {}) {
        return this.functions.deleteMany({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter
        });
      }
      /** @inheritdoc */
      updateOne(filter, update, options = {}) {
        return this.functions.updateOne({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter,
          update,
          upsert: options.upsert,
          arrayFilters: options.arrayFilters
        });
      }
      /** @inheritdoc */
      updateMany(filter, update, options = {}) {
        return this.functions.updateMany({
          database: this.databaseName,
          collection: this.collectionName,
          query: filter,
          update,
          upsert: options.upsert,
          arrayFilters: options.arrayFilters
        });
      }
      watch({ ids, filter } = {}) {
        const iterable = this.functions.callFunctionStreaming("watch", {
          database: this.databaseName,
          collection: this.collectionName,
          ids,
          filter
        });
        const iterator = iterable.then((i2) => i2[Symbol.asyncIterator]());
        const stream = this.watchImpl(iterator);
        const originalReturn = stream.return;
        return Object.assign(stream, {
          return(value) {
            iterator.then((i2) => i2.return ? i2.return(value) : void 0);
            return originalReturn.call(stream, value);
          }
        });
      }
      /**
       * @param iterator An async iterator of the response body of a watch request.
       * @yields Change events.
       * Note: We had to split this from the `watch` method above to enable manually calling `return` on the response body iterator.
       */
      async *watchImpl(iterator) {
        const watchStream = new WatchStream();
        const iterable = iterator.then((i2) => ({ [Symbol.asyncIterator]: () => i2 }));
        for await (const chunk of await iterable) {
          if (!chunk)
            continue;
          watchStream.feedBuffer(chunk);
          while (watchStream.state == WatchStreamState.HAVE_EVENT) {
            yield watchStream.nextEvent();
          }
          if (watchStream.state == WatchStreamState.HAVE_ERROR)
            throw watchStream.error;
        }
      }
    };
    DEFAULT_DEVICE_ID = "000000000000000000000000";
    (function(UserState2) {
      UserState2["Active"] = "active";
      UserState2["LoggedOut"] = "logged-out";
      UserState2["Removed"] = "removed";
    })(UserState || (UserState = {}));
    (function(UserType2) {
      UserType2["Normal"] = "normal";
      UserType2["Server"] = "server";
    })(UserType$1 || (UserType$1 = {}));
    User = class {
      /**
       * @param parameters Parameters of the user.
       */
      constructor(parameters) {
        this.app = parameters.app;
        this.id = parameters.id;
        this.storage = new UserStorage(this.app.storage, this.id);
        if ("accessToken" in parameters && "refreshToken" in parameters && "providerType" in parameters) {
          this._accessToken = parameters.accessToken;
          this._refreshToken = parameters.refreshToken;
          this.providerType = parameters.providerType;
          this.storage.accessToken = parameters.accessToken;
          this.storage.refreshToken = parameters.refreshToken;
          this.storage.providerType = parameters.providerType;
        } else {
          this._accessToken = this.storage.accessToken;
          this._refreshToken = this.storage.refreshToken;
          const providerType = this.storage.providerType;
          this._profile = this.storage.profile;
          if (providerType) {
            this.providerType = providerType;
          } else {
            throw new Error("Storage is missing a provider type");
          }
        }
        this.fetcher = this.app.fetcher.clone({
          userContext: { currentUser: this }
        });
        this.apiKeys = new ApiKeyAuth(this.fetcher);
        this.functions = FunctionsFactory.create(this.fetcher);
      }
      /**
       * @returns The access token used to authenticate the user towards Atlas App Services.
       */
      get accessToken() {
        return this._accessToken;
      }
      /**
       * @param token The new access token.
       */
      set accessToken(token) {
        this._accessToken = token;
        this.storage.accessToken = token;
      }
      /**
       * @returns The refresh token used to issue new access tokens.
       */
      get refreshToken() {
        return this._refreshToken;
      }
      /**
       * @param token The new refresh token.
       */
      set refreshToken(token) {
        this._refreshToken = token;
        this.storage.refreshToken = token;
      }
      /**
       * @returns The current state of the user.
       */
      get state() {
        if (this.id in this.app.allUsers) {
          return this.refreshToken === null ? UserState.LoggedOut : UserState.Active;
        } else {
          return UserState.Removed;
        }
      }
      /**
       * @returns The logged in state of the user.
       */
      get isLoggedIn() {
        return this.state === UserState.Active;
      }
      get customData() {
        if (this.accessToken) {
          const decodedToken = this.decodeAccessToken();
          return decodedToken.userData;
        } else {
          throw new Error("Cannot read custom data without an access token");
        }
      }
      /**
       * @returns Profile containing detailed information about the user.
       */
      get profile() {
        if (this._profile) {
          return this._profile.data;
        } else {
          throw new Error("A profile was never fetched for this user");
        }
      }
      get identities() {
        if (this._profile) {
          return this._profile.identities;
        } else {
          throw new Error("A profile was never fetched for this user");
        }
      }
      get deviceId() {
        if (this.accessToken) {
          const payload = this.accessToken.split(".")[1];
          if (payload) {
            const parsedPayload = JSON.parse(gBase64.decode(payload));
            const deviceId = parsedPayload["baas_device_id"];
            if (typeof deviceId === "string" && deviceId !== DEFAULT_DEVICE_ID) {
              return deviceId;
            }
          }
        }
        return null;
      }
      /**
       * Refresh the users profile data.
       */
      async refreshProfile() {
        const response = await this.fetcher.fetchJSON({
          method: "GET",
          path: routes2.api().auth().profile().path
        });
        this._profile = new UserProfile(response);
        this.storage.profile = this._profile;
      }
      /**
       * Log out the user, invalidating the session (and its refresh token).
       */
      async logOut() {
        try {
          if (this._refreshToken !== null) {
            await this.fetcher.fetchJSON({
              method: "DELETE",
              path: routes2.api().auth().session().path,
              tokenType: "refresh"
            });
          }
        } catch (err) {
          if (!(err instanceof Error) || !err.message.includes("failed to find refresh token")) {
            throw err;
          }
        } finally {
          this.accessToken = null;
          this.refreshToken = null;
        }
      }
      /** @inheritdoc */
      async linkCredentials(credentials) {
        const response = await this.app.authenticator.authenticate(credentials, this);
        if (this.id !== response.userId) {
          const details = `got user id ${response.userId} expected ${this.id}`;
          throw new Error(`Link response ment for another user (${details})`);
        }
        this.accessToken = response.accessToken;
        await this.refreshProfile();
      }
      /**
       * Request a new access token, using the refresh token.
       */
      async refreshAccessToken() {
        const response = await this.fetcher.fetchJSON({
          method: "POST",
          path: routes2.api().auth().session().path,
          tokenType: "refresh"
        });
        const { access_token: accessToken } = response;
        if (typeof accessToken === "string") {
          this.accessToken = accessToken;
        } else {
          throw new Error("Expected an 'access_token' in the response");
        }
      }
      /** @inheritdoc */
      async refreshCustomData() {
        await this.refreshAccessToken();
        return this.customData;
      }
      /**
       * @inheritdoc
       */
      addListener() {
        throw new Error("Not yet implemented");
      }
      /**
       * @inheritdoc
       */
      removeListener() {
        throw new Error("Not yet implemented");
      }
      /**
       * @inheritdoc
       */
      removeAllListeners() {
        throw new Error("Not yet implemented");
      }
      /** @inheritdoc */
      callFunction(name, ...args) {
        return this.functions.callFunction(name, ...args);
      }
      /**
       * @returns A plain ol' JavaScript object representation of the user.
       */
      toJSON() {
        return {
          id: this.id,
          accessToken: this.accessToken,
          refreshToken: this.refreshToken,
          profile: this._profile,
          state: this.state,
          customData: this.customData
        };
      }
      /** @inheritdoc */
      push() {
        throw new Error("Not yet implemented");
      }
      /** @inheritdoc */
      mongoClient(serviceName) {
        return createService(this.fetcher, serviceName);
      }
      decodeAccessToken() {
        if (this.accessToken) {
          const parts = this.accessToken.split(".");
          if (parts.length !== 3) {
            throw new Error("Expected an access token with three parts");
          }
          const encodedPayload = parts[1];
          const decodedPayload = gBase64.decode(encodedPayload);
          const parsedPayload = JSON.parse(decodedPayload);
          const { exp: expires, iat: issuedAt, sub: subject, user_data: userData = {} } = parsedPayload;
          if (typeof expires !== "number") {
            throw new Error("Failed to decode access token 'exp'");
          } else if (typeof issuedAt !== "number") {
            throw new Error("Failed to decode access token 'iat'");
          }
          return { expires, issuedAt, subject, userData };
        } else {
          throw new Error("Missing an access token");
        }
      }
    };
    Credentials = class {
      /**
       * Constructs an instance of credentials.
       *
       * @param providerName The name of the authentication provider used when authenticating.
       * @param providerType The type of the authentication provider used when authenticating.
       * @param payload The data being sent to the service when authenticating.
       */
      constructor(providerName, providerType, payload) {
        this.providerName = providerName;
        this.providerType = providerType;
        this.payload = payload;
      }
      /**
       * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).
       *
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static anonymous() {
        return new Credentials("anon-user", "anon-user", {});
      }
      /**
       * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).
       *
       * @param key The secret content of the API key.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static apiKey(key) {
        return new Credentials("api-key", "api-key", { key });
      }
      /**
       * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).
       * Note: This was formerly known as the "Username/Password" provider.
       *
       * @param email The end-users email address.
       * @param password The end-users password.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static emailPassword(email, password) {
        return new Credentials("local-userpass", "local-userpass", {
          username: email,
          password
        });
      }
      /**
       * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).
       *
       * @param payload The custom payload as expected by the server.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static function(payload) {
        return new Credentials("custom-function", "custom-function", payload);
      }
      /**
       * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).
       *
       * @param token The JSON Web Token (JWT).
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static jwt(token) {
        return new Credentials("custom-token", "custom-token", {
          token
        });
      }
      /**
       * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).
       *
       * @param payload The URL that users should be redirected to, the auth code or id token from Google.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static google(payload) {
        return new Credentials("oauth2-google", "oauth2-google", Credentials.derivePayload(payload));
      }
      /**
       * @param payload The payload string.
       * @returns A payload object based on the string.
       */
      static derivePayload(payload) {
        if (typeof payload === "string") {
          throw new Error("`google(<tokenString>)` has been deprecated.  Please use `google(<authCodeObject>).");
        } else if (Object.keys(payload).length === 1) {
          if ("authCode" in payload || "redirectUrl" in payload) {
            return payload;
          } else if ("idToken" in payload) {
            return { id_token: payload.idToken };
          } else {
            throw new Error("Unexpected payload: " + JSON.stringify(payload));
          }
        } else {
          throw new Error("Expected only one property in payload, got " + JSON.stringify(payload));
        }
      }
      /**
       * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).
       *
       * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static facebook(redirectUrlOrAccessToken) {
        return new Credentials("oauth2-facebook", "oauth2-facebook", redirectUrlOrAccessToken.includes("://") ? { redirectUrl: redirectUrlOrAccessToken } : { accessToken: redirectUrlOrAccessToken });
      }
      /**
       * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).
       *
       * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.
       * @returns The credentials instance, which can be passed to `app.logIn`.
       */
      static apple(redirectUrlOrIdToken) {
        return new Credentials("oauth2-apple", "oauth2-apple", redirectUrlOrIdToken.includes("://") ? { redirectUrl: redirectUrlOrIdToken } : { id_token: redirectUrlOrIdToken });
      }
    };
    USER_IDS_STORAGE_KEY = "userIds";
    DEVICE_ID_STORAGE_KEY = "deviceId";
    AppStorage = class extends PrefixedStorage {
      /**
       * @param storage The underlying storage to wrap.
       * @param appId The id of the app.
       */
      constructor(storage, appId) {
        super(storage, `app(${appId})`);
      }
      /**
       * Reads out the list of user ids from storage.
       *
       * @returns A list of user ids.
       */
      getUserIds() {
        const userIdsString = this.get(USER_IDS_STORAGE_KEY);
        const userIds = userIdsString ? JSON.parse(userIdsString) : [];
        if (Array.isArray(userIds)) {
          return [...new Set(userIds)];
        } else {
          throw new Error("Expected the user ids to be an array");
        }
      }
      /**
       * Sets the list of ids in storage.
       * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.
       *
       * @param userIds The list of ids to store.
       * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.
       */
      setUserIds(userIds, mergeWithExisting) {
        if (mergeWithExisting) {
          const existingIds = this.getUserIds();
          for (const id of existingIds) {
            if (userIds.indexOf(id) === -1) {
              userIds.push(id);
            }
          }
        }
        this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));
      }
      /**
       * Remove an id from the list of ids.
       *
       * @param userId The id of a User to be removed.
       */
      removeUserId(userId) {
        const existingIds = this.getUserIds();
        const userIds = existingIds.filter((id) => id !== userId);
        this.setUserIds(userIds, false);
      }
      /**
       * @returns id of this device (if any exists)
       */
      getDeviceId() {
        return this.get(DEVICE_ID_STORAGE_KEY);
      }
      /**
       * @param deviceId The id of this device, to send on subsequent authentication requests.
       */
      setDeviceId(deviceId) {
        this.set(DEVICE_ID_STORAGE_KEY, deviceId);
      }
    };
    LOWERCASE_LETTERS = "abcdefghijklmnopqrstuvwxyz";
    CLOSE_CHECK_INTERVAL = 100;
    REDIRECT_HASH_TO_RESULT = {
      _stitch_client_app_id: "appId",
      _baas_client_app_id: "appId",
      _stitch_ua: "userAuth",
      _baas_ua: "userAuth",
      _stitch_link: "link",
      _baas_link: "link",
      _stitch_error: "error",
      _baas_error: "error",
      _stitch_state: "state",
      _baas_state: "state"
    };
    OAuth2Helper = class {
      /**
       * @param storage The underlying storage to use when storing and retriving secrets.
       * @param openWindow An optional function called when a browser window needs to open.
       */
      constructor(storage, openWindow2 = getEnvironment().openWindow) {
        this.storage = storage.prefix("oauth2");
        this.openWindow = openWindow2;
      }
      /**
       * Parses the query string from the final step of the OAuth flow.
       *
       * @param queryString The query string passed through in location.hash.
       * @returns The result of the OAuth flow.
       */
      static parseRedirectLocation(queryString) {
        const params = decodeQueryString(queryString);
        const result = {};
        for (const [p2, r2] of Object.entries(REDIRECT_HASH_TO_RESULT)) {
          const value = params[p2];
          if (value) {
            result[r2] = value;
          }
        }
        return result;
      }
      /**
       * Handle the redirect querystring by parsing it and storing it for others to consume.
       *
       * @param queryString The query string containing the encoded result from the OAuth provider.
       * @param storage The underlying storage used to persist the result.
       */
      static handleRedirect(queryString, storage = getEnvironment().defaultStorage) {
        const result = OAuth2Helper.parseRedirectLocation(queryString);
        const { state, error } = result;
        if (typeof state === "string") {
          const oauth2Storage = storage.prefix("oauth2");
          const stateStorage = OAuth2Helper.getStateStorage(oauth2Storage, state);
          stateStorage.set("result", JSON.stringify(result));
        } else if (error) {
          throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);
        } else {
          throw new Error("Failed to handle OAuth 2.0 redirect.");
        }
      }
      /**
       * Decodes the authInfo string into its seperate parts.
       *
       * @param authInfo An authInfo string returned from the server.
       * @returns An object containing the separate parts of the authInfo string.
       */
      static decodeAuthInfo(authInfo) {
        const parts = (authInfo || "").split("$");
        if (parts.length === 4) {
          const [accessToken, refreshToken, userId, deviceId] = parts;
          return { accessToken, refreshToken, userId, deviceId };
        } else {
          throw new Error("Failed to decode 'authInfo' into ids and tokens");
        }
      }
      /**
       * Get the storage key associated of an secret associated with a state.
       *
       * @param storage The root storage used to derive a "state namespaced" storage.
       * @param state The random state.
       * @returns The storage associated with a particular state.
       */
      static getStateStorage(storage, state) {
        return storage.prefix(`state(${state})`);
      }
      /**
       * Open a window and wait for the redirect to be handled.
       *
       * @param url The URL to open.
       * @param state The state which will be used to listen for storage updates.
       * @returns The result passed through the redirect.
       */
      openWindowAndWaitForRedirect(url, state) {
        const stateStorage = OAuth2Helper.getStateStorage(this.storage, state);
        return new Promise((resolve, reject) => {
          let redirectWindow = null;
          let windowClosedInterval;
          const handleStorageUpdate = () => {
            const result = stateStorage.get("result");
            if (result) {
              const parsedResult = JSON.parse(result);
              stateStorage.removeListener(handleStorageUpdate);
              stateStorage.clear();
              try {
                if (redirectWindow) {
                  clearInterval(windowClosedInterval);
                  redirectWindow.close();
                }
              } catch (err) {
                console.warn(`Failed closing redirect window: ${err}`);
              } finally {
                resolve(parsedResult);
              }
            }
          };
          stateStorage.addListener(handleStorageUpdate);
          redirectWindow = this.openWindow(url);
          windowClosedInterval = setInterval(() => {
            if (!redirectWindow) {
              clearInterval(windowClosedInterval);
            } else if (redirectWindow.closed) {
              clearInterval(windowClosedInterval);
              stateStorage.removeListener(handleStorageUpdate);
              const err = new Error("Window closed");
              reject(err);
            }
          }, CLOSE_CHECK_INTERVAL);
        });
      }
      /**
       * Generate a random state string.
       *
       * @returns The random state string.
       */
      generateState() {
        return generateRandomString(12, LOWERCASE_LETTERS);
      }
    };
    REDIRECT_LOCATION_HEADER = "x-baas-location";
    Authenticator = class {
      /**
       * @param fetcher The fetcher used to fetch responses from the server.
       * @param storage The storage used when completing OAuth 2.0 flows (should not be scoped to a specific app).
       * @param getDeviceInformation Called to get device information to be sent to the server.
       */
      constructor(fetcher, storage, getDeviceInformation) {
        this.fetcher = fetcher;
        this.oauth2 = new OAuth2Helper(storage);
        this.getDeviceInformation = getDeviceInformation;
      }
      /**
       * @param credentials Credentials to use when logging in.
       * @param linkingUser A user requesting to link.
       * @returns A promise resolving to the response from the server.
       */
      async authenticate(credentials, linkingUser) {
        const deviceInformation = this.getDeviceInformation();
        const isLinking = typeof linkingUser === "object";
        if (credentials.providerType.startsWith("oauth2") && typeof credentials.payload.redirectUrl === "string") {
          const state = this.oauth2.generateState();
          const url = await this.getLogInUrl(credentials, isLinking, {
            state,
            redirect: credentials.payload.redirectUrl,
            // Ensure redirects are communicated in a header different from "Location" and status remains 200 OK
            providerRedirectHeader: isLinking ? true : void 0,
            // Add the device information, only if we're not linking - since that request won't have a body of its own.
            device: !isLinking ? deviceInformation.encode() : void 0
          });
          if (isLinking) {
            const response = await this.fetcher.fetch({
              method: "GET",
              url,
              tokenType: isLinking ? "access" : "none",
              user: linkingUser,
              // The response will set a cookie that we need to tell the browser to store
              mode: "cors",
              credentials: "include"
            });
            const redirectUrl = response.headers.get(REDIRECT_LOCATION_HEADER);
            if (redirectUrl) {
              return this.openWindowAndWaitForAuthResponse(redirectUrl, state);
            } else {
              throw new Error(`Missing ${REDIRECT_LOCATION_HEADER} header`);
            }
          } else {
            return this.openWindowAndWaitForAuthResponse(url, state);
          }
        } else {
          const logInUrl = await this.getLogInUrl(credentials, isLinking);
          const response = await this.fetcher.fetchJSON({
            method: "POST",
            url: logInUrl,
            body: {
              ...credentials.payload,
              options: {
                device: deviceInformation.toJSON()
              }
            },
            tokenType: isLinking ? "access" : "none",
            user: linkingUser
          });
          const { user_id: userId, access_token: accessToken, refresh_token: refreshToken = null, device_id: deviceId } = response;
          if (typeof userId !== "string") {
            throw new Error("Expected a user id in the response");
          }
          if (typeof accessToken !== "string") {
            throw new Error("Expected an access token in the response");
          }
          if (typeof refreshToken !== "string" && refreshToken !== null) {
            throw new Error("Expected refresh token to be a string or null");
          }
          if (typeof deviceId !== "string") {
            throw new Error("Expected device id to be a string");
          }
          return { userId, accessToken, refreshToken, deviceId };
        }
      }
      /**
       * @param credentials Credentials to use when logging in.
       * @param link Should the request link with the current user?
       * @param extraQueryParams Any extra parameters to include in the query string
       * @returns A promise resolving to the url to be used when logging in.
       */
      async getLogInUrl(credentials, link = false, extraQueryParams = {}) {
        const appRoute = this.fetcher.appRoute;
        const loginRoute = appRoute.authProvider(credentials.providerName).login();
        const qs = encodeQueryString({
          link: link ? "true" : void 0,
          ...extraQueryParams
        });
        const locationUrl = await this.fetcher.locationUrl;
        return locationUrl + loginRoute.path + qs;
      }
      async openWindowAndWaitForAuthResponse(redirectUrl, state) {
        const redirectResult = await this.oauth2.openWindowAndWaitForRedirect(redirectUrl, state);
        return OAuth2Helper.decodeAuthInfo(redirectResult.userAuth);
      }
    };
    MongoDBRealmError = class extends Error {
      constructor(method, url, statusCode, statusText, error, errorCode, link) {
        const summary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;
        if (typeof error === "string") {
          super(`Request failed (${method} ${url}): ${error} (${summary})`);
        } else {
          super(`Request failed (${method} ${url}): (${summary})`);
        }
        this.method = method;
        this.url = url;
        this.statusText = statusText;
        this.statusCode = statusCode;
        this.error = error;
        this.errorCode = errorCode;
        this.link = link;
      }
      /**
       * Constructs and returns an error from a request and a response.
       * Note: The caller must throw this error themselves.
       *
       * @param request The request sent to the server.
       * @param response A raw response, as returned from the server.
       * @returns An error from a request and a response.
       */
      static async fromRequestAndResponse(request, response) {
        var _a2;
        const { url, method } = request;
        const { status, statusText } = response;
        if ((_a2 = response.headers.get("content-type")) === null || _a2 === void 0 ? void 0 : _a2.startsWith("application/json")) {
          const body = await response.json();
          if (typeof body === "object" && body) {
            const { error, error_code: errorCode, link } = body;
            return new MongoDBRealmError(method, url, status, statusText, typeof error === "string" ? error : void 0, typeof errorCode === "string" ? errorCode : void 0, typeof link === "string" ? link : void 0);
          }
        }
        return new MongoDBRealmError(method, url, status, statusText);
      }
    };
    Fetcher = class {
      /**
       * @param config A configuration of the fetcher.
       * @param config.appId The application id.
       * @param config.transport The transport used when fetching.
       * @param config.userContext An object used to determine the requesting user.
       * @param config.locationUrlContext An object used to determine the location / base URL.
       */
      constructor({ appId, transport, userContext, locationUrlContext }) {
        this.appId = appId;
        this.transport = transport;
        this.userContext = userContext;
        this.locationUrlContext = locationUrlContext;
      }
      /**
       * @param user An optional user to generate the header for.
       * @param tokenType The type of token (access or refresh).
       * @returns An object containing the user's token as "Authorization" header or undefined if no user is given.
       */
      static buildAuthorizationHeader(user, tokenType) {
        if (!user || tokenType === "none") {
          return {};
        } else if (tokenType === "access") {
          return { Authorization: `Bearer ${user.accessToken}` };
        } else if (tokenType === "refresh") {
          return { Authorization: `Bearer ${user.refreshToken}` };
        } else {
          throw new Error(`Unexpected token type (${tokenType})`);
        }
      }
      /**
       * @param body The body string or object passed from a request.
       * @returns An object optionally specifying the "Content-Type" header.
       */
      static buildBody(body) {
        if (!body) {
          return;
        } else if (typeof body === "object" && body !== null) {
          return JSON.stringify(serialize2(body));
        } else if (typeof body === "string") {
          return body;
        } else {
          console.log("body is", body);
          throw new Error("Unexpected type of body");
        }
      }
      /**
       * @param body The body string or object passed from a request.
       * @returns An object optionally specifying the "Content-Type" header.
       */
      static buildJsonHeader(body) {
        if (body && body.length > 0) {
          return { "Content-Type": "application/json" };
        } else {
          return {};
        }
      }
      clone(config) {
        return new Fetcher({
          appId: this.appId,
          transport: this.transport,
          userContext: this.userContext,
          locationUrlContext: this.locationUrlContext,
          ...config
        });
      }
      /**
       * Fetch a network resource as an authenticated user.
       *
       * @param request The request which should be sent to the server.
       * @returns The response from the server.
       */
      async fetch(request) {
        const { path, url, tokenType = "access", user = this.userContext.currentUser, ...restOfRequest } = request;
        if (typeof path === "string" && typeof url === "string") {
          throw new Error("Use of 'url' and 'path' mutually exclusive");
        } else if (typeof path === "string") {
          const url2 = await this.locationUrlContext.locationUrl + path;
          return this.fetch({ ...request, path: void 0, url: url2 });
        } else if (typeof url === "string") {
          const response = await this.transport.fetch({
            ...restOfRequest,
            url,
            headers: {
              ...Fetcher.buildAuthorizationHeader(user, tokenType),
              ...request.headers
            }
          });
          if (response.ok) {
            return response;
          } else if (user && response.status === 401 && tokenType === "access") {
            await user.refreshAccessToken();
            return this.fetch({ ...request, user });
          } else {
            if (user && response.status === 401 && tokenType === "refresh") {
              user.accessToken = null;
              user.refreshToken = null;
            }
            throw await MongoDBRealmError.fromRequestAndResponse(request, response);
          }
        } else {
          throw new Error("Expected either 'url' or 'path'");
        }
      }
      /**
       * Fetch a network resource as an authenticated user and parse the result as extended JSON.
       *
       * @param request The request which should be sent to the server.
       * @returns The response from the server, parsed as extended JSON.
       */
      async fetchJSON(request) {
        const { body } = request;
        const serializedBody = Fetcher.buildBody(body);
        const contentTypeHeaders = Fetcher.buildJsonHeader(serializedBody);
        const response = await this.fetch({
          ...request,
          body: serializedBody,
          headers: {
            Accept: "application/json",
            ...contentTypeHeaders,
            ...request.headers
          }
        });
        const contentType = response.headers.get("content-type");
        if (contentType === null || contentType === void 0 ? void 0 : contentType.startsWith("application/json")) {
          const responseBody = await response.json();
          return deserialize2(responseBody);
        } else if (contentType === null) {
          return null;
        } else {
          throw new Error(`Expected JSON response, got "${contentType}"`);
        }
      }
      /**
       * Fetch an "event-stream" resource as an authenticated user.
       *
       * @param request The request which should be sent to the server.
       * @returns An async iterator over the response body.
       */
      async fetchStream(request) {
        const { body } = await this.fetch({
          ...request,
          headers: {
            Accept: "text/event-stream",
            ...request.headers
          }
        });
        return asyncIteratorFromResponseBody(body);
      }
      /**
       * @returns The path of the app route.
       */
      get appRoute() {
        return routes2.api().app(this.appId);
      }
      /**
       * @returns A promise of the location URL of the app.
       */
      get locationUrl() {
        return this.locationUrlContext.locationUrl;
      }
    };
    DEVICE_ID_STORAGE_KEY$1 = "deviceId";
    (function(DeviceFields2) {
      DeviceFields2["DEVICE_ID"] = "deviceId";
      DeviceFields2["APP_ID"] = "appId";
      DeviceFields2["APP_VERSION"] = "appVersion";
      DeviceFields2["PLATFORM"] = "platform";
      DeviceFields2["PLATFORM_VERSION"] = "platformVersion";
      DeviceFields2["SDK_VERSION"] = "sdkVersion";
    })(DeviceFields || (DeviceFields = {}));
    DeviceInformation = class {
      /**
       * @param params Construct the device information from these parameters.
       * @param params.appId A user-defined application id.
       * @param params.appVersion A user-defined application version.
       * @param params.deviceId An unique id for the end-users device.
       */
      constructor({ appId, appVersion, deviceId }) {
        this.sdkVersion = "2.0.0";
        const environment2 = getEnvironment();
        this.platform = environment2.platform;
        this.platformVersion = environment2.platformVersion;
        this.appId = appId;
        this.appVersion = appVersion;
        this.deviceId = deviceId;
      }
      /**
       * @returns An base64 URI encoded representation of the device information.
       */
      encode() {
        const obj = removeKeysWithUndefinedValues(this);
        return gBase64.encode(JSON.stringify(obj));
      }
      /**
       * @returns The defaults
       */
      toJSON() {
        return removeKeysWithUndefinedValues(this);
      }
    };
    DEFAULT_BASE_URL = "https://realm.mongodb.com";
    App = class {
      /**
       * Construct a Realm App, either from the Realm App id visible from the Atlas App Services UI or a configuration.
       *
       * @param idOrConfiguration The Realm App id or a configuration to use for this app.
       */
      constructor(idOrConfiguration) {
        this.users = [];
        this._locationUrl = null;
        const configuration = typeof idOrConfiguration === "string" ? { id: idOrConfiguration } : idOrConfiguration;
        if (typeof configuration === "object" && typeof configuration.id === "string") {
          this.id = configuration.id;
        } else {
          throw new Error("Missing an Atlas App Services app-id");
        }
        this.baseUrl = configuration.baseUrl || DEFAULT_BASE_URL;
        if (configuration.skipLocationRequest) {
          this._locationUrl = Promise.resolve(this.baseUrl);
        }
        this.localApp = configuration.app;
        const { storage, transport = new DefaultNetworkTransport() } = configuration;
        this.fetcher = new Fetcher({
          appId: this.id,
          userContext: this,
          locationUrlContext: this,
          transport
        });
        this.emailPasswordAuth = new EmailPasswordAuth(this.fetcher);
        const baseStorage = storage || getEnvironment().defaultStorage;
        this.storage = new AppStorage(baseStorage, this.id);
        this.authenticator = new Authenticator(this.fetcher, baseStorage, () => this.deviceInformation);
        try {
          this.hydrate();
        } catch (err) {
          this.storage.clear();
          console.warn("Realm app hydration failed:", err instanceof Error ? err.message : err);
        }
      }
      /**
       * Get or create a singleton Realm App from an id.
       * Calling this function multiple times with the same id will return the same instance.
       *
       * @param id The Realm App id visible from the Atlas App Services UI or a configuration.
       * @returns The Realm App instance.
       */
      static getApp(id) {
        if (id in App.appCache) {
          return App.appCache[id];
        } else {
          const instance = new App(id);
          App.appCache[id] = instance;
          return instance;
        }
      }
      /**
       * Switch user.
       *
       * @param nextUser The user or id of the user to switch to.
       */
      switchUser(nextUser) {
        const index = this.users.findIndex((u2) => u2 === nextUser);
        if (index === -1) {
          throw new Error("The user was never logged into this app");
        }
        const [user] = this.users.splice(index, 1);
        this.users.unshift(user);
      }
      /**
       * Log in a user.
       *
       * @param credentials Credentials to use when logging in.
       * @param fetchProfile Should the users profile be fetched? (default: true)
       * @returns A promise resolving to the newly logged in user.
       */
      async logIn(credentials, fetchProfile = true) {
        const response = await this.authenticator.authenticate(credentials);
        const user = this.createOrUpdateUser(response, credentials.providerType);
        this.switchUser(user);
        if (fetchProfile) {
          await user.refreshProfile();
        }
        this.storage.setUserIds(this.users.map((u2) => u2.id), true);
        const deviceId = response.deviceId;
        if (deviceId && deviceId !== "000000000000000000000000") {
          this.storage.set(DEVICE_ID_STORAGE_KEY$1, deviceId);
        }
        return user;
      }
      /**
       * @inheritdoc
       */
      async removeUser(user) {
        const index = this.users.findIndex((u2) => u2 === user);
        if (index === -1) {
          throw new Error("The user was never logged into this app");
        }
        this.users.splice(index, 1);
        await user.logOut();
        this.storage.remove(`user(${user.id}):profile`);
        this.storage.removeUserId(user.id);
      }
      /**
       * @inheritdoc
       */
      async deleteUser(user) {
        await this.fetcher.fetchJSON({
          method: "DELETE",
          path: routes2.api().auth().delete().path
        });
        await this.removeUser(user);
      }
      /**
       * @inheritdoc
       */
      addListener() {
        throw new Error("Not yet implemented");
      }
      /**
       * @inheritdoc
       */
      removeListener() {
        throw new Error("Not yet implemented");
      }
      /**
       * @inheritdoc
       */
      removeAllListeners() {
        throw new Error("Not yet implemented");
      }
      /**
       * The currently active user (or null if no active users exists).
       *
       * @returns the currently active user or null.
       */
      get currentUser() {
        const activeUsers = this.users.filter((user) => user.state === UserState.Active);
        if (activeUsers.length === 0) {
          return null;
        } else {
          return activeUsers[0];
        }
      }
      /**
       * All active and logged-out users:
       *  - First in the list are active users (ordered by most recent call to switchUser or login)
       *  - Followed by logged out users (also ordered by most recent call to switchUser or login).
       *
       * @returns An array of users active or logged out users (current user being the first).
       */
      get allUsers() {
        return Object.fromEntries(this.users.map((user) => [user.id, user]));
      }
      /**
       * @returns A promise of the app URL, with the app location resolved.
       */
      get locationUrl() {
        if (!this._locationUrl) {
          const path = routes2.api().app(this.id).location().path;
          this._locationUrl = this.fetcher.fetchJSON({
            method: "GET",
            url: this.baseUrl + path,
            tokenType: "none"
          }).then((body) => {
            if (typeof body !== "object") {
              throw new Error("Expected response body be an object");
            } else {
              return body;
            }
          }).then(({ hostname }) => {
            if (typeof hostname !== "string") {
              throw new Error("Expected response to contain a 'hostname'");
            } else {
              return hostname;
            }
          }).catch((err) => {
            this._locationUrl = null;
            throw err;
          });
        }
        return this._locationUrl;
      }
      /**
       * @returns Information about the current device, sent to the server when authenticating.
       */
      get deviceInformation() {
        const deviceIdStr = this.storage.getDeviceId();
        const deviceId = typeof deviceIdStr === "string" && deviceIdStr !== "000000000000000000000000" ? new ObjectId(deviceIdStr) : void 0;
        return new DeviceInformation({
          appId: this.localApp ? this.localApp.name : void 0,
          appVersion: this.localApp ? this.localApp.version : void 0,
          deviceId
        });
      }
      /**
       * Create (and store) a new user or update an existing user's access and refresh tokens.
       * This helps de-duplicating users in the list of users known to the app.
       *
       * @param response A response from the Authenticator.
       * @param providerType The type of the authentication provider used.
       * @returns A new or an existing user.
       */
      createOrUpdateUser(response, providerType) {
        const existingUser = this.users.find((u2) => u2.id === response.userId);
        if (existingUser) {
          existingUser.accessToken = response.accessToken;
          existingUser.refreshToken = response.refreshToken;
          return existingUser;
        } else {
          if (!response.refreshToken) {
            throw new Error("No refresh token in response from server");
          }
          const user = new User({
            app: this,
            id: response.userId,
            accessToken: response.accessToken,
            refreshToken: response.refreshToken,
            providerType
          });
          this.users.unshift(user);
          return user;
        }
      }
      /**
       * Restores the state of the app (active and logged-out users) from the storage
       */
      hydrate() {
        const userIds = this.storage.getUserIds();
        this.users = userIds.map((id) => new User({ app: this, id }));
      }
    };
    App.appCache = {};
    App.Credentials = Credentials;
    setIsDevelopmentMode$1 = (state) => {
    };
    check$1 = function(it) {
      return it && it.Math == Math && it;
    };
    safeGlobalThis$1 = // eslint-disable-next-line no-restricted-globals
    check$1(typeof globalThis == "object" && globalThis) || check$1(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `self`
    check$1(typeof self == "object" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `global`
    check$1(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
    setIsDevelopmentMode$1(typeof __DEV__ !== "undefined" && __DEV__);
    LocalStorage = class {
      /**
       * Constructs a LocalStorage using the global window.
       */
      constructor() {
        if (typeof safeGlobalThis$1.localStorage === "object") {
          this.global = safeGlobalThis$1;
        } else {
          throw new Error("Cannot use LocalStorage without a global localStorage object");
        }
      }
      /** @inheritdoc */
      get(key) {
        return this.global.localStorage.getItem(key);
      }
      /** @inheritdoc */
      set(key, value) {
        return this.global.localStorage.setItem(key, value);
      }
      /** @inheritdoc */
      remove(key) {
        return this.global.localStorage.removeItem(key);
      }
      /** @inheritdoc */
      prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
      }
      /** @inheritdoc */
      clear(prefix) {
        const keys = [];
        for (let i2 = 0; i2 < this.global.localStorage.length; i2++) {
          const key = this.global.localStorage.key(i2);
          if (key && (!prefix || key.startsWith(prefix))) {
            keys.push(key);
          }
        }
        for (const key of keys) {
          this.global.localStorage.removeItem(key);
        }
      }
      /** @inheritdoc */
      addListener(listener) {
        return this.global.addEventListener("storage", listener);
      }
      /** @inheritdoc */
      removeListener(listener) {
        return this.global.removeEventListener("storage", listener);
      }
    };
    browser = detect();
    DefaultStorage = "localStorage" in safeGlobalThis$1 ? LocalStorage : MemoryStorage;
    environment$1 = {
      defaultStorage: new DefaultStorage().prefix("realm-web"),
      openWindow,
      platform: (browser === null || browser === void 0 ? void 0 : browser.name) || "web",
      platformVersion: (browser === null || browser === void 0 ? void 0 : browser.version) || "0.0.0",
      TextDecoder
    };
    setEnvironment(environment$1);
  }
});

// ../cf-utils/mongodb.js
async function GetMongo(context) {
  const app = new App({
    id: "application-0-cotzzqd"
  });
  const apiKey = context.env.MONGO_API_TOKEN;
  if (!apiKey) {
    throw new Error("Could not find a Server API Key.");
  }
  const credentials = Credentials.apiKey(apiKey);
  const user = await app.logIn(credentials);
  const client = user.mongoClient("mongodb-atlas");
  const scripts_collection = client.db("db").collection("scripts");
  return {
    client,
    scripts_collection,
    ObjectId: bson_browser_esm_exports.ObjectId,
    Binary: bson_browser_esm_exports.Binary
  };
}
var init_mongodb = __esm({
  "../cf-utils/mongodb.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_bundle_dom_es();
  }
});

// api/episodes.js
async function onRequestGet(context) {
  const { scripts_collection } = await GetMongo(context);
  const episodes = await scripts_collection.aggregate([
    {
      $sort: {
        _id: -1
      }
    }
  ]);
  return Response.json(
    episodes.map((episode) => ({
      url: episode.url,
      title: episode.script.title,
      views: episode.views
    }))
  );
}
var init_episodes = __esm({
  "api/episodes.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_mongodb();
  }
});

// ../node_modules/@google/generative-ai/dist/index.mjs
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  const headers = new Headers();
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = url.requestOptions.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e2) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e2.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeRequest(model, task, apiKey, stream, body, requestOptions) {
  return _makeRequestInternal(model, task, apiKey, stream, body, requestOptions, fetch);
}
async function _makeRequestInternal(model, task, apiKey, stream, body, requestOptions, fetchFn = fetch) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  let response;
  try {
    const request = await constructRequest(model, task, apiKey, stream, body, requestOptions);
    response = await fetchFn(request.url, request.fetchOptions);
    if (!response.ok) {
      let message = "";
      let errorDetails;
      try {
        const json = await response.json();
        message = json.error.message;
        if (json.error.details) {
          message += ` ${JSON.stringify(json.error.details)}`;
          errorDetails = json.error.details;
        }
      } catch (e2) {
      }
      throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
    }
  } catch (e2) {
    let err = e2;
    if (!(e2 instanceof GoogleGenerativeAIFetchError || e2 instanceof GoogleGenerativeAIRequestInputError)) {
      err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e2.message}`);
      err.stack = e2.stack;
    }
    throw err;
  }
  return response;
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const abortController = new AbortController();
    const signal = abortController.signal;
    setTimeout(() => abortController.abort(), requestOptions.timeout);
    fetchOptions.signal = signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  return response;
}
function getText(response) {
  var _a2, _b, _c2, _d2;
  const textStrings = [];
  if ((_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d2 = (_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0].content) === null || _d2 === void 0 ? void 0 : _d2.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a2, _b, _c2, _d2;
  const functionCalls = [];
  if ((_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d2 = (_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0].content) === null || _d2 === void 0 ? void 0 : _d2.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return void 0;
  }
}
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a2, _b, _c2;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a2 = response.promptFeedback) === null || _a2 === void 0 ? void 0 : _a2.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value;
          let match2 = currentText.match(responseLineRE);
          let parsedResponse;
          while (match2) {
            try {
              parsedResponse = JSON.parse(match2[1]);
            } catch (e2) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match2[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match2[0].length);
            match2 = currentText.match(responseLineRE);
          }
          return pump();
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      for (const candidate of response.candidates) {
        const i2 = candidate.index;
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[i2]) {
          aggregatedResponse.candidates[i2] = {
            index: candidate.index
          };
        }
        aggregatedResponse.candidates[i2].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[i2].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[i2].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[i2].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[i2].content) {
            aggregatedResponse.candidates[i2].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[i2].content.parts.push(newPart);
          }
        }
      }
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeRequest(
    model,
    Task.STREAM_GENERATE_CONTENT,
    apiKey,
    /* stream */
    true,
    JSON.stringify(params),
    requestOptions
  );
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeRequest(
    model,
    Task.GENERATE_CONTENT,
    apiKey,
    /* stream */
    false,
    JSON.stringify(params),
    requestOptions
  );
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return void 0;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request) {
  let newParts = [];
  if (typeof request === "string") {
    newParts = [{ text: request }];
  } else {
    for (const partOrString of request) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
function validateChatHistory(history) {
  let prevContent;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    if (prevContent) {
      const validPreviousContentRoles = VALID_PREVIOUS_CONTENT_ROLES[role];
      if (!validPreviousContentRoles.includes(prevContent.role)) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't follow '${prevContent.role}'. Valid previous roles: ${JSON.stringify(VALID_PREVIOUS_CONTENT_ROLES)}`);
      }
    }
    prevContent = currContent;
  }
}
async function countTokens(apiKey, model, params, requestOptions) {
  const response = await makeRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(Object.assign(Object.assign({}, params), { model })), requestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request) => {
    return Object.assign(Object.assign({}, request), { model });
  });
  const response = await makeRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}
var POSSIBLE_ROLES, HarmCategory, HarmBlockThreshold, HarmProbability, BlockReason, FinishReason, TaskType, FunctionCallingMode, FunctionDeclarationSchemaType, GoogleGenerativeAIError, GoogleGenerativeAIResponseError, GoogleGenerativeAIFetchError, GoogleGenerativeAIRequestInputError, DEFAULT_BASE_URL2, DEFAULT_API_VERSION, PACKAGE_VERSION, PACKAGE_LOG_HEADER, Task, RequestUrl, badFinishReasons, responseLineRE, VALID_PART_FIELDS, VALID_PARTS_PER_ROLE, VALID_PREVIOUS_CONTENT_ROLES, SILENT_ERROR, ChatSession, GenerativeModel, GoogleGenerativeAI;
var init_dist = __esm({
  "../node_modules/@google/generative-ai/dist/index.mjs"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    POSSIBLE_ROLES = ["user", "model", "function", "system"];
    (function(HarmCategory2) {
      HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
    })(HarmCategory || (HarmCategory = {}));
    (function(HarmBlockThreshold2) {
      HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
    })(HarmBlockThreshold || (HarmBlockThreshold = {}));
    (function(HarmProbability2) {
      HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability2["LOW"] = "LOW";
      HarmProbability2["MEDIUM"] = "MEDIUM";
      HarmProbability2["HIGH"] = "HIGH";
    })(HarmProbability || (HarmProbability = {}));
    (function(BlockReason2) {
      BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockReason2["SAFETY"] = "SAFETY";
      BlockReason2["OTHER"] = "OTHER";
    })(BlockReason || (BlockReason = {}));
    (function(FinishReason2) {
      FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason2["STOP"] = "STOP";
      FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason2["SAFETY"] = "SAFETY";
      FinishReason2["RECITATION"] = "RECITATION";
      FinishReason2["OTHER"] = "OTHER";
    })(FinishReason || (FinishReason = {}));
    (function(TaskType2) {
      TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
      TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
      TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
      TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
      TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
      TaskType2["CLUSTERING"] = "CLUSTERING";
    })(TaskType || (TaskType = {}));
    (function(FunctionCallingMode2) {
      FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingMode2["AUTO"] = "AUTO";
      FunctionCallingMode2["ANY"] = "ANY";
      FunctionCallingMode2["NONE"] = "NONE";
    })(FunctionCallingMode || (FunctionCallingMode = {}));
    (function(FunctionDeclarationSchemaType2) {
      FunctionDeclarationSchemaType2["STRING"] = "STRING";
      FunctionDeclarationSchemaType2["NUMBER"] = "NUMBER";
      FunctionDeclarationSchemaType2["INTEGER"] = "INTEGER";
      FunctionDeclarationSchemaType2["BOOLEAN"] = "BOOLEAN";
      FunctionDeclarationSchemaType2["ARRAY"] = "ARRAY";
      FunctionDeclarationSchemaType2["OBJECT"] = "OBJECT";
    })(FunctionDeclarationSchemaType || (FunctionDeclarationSchemaType = {}));
    GoogleGenerativeAIError = class extends Error {
      constructor(message) {
        super(`[GoogleGenerativeAI Error]: ${message}`);
      }
    };
    GoogleGenerativeAIResponseError = class extends GoogleGenerativeAIError {
      constructor(message, response) {
        super(message);
        this.response = response;
      }
    };
    GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
      constructor(message, status, statusText, errorDetails) {
        super(message);
        this.status = status;
        this.statusText = statusText;
        this.errorDetails = errorDetails;
      }
    };
    GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
    };
    DEFAULT_BASE_URL2 = "https://generativelanguage.googleapis.com";
    DEFAULT_API_VERSION = "v1beta";
    PACKAGE_VERSION = "0.11.1";
    PACKAGE_LOG_HEADER = "genai-js";
    (function(Task2) {
      Task2["GENERATE_CONTENT"] = "generateContent";
      Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
      Task2["COUNT_TOKENS"] = "countTokens";
      Task2["EMBED_CONTENT"] = "embedContent";
      Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
    })(Task || (Task = {}));
    RequestUrl = class {
      constructor(model, task, apiKey, stream, requestOptions) {
        this.model = model;
        this.task = task;
        this.apiKey = apiKey;
        this.stream = stream;
        this.requestOptions = requestOptions;
      }
      toString() {
        var _a2, _b;
        const apiVersion = ((_a2 = this.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.apiVersion) || DEFAULT_API_VERSION;
        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL2;
        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
        if (this.stream) {
          url += "?alt=sse";
        }
        return url;
      }
    };
    badFinishReasons = [FinishReason.RECITATION, FinishReason.SAFETY];
    responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
    VALID_PART_FIELDS = [
      "text",
      "inlineData",
      "functionCall",
      "functionResponse"
    ];
    VALID_PARTS_PER_ROLE = {
      user: ["text", "inlineData"],
      function: ["functionResponse"],
      model: ["text", "functionCall"],
      // System instructions shouldn't be in history anyway.
      system: ["text"]
    };
    VALID_PREVIOUS_CONTENT_ROLES = {
      user: ["model"],
      function: ["model"],
      model: ["user", "function"],
      // System instructions shouldn't be in history.
      system: []
    };
    SILENT_ERROR = "SILENT_ERROR";
    ChatSession = class {
      constructor(apiKey, model, params, requestOptions) {
        this.model = model;
        this.params = params;
        this.requestOptions = requestOptions;
        this._history = [];
        this._sendPromise = Promise.resolve();
        this._apiKey = apiKey;
        if (params === null || params === void 0 ? void 0 : params.history) {
          validateChatHistory(params.history);
          this._history = params.history;
        }
      }
      /**
       * Gets the chat history so far. Blocked prompts are not added to history.
       * Blocked candidates are not added to history, nor are the prompts that
       * generated them.
       */
      async getHistory() {
        await this._sendPromise;
        return this._history;
      }
      /**
       * Sends a chat message and receives a non-streaming
       * {@link GenerateContentResult}
       */
      async sendMessage(request) {
        var _a2, _b, _c2, _d2, _e2;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
          safetySettings: (_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.safetySettings,
          generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
          tools: (_c2 = this.params) === null || _c2 === void 0 ? void 0 : _c2.tools,
          toolConfig: (_d2 = this.params) === null || _d2 === void 0 ? void 0 : _d2.toolConfig,
          systemInstruction: (_e2 = this.params) === null || _e2 === void 0 ? void 0 : _e2.systemInstruction,
          contents: [...this._history, newContent]
        };
        let finalResult;
        this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, this.requestOptions)).then((result) => {
          var _a3;
          if (result.response.candidates && result.response.candidates.length > 0) {
            this._history.push(newContent);
            const responseContent = Object.assign({
              parts: [],
              // Response seems to come back without a role set.
              role: "model"
            }, (_a3 = result.response.candidates) === null || _a3 === void 0 ? void 0 : _a3[0].content);
            this._history.push(responseContent);
          } else {
            const blockErrorMessage = formatBlockErrorMessage(result.response);
            if (blockErrorMessage) {
              console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
            }
          }
          finalResult = result;
        });
        await this._sendPromise;
        return finalResult;
      }
      /**
       * Sends a chat message and receives the response as a
       * {@link GenerateContentStreamResult} containing an iterable stream
       * and a response promise.
       */
      async sendMessageStream(request) {
        var _a2, _b, _c2, _d2, _e2;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
          safetySettings: (_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.safetySettings,
          generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
          tools: (_c2 = this.params) === null || _c2 === void 0 ? void 0 : _c2.tools,
          toolConfig: (_d2 = this.params) === null || _d2 === void 0 ? void 0 : _d2.toolConfig,
          systemInstruction: (_e2 = this.params) === null || _e2 === void 0 ? void 0 : _e2.systemInstruction,
          contents: [...this._history, newContent]
        };
        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, this.requestOptions);
        this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
          throw new Error(SILENT_ERROR);
        }).then((streamResult) => streamResult.response).then((response) => {
          if (response.candidates && response.candidates.length > 0) {
            this._history.push(newContent);
            const responseContent = Object.assign({}, response.candidates[0].content);
            if (!responseContent.role) {
              responseContent.role = "model";
            }
            this._history.push(responseContent);
          } else {
            const blockErrorMessage = formatBlockErrorMessage(response);
            if (blockErrorMessage) {
              console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
            }
          }
        }).catch((e2) => {
          if (e2.message !== SILENT_ERROR) {
            console.error(e2);
          }
        });
        return streamPromise;
      }
    };
    GenerativeModel = class {
      constructor(apiKey, modelParams, requestOptions) {
        this.apiKey = apiKey;
        if (modelParams.model.includes("/")) {
          this.model = modelParams.model;
        } else {
          this.model = `models/${modelParams.model}`;
        }
        this.generationConfig = modelParams.generationConfig || {};
        this.safetySettings = modelParams.safetySettings || [];
        this.tools = modelParams.tools;
        this.toolConfig = modelParams.toolConfig;
        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
        this.requestOptions = requestOptions || {};
      }
      /**
       * Makes a single non-streaming call to the model
       * and returns an object containing a single {@link GenerateContentResponse}.
       */
      async generateContent(request) {
        const formattedParams = formatGenerateContentInput(request);
        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, formattedParams), this.requestOptions);
      }
      /**
       * Makes a single streaming call to the model
       * and returns an object containing an iterable stream that iterates
       * over all chunks in the streaming response as well as
       * a promise that returns the final aggregated response.
       */
      async generateContentStream(request) {
        const formattedParams = formatGenerateContentInput(request);
        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, formattedParams), this.requestOptions);
      }
      /**
       * Gets a new {@link ChatSession} instance which can be used for
       * multi-turn chats.
       */
      startChat(startChatParams) {
        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, startChatParams), this.requestOptions);
      }
      /**
       * Counts the tokens in the provided request.
       */
      async countTokens(request) {
        const formattedParams = formatGenerateContentInput(request);
        return countTokens(this.apiKey, this.model, formattedParams, this.requestOptions);
      }
      /**
       * Embeds the provided content.
       */
      async embedContent(request) {
        const formattedParams = formatEmbedContentInput(request);
        return embedContent(this.apiKey, this.model, formattedParams, this.requestOptions);
      }
      /**
       * Embeds an array of {@link EmbedContentRequest}s.
       */
      async batchEmbedContents(batchEmbedContentRequest) {
        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, this.requestOptions);
      }
    };
    GoogleGenerativeAI = class {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
      /**
       * Gets a {@link GenerativeModel} instance for the provided model name.
       */
      getGenerativeModel(modelParams, requestOptions) {
        if (!modelParams.model) {
          throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
        }
        return new GenerativeModel(this.apiKey, modelParams, requestOptions);
      }
    };
  }
});

// ../cf-utils/request.js
var RequestMD;
var init_request = __esm({
  "../cf-utils/request.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    RequestMD = `
# Episode Creation Request

## Show Theme: House M.D.

Generate an episode script based on the popular medical drama series, "House M.D.". The primary focus should be on Dr. Gregory House and his diagnostic team, with their unique personalities and interactions.

## Requirements

- Episode duration should be at least 2 minutes long
- Only one character can speak at a time
- A character cannot be on the same node at a time
- A character can either start off the screen, invisible, or be visible at a node already
- Movements of characters should be realistic. For instance, they shouldn't suddenly jump from one end of the scene to the other
- Make all the characters have the same personality that they have on the show, for example make House a genius, sarcastic, direct, and mean
- Try To make the episode sound and feel like a House MD episode
- The dynamic between Dr. House and Dr. Wilson should be highlighted
- Include moments of tension, mystery, and revelation as the team unravels the medical mystery
- Use medical terminologies accurately
- The duration on dialogues should be accurate how long it would actually take to say that
- Make sure the episode timelime flows right. After one event is done, it should go right to the next. No pause in between
- All characters in a scene MUST be defined in the intial state. A character cannot just suddenly appear if they are not defined in the initial state
- When changing to a new scene, you DO NOT call a scene action_type of scene just to fade out or whatever, The action type would just be fade and it would take care of it. So don't call it twice in consecutive order
- The last events timestamp and duration must add up to the episode total duration
- Scene Transitions: Each scene transition should only be mentioned once. Avoid repetitive transitions to the same scene (e.g., do not fade out and then fade back into the same scene). Transition to a new scene directly.
- Single Action Events: Each timestamp in the timeline should represent a single, distinct action. This provides clarity and ensures each action receives the appropriate focus and duration in the narrative.
- Overlapping Durations: While each timestamp represents a single action, the duration of an action CANNOT extend beyond the next timestamp.
- Complete InitialState Data: For each scene's initialState, every character listed, whether visible or not, must have a defined position (startX, startY, scale, and rotation). If a character is initially invisible or off-screen but will be used later in the scene, they should still have a position set in the initialState.
- Direct Scene Introduction: If a character is intended to be on screen at the beginning of a scene, they should be set as "visible": true in the initialState of the scene. Do not use the "appear" action immediately after a scene transition to introduce characters that are meant to be present from the start of the scene. Instead, make them visible by default using the initialState.

## Topic

By default the episode should revolve around a rare and challenging medical case unless the user specifys otherwise.

## Characters

These are the only available characters to use: House, Cuddy, Wilson, Chase, Cameron, and a Patient. You don't have to use all the characters. They are just avaliable to use. However, House must always be in the script and the patient must be in the script.

## Scenes/Nodes

These are the nodes you MUST follow for the characters. When the node has ONLY that means only that character is allowed to be on that node

1. Hallway Scene:

Node 1: (x: 774.9, y: 707.3, scale: 0.6)
Node 2: (x: 677.7, y: 538.8, scale: 0.2)
Node 3: (x: 531.3, y: 709.3, scale: 0.6)
Node 4: (x: 310.0, y: 554.2, scale: 0.4)
Node 5: (x: 97.0, y: 671.0, scale: 0.5)

2. Hospital Room Scene:

Node 1: (x: 155.7, y: 495.9, scale: 0.35, rotation: 0)
Node 2: (x: 342.5, y: 472.5, scale: 0.25, rotation: 0)
Node 3: (x: 532.8, y: 449.7, scale: 0.35, rotation: 0)
Node 4: (x: 279.0, y: 775.2, scale: 0.4, rotation: 0)
Node 5: (x: 722.4, y: 750.6, scale: 0.4, rotation: 0)
Node 6: (x: 910, y: 515.8, scale: 0.25, rotation: 50) Only for the patient.

3. Meeting Scene:

Node 1: (x: 809.9, y: 561.3, scale: 0.6)
Node 2: (x: 687.7, y: 342.8, scale: 0.2)
Node 3: (x: 584.3, y: 627.3, scale: 0.6)
Node 4: (x: 326.5, y: 344.7, scale: 0.3)
Node 5: (x: 153.0, y: 516.0, scale: 0.5)

4. MRI Scene:

Node 1: (x: 892.9, y: 435.3, scale: 0.6, rotation: 0)
Node 2: (x: 725.1, y: 370.1, scale: 0.35, rotation: 0)
Node 3: (x: 400.7, y: 400.8, scale: 0.45, rotation: 290) Only for the patient.
Node 4: (x: 102.8, y: 478.0, scale: 0.55, rotation: 0)

5. Office Scene:

Node 1: (x: 847.9, y: 644.3, scale: 0.6)
Node 2: (x: 699.5, y: 514.7, scale: 0.3)
Node 3: (x: 530.0, y: 669.0, scale: 0.5)
Node 4: (x: 324.4, y: 667.9, scale: 0.7)
Node 5: (x: 98.4, y: 520.6, scale: 0.4)

6. OR Scene:

Node 1: (x: 149.3, y: 709.3, scale: 0.6)
Node 2: (x: 845.9, y: 716.3, scale: 0.6)
Node 3: (x: 550.0, y: 707.5, scale: 0.5, rotation: 60) Only for the patient.

## Structure

The script will be structured in the following way:

title: This is the name of the episode. It should be catchy and relevant to the episode's theme.

description: This is the description of the episode.

duration: This is the total runtime of the episode in seconds. For instance, 300 seconds mean the episode is 5 minutes long.

all_scenes: A list of all the places or settings that will be shown in this episode.

all_characters: A list of all the characters that will appear in this episode.

timeline: This is a list detailing what happens at specific times in the episode. Each event in the timeline has:

-timestamp: The time (in seconds) when the event starts.
-action: What is happening at that timestamp. The action has an action_type which can be one of the following:
--appear: A character comes into the scene.
--talk: A character says something. This action will also have a dialogue detailing what the character says.
--move: A character moves to a new location on the screen. This action will also have details about the start and end position of the movement.
--rotate: A character rotates to a specific angle.
--scene: The scene or setting changes.

Detailed Breakdown of Action Types

1. appear:
   When a character first enters the scene or becomes visible.

character: The name of the character that is appearing.
action_type: Should be set to "appear".
duration: Duration in seconds for how long this action takes.

2. talk:
   When a character speaks.

character: The name of the character that is speaking.
action_type: Should be set to "talk".
dialogue: The content of what the character says. This could be a single sentence or multiple sentences.
duration: Duration in seconds for how long this dialogue will be displayed or spoken.

3. move:
   Represents a character moving from one spot to another.

character: The name of the character that is moving.
action_type: Should be set to "move".
position: Details about the movement:
startX: The starting horizontal position (x-coordinate).
startY: The starting vertical position (y-coordinate).
endX: The ending horizontal position (x-coordinate).
endY: The ending vertical position (y-coordinate).
scale: The size scale of the character during the movement. For instance, 1 is full size, 0.5 is half size.
rotation: The rotation angle of the character during the movement, in degrees.

4. rotate:
   When a character rotates to a specific angle.

character: The name of the character that is rotating.
action_type: Should be set to "rotate".
rotation: The angle in degrees to which the character should rotate.

5. scene:
   Represents a change in the scene or setting.

action_type: Must be set to "scene".
scene: The name of the new scene or setting.
transition_effect: The visual effect to use when transitioning from one scene to another. Examples include "fade", "slide", "wipe", etc.
duration: Duration in seconds for how long the transition effect takes.
initialState: This represents the initial positions, scales, rotations, and visibility of all characters in the new scene. It should be structured as follows:
characters: An array of characters with their attributes:
name: The name of the character.
visible: A boolean indicating if the character is visible or not.
position: An object describing the character's position, scale, and rotation:
startX: The horizontal position (x-coordinate).
startY: The vertical position (y-coordinate).
scale: The size scale of the character. For instance, 1 is full size, 0.5 is half size.
rotation: The rotation angle of the character, in degrees.

Example of an action that plays at the 1 second mark
{
"timestamp": 1,
"character": "house",
"action": {
"action_type": "talk",
"dialogue": "Hello World!",
"duration": 2
}
}

## Output

ONLY A JSON OBJECT NOTHING ELSE. DO NOT PUT IN CODE BLOCK. ALSO MAKE SURE THAT THE LAST TIMESTAMP + DURATION ADDS UP TO 120!
`;
  }
});

// ../cf-utils/ttsmap.js
var ttsmap;
var init_ttsmap = __esm({
  "../cf-utils/ttsmap.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    ttsmap = {
      house: { name: "Antoni", id: "ErXwobaYiN019PkySvjV" },
      chase: { name: "Charlie", id: "IKne3meq5aSn9XLyUdCD" },
      wilson: { name: "Arnold", id: "VR6AewLTigWG4xSOukaG" },
      cuddy: { name: "Rachel", id: "21m00Tcm4TlvDq8ikWAM" },
      cameron: { name: "Glinda", id: "z9fAnlkpzviPz146aGWa" },
      patient: { name: "Adam", id: "pNInz6obpgDQGcFmaJgB" }
    };
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
var getHttpHandlerExtensionConfiguration, resolveHttpHandlerRuntimeConfig;
var init_httpExtensionConfiguration = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
      let httpHandler = runtimeConfig.httpHandler;
      return {
        setHttpHandler(handler) {
          httpHandler = handler;
        },
        httpHandler() {
          return httpHandler;
        },
        updateHttpClientConfig(key, value) {
          httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
          return httpHandler.httpHandlerConfigs();
        }
      };
    };
    resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
      return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler()
      };
    };
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/extensions/index.js
var init_extensions = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/extensions/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_httpExtensionConfiguration();
  }
});

// ../node_modules/@smithy/types/dist-es/abort.js
var init_abort = __esm({
  "../node_modules/@smithy/types/dist-es/abort.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
var init_auth = __esm({
  "../node_modules/@smithy/types/dist-es/auth/auth.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(HttpAuthLocation2) {
      HttpAuthLocation2["HEADER"] = "header";
      HttpAuthLocation2["QUERY"] = "query";
    })(HttpAuthLocation || (HttpAuthLocation = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
var init_HttpApiKeyAuth = __esm({
  "../node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(HttpApiKeyAuthLocation2) {
      HttpApiKeyAuthLocation2["HEADER"] = "header";
      HttpApiKeyAuthLocation2["QUERY"] = "query";
    })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
var init_HttpAuthScheme = __esm({
  "../node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
var init_HttpAuthSchemeProvider = __esm({
  "../node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/auth/HttpSigner.js
var init_HttpSigner = __esm({
  "../node_modules/@smithy/types/dist-es/auth/HttpSigner.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
var init_IdentityProviderConfig = __esm({
  "../node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/auth/index.js
var init_auth2 = __esm({
  "../node_modules/@smithy/types/dist-es/auth/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_auth();
    init_HttpApiKeyAuth();
    init_HttpAuthScheme();
    init_HttpAuthSchemeProvider();
    init_HttpSigner();
    init_IdentityProviderConfig();
  }
});

// ../node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
var init_blob_payload_input_types = __esm({
  "../node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/checksum.js
var init_checksum = __esm({
  "../node_modules/@smithy/types/dist-es/checksum.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/client.js
var init_client = __esm({
  "../node_modules/@smithy/types/dist-es/client.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/command.js
var init_command = __esm({
  "../node_modules/@smithy/types/dist-es/command.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/connection/config.js
var init_config = __esm({
  "../node_modules/@smithy/types/dist-es/connection/config.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/connection/manager.js
var init_manager = __esm({
  "../node_modules/@smithy/types/dist-es/connection/manager.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/connection/pool.js
var init_pool = __esm({
  "../node_modules/@smithy/types/dist-es/connection/pool.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/connection/index.js
var init_connection = __esm({
  "../node_modules/@smithy/types/dist-es/connection/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_config();
    init_manager();
    init_pool();
  }
});

// ../node_modules/@smithy/types/dist-es/crypto.js
var init_crypto = __esm({
  "../node_modules/@smithy/types/dist-es/crypto.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/encode.js
var init_encode = __esm({
  "../node_modules/@smithy/types/dist-es/encode.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
var init_endpoint = __esm({
  "../node_modules/@smithy/types/dist-es/endpoint.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(EndpointURLScheme2) {
      EndpointURLScheme2["HTTP"] = "http";
      EndpointURLScheme2["HTTPS"] = "https";
    })(EndpointURLScheme || (EndpointURLScheme = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
var init_EndpointRuleObject = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
var init_ErrorRuleObject = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
var init_RuleSetObject = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/shared.js
var init_shared = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/shared.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
var init_TreeRuleObject = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/endpoints/index.js
var init_endpoints = __esm({
  "../node_modules/@smithy/types/dist-es/endpoints/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EndpointRuleObject();
    init_ErrorRuleObject();
    init_RuleSetObject();
    init_shared();
    init_TreeRuleObject();
  }
});

// ../node_modules/@smithy/types/dist-es/eventStream.js
var init_eventStream = __esm({
  "../node_modules/@smithy/types/dist-es/eventStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
var init_checksum2 = __esm({
  "../node_modules/@smithy/types/dist-es/extensions/checksum.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(AlgorithmId2) {
      AlgorithmId2["MD5"] = "md5";
      AlgorithmId2["CRC32"] = "crc32";
      AlgorithmId2["CRC32C"] = "crc32c";
      AlgorithmId2["SHA1"] = "sha1";
      AlgorithmId2["SHA256"] = "sha256";
    })(AlgorithmId || (AlgorithmId = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
var init_defaultClientConfiguration = __esm({
  "../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_checksum2();
  }
});

// ../node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
var init_defaultExtensionConfiguration = __esm({
  "../node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/extensions/index.js
var init_extensions2 = __esm({
  "../node_modules/@smithy/types/dist-es/extensions/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_defaultClientConfiguration();
    init_defaultExtensionConfiguration();
    init_checksum2();
  }
});

// ../node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
var init_http = __esm({
  "../node_modules/@smithy/types/dist-es/http.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(FieldPosition2) {
      FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
      FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition || (FieldPosition = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
var init_httpHandlerInitialization = __esm({
  "../node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
var init_apiKeyIdentity = __esm({
  "../node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
var init_awsCredentialIdentity = __esm({
  "../node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/identity/identity.js
var init_identity = __esm({
  "../node_modules/@smithy/types/dist-es/identity/identity.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
var init_tokenIdentity = __esm({
  "../node_modules/@smithy/types/dist-es/identity/tokenIdentity.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/identity/index.js
var init_identity2 = __esm({
  "../node_modules/@smithy/types/dist-es/identity/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_apiKeyIdentity();
    init_awsCredentialIdentity();
    init_identity();
    init_tokenIdentity();
  }
});

// ../node_modules/@smithy/types/dist-es/logger.js
var init_logger = __esm({
  "../node_modules/@smithy/types/dist-es/logger.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/middleware.js
var SMITHY_CONTEXT_KEY;
var init_middleware = __esm({
  "../node_modules/@smithy/types/dist-es/middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    SMITHY_CONTEXT_KEY = "__smithy_context";
  }
});

// ../node_modules/@smithy/types/dist-es/pagination.js
var init_pagination = __esm({
  "../node_modules/@smithy/types/dist-es/pagination.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
var init_profile = __esm({
  "../node_modules/@smithy/types/dist-es/profile.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(IniSectionType2) {
      IniSectionType2["PROFILE"] = "profile";
      IniSectionType2["SSO_SESSION"] = "sso-session";
      IniSectionType2["SERVICES"] = "services";
    })(IniSectionType || (IniSectionType = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/response.js
var init_response = __esm({
  "../node_modules/@smithy/types/dist-es/response.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/retry.js
var init_retry = __esm({
  "../node_modules/@smithy/types/dist-es/retry.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/serde.js
var init_serde = __esm({
  "../node_modules/@smithy/types/dist-es/serde.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/shapes.js
var init_shapes = __esm({
  "../node_modules/@smithy/types/dist-es/shapes.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/signature.js
var init_signature = __esm({
  "../node_modules/@smithy/types/dist-es/signature.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/stream.js
var init_stream = __esm({
  "../node_modules/@smithy/types/dist-es/stream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
var init_streaming_blob_common_types = __esm({
  "../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
var init_streaming_blob_payload_input_types = __esm({
  "../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
var init_streaming_blob_payload_output_types = __esm({
  "../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
var init_transfer = __esm({
  "../node_modules/@smithy/types/dist-es/transfer.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(RequestHandlerProtocol2) {
      RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
      RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
      RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
  }
});

// ../node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
var init_client_payload_blob_type_narrow = __esm({
  "../node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/transform/no-undefined.js
var init_no_undefined = __esm({
  "../node_modules/@smithy/types/dist-es/transform/no-undefined.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/transform/type-transform.js
var init_type_transform = __esm({
  "../node_modules/@smithy/types/dist-es/transform/type-transform.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/uri.js
var init_uri = __esm({
  "../node_modules/@smithy/types/dist-es/uri.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/util.js
var init_util = __esm({
  "../node_modules/@smithy/types/dist-es/util.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/waiter.js
var init_waiter = __esm({
  "../node_modules/@smithy/types/dist-es/waiter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/types/dist-es/index.js
var init_dist_es = __esm({
  "../node_modules/@smithy/types/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_abort();
    init_auth2();
    init_blob_payload_input_types();
    init_checksum();
    init_client();
    init_command();
    init_connection();
    init_crypto();
    init_encode();
    init_endpoint();
    init_endpoints();
    init_eventStream();
    init_extensions2();
    init_http();
    init_httpHandlerInitialization();
    init_identity2();
    init_logger();
    init_middleware();
    init_pagination();
    init_profile();
    init_response();
    init_retry();
    init_serde();
    init_shapes();
    init_signature();
    init_stream();
    init_streaming_blob_common_types();
    init_streaming_blob_payload_input_types();
    init_streaming_blob_payload_output_types();
    init_transfer();
    init_client_payload_blob_type_narrow();
    init_no_undefined();
    init_type_transform();
    init_uri();
    init_util();
    init_waiter();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/Field.js
var init_Field = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/Field.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/Fields.js
var init_Fields = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/Fields.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/httpHandler.js
var init_httpHandler = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/httpHandler.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}
var HttpRequest;
var init_httpRequest = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/httpRequest.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    HttpRequest = class {
      constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
      }
      static isInstance(request) {
        if (!request)
          return false;
        const req = request;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
      }
      clone() {
        const cloned = new HttpRequest({
          ...this,
          headers: { ...this.headers }
        });
        if (cloned.query)
          cloned.query = cloneQuery(cloned.query);
        return cloned;
      }
    };
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var HttpResponse;
var init_httpResponse = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/httpResponse.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    HttpResponse = class {
      constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
      }
      static isInstance(response) {
        if (!response)
          return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
      }
    };
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
function isValidHostname(hostname) {
  const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
  return hostPattern.test(hostname);
}
var init_isValidHostname = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/isValidHostname.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/types.js
var init_types = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/protocol-http/dist-es/index.js
var init_dist_es2 = __esm({
  "../node_modules/@smithy/protocol-http/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_extensions();
    init_Field();
    init_Fields();
    init_httpHandler();
    init_httpRequest();
    init_httpResponse();
    init_isValidHostname();
    init_types();
  }
});

// ../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
      if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        request.headers = {
          ...request.headers,
          Expect: "100-continue"
        };
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions, getAddExpectContinuePlugin;
var init_dist_es3 = __esm({
  "../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    addExpectContinueMiddlewareOptions = {
      step: "build",
      tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
      name: "addExpectContinueMiddleware",
      override: true
    };
    getAddExpectContinuePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware, hostHeaderMiddlewareOptions, getHostHeaderPlugin;
var init_dist_es4 = __esm({
  "../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    hostHeaderMiddleware = (options) => (next) => async (args) => {
      if (!HttpRequest.isInstance(args.request))
        return next(args);
      const { request } = args;
      const { handlerProtocol = "" } = options.requestHandler.metadata || {};
      if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
      } else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
          host += `:${request.port}`;
        request.headers["host"] = host;
      }
      return next(args);
    };
    hostHeaderMiddlewareOptions = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: true
    };
    getHostHeaderPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware, loggerMiddlewareOptions, getLoggerPlugin;
var init_loggerMiddleware = __esm({
  "../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    loggerMiddleware = () => (next, context) => async (args) => {
      try {
        const response = await next(args);
        const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger2?.info?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          output: outputFilterSensitiveLog(outputWithoutMetadata),
          metadata: $metadata
        });
        return response;
      } catch (error) {
        const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger2?.error?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          error,
          metadata: error.$metadata
        });
        throw error;
      }
    };
    loggerMiddlewareOptions = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: true
    };
    getLoggerPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-logger/dist-es/index.js
var init_dist_es5 = __esm({
  "../node_modules/@aws-sdk/middleware-logger/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_loggerMiddleware();
  }
});

// ../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME, ENV_LAMBDA_FUNCTION_NAME, ENV_TRACE_ID, recursionDetectionMiddleware, addRecursionDetectionMiddlewareOptions, getRecursionDetectionPlugin;
var init_dist_es6 = __esm({
  "../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
    ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
    ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
    recursionDetectionMiddleware = (options) => (next) => async (args) => {
      const { request } = args;
      if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
      }
      const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
      const traceId = process.env[ENV_TRACE_ID];
      const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
      if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
      }
      return next({
        ...args,
        request
      });
    };
    addRecursionDetectionMiddlewareOptions = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: true,
      priority: "low"
    };
    getRecursionDetectionPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger;
var init_NoOpLogger = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    NoOpLogger = class {
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
  }
});

// ../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var getAllAliases, getMiddlewareNameWithAliases, constructStack, stepWeights, priorityWeights;
var init_MiddlewareStack = __esm({
  "../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getAllAliases = (name, aliases) => {
      const _aliases = [];
      if (name) {
        _aliases.push(name);
      }
      if (aliases) {
        for (const alias of aliases) {
          _aliases.push(alias);
        }
      }
      return _aliases;
    };
    getMiddlewareNameWithAliases = (name, aliases) => {
      return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    constructStack = () => {
      let absoluteEntries = [];
      let relativeEntries = [];
      let identifyOnResolve = false;
      const entriesNameSet = /* @__PURE__ */ new Set();
      const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
      const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const aliases = getAllAliases(entry.name, entry.aliases);
          if (aliases.includes(toRemove)) {
            isRemoved = true;
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          if (entry.middleware === toRemove) {
            isRemoved = true;
            for (const alias of getAllAliases(entry.name, entry.aliases)) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
          toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
          toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
      };
      const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        return expandedMiddlewareList;
      };
      const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
          if (entry.toMiddleware) {
            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
            if (toMiddleware === void 0) {
              if (debug) {
                return;
              }
              throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
            }
            if (entry.relation === "after") {
              toMiddleware.after.push(entry);
            }
            if (entry.relation === "before") {
              toMiddleware.before.push(entry);
            }
          }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
          wholeList.push(...expandedMiddlewareList);
          return wholeList;
        }, []);
        return mainChain;
      };
      const stack = {
        add: (middleware, options = {}) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            step: "initialize",
            priority: "normal",
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = absoluteEntries[toOverrideIndex];
                if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
                }
                absoluteEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = relativeEntries[toOverrideIndex];
                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                }
                relativeEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
          plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
          if (typeof toRemove === "string")
            return removeByName(toRemove);
          else
            return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
          let isRemoved = false;
          const filterCb = (entry) => {
            const { tags, name, aliases: _aliases } = entry;
            if (tags && tags.includes(toRemove)) {
              const aliases = getAllAliases(name, _aliases);
              for (const alias of aliases) {
                entriesNameSet.delete(alias);
              }
              isRemoved = true;
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        },
        concat: (from) => {
          const cloned = cloneTo(constructStack());
          cloned.use(from);
          cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
          return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
          return getMiddlewareList(true).map((mw) => {
            const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
            return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
          });
        },
        identifyOnResolve(toggle) {
          if (typeof toggle === "boolean")
            identifyOnResolve = toggle;
          return identifyOnResolve;
        },
        resolve: (handler, context) => {
          for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
            handler = middleware(handler, context);
          }
          if (identifyOnResolve) {
            console.log(stack.identify());
          }
          return handler;
        }
      };
      return stack;
    };
    stepWeights = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    };
    priorityWeights = {
      high: 3,
      normal: 2,
      low: 1
    };
  }
});

// ../node_modules/@smithy/middleware-stack/dist-es/index.js
var init_dist_es7 = __esm({
  "../node_modules/@smithy/middleware-stack/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_MiddlewareStack();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/client.js
var Client;
var init_client2 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/client.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es7();
    Client = class {
      constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
      }
      send(command, optionsOrCb, cb2) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
          handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
          });
        } else {
          return handler(command).then((result) => result.output);
        }
      }
      destroy() {
        if (this.config.requestHandler.destroy)
          this.config.requestHandler.destroy();
      }
    };
  }
});

// ../node_modules/@smithy/util-base64/dist-es/constants.browser.js
var alphabetByEncoding, alphabetByValue, bitsPerLetter, bitsPerByte, maxLetterValue;
var init_constants_browser = __esm({
  "../node_modules/@smithy/util-base64/dist-es/constants.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    alphabetByEncoding = {};
    alphabetByValue = new Array(64);
    for (let i2 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i2 + start <= limit; i2++) {
      const char = String.fromCharCode(i2 + start);
      alphabetByEncoding[char] = i2;
      alphabetByValue[i2] = char;
    }
    for (let i2 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i2 + start <= limit; i2++) {
      const char = String.fromCharCode(i2 + start);
      const index = i2 + 26;
      alphabetByEncoding[char] = index;
      alphabetByValue[index] = char;
    }
    for (let i2 = 0; i2 < 10; i2++) {
      alphabetByEncoding[i2.toString(10)] = i2 + 52;
      const char = i2.toString(10);
      const index = i2 + 52;
      alphabetByEncoding[char] = index;
      alphabetByValue[index] = char;
    }
    alphabetByEncoding["+"] = 62;
    alphabetByValue[62] = "+";
    alphabetByEncoding["/"] = 63;
    alphabetByValue[63] = "/";
    bitsPerLetter = 6;
    bitsPerByte = 8;
    maxLetterValue = 63;
  }
});

// ../node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
var fromBase64;
var init_fromBase64_browser = __esm({
  "../node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants_browser();
    fromBase64 = (input) => {
      let totalByteLength = input.length / 4 * 3;
      if (input.slice(-2) === "==") {
        totalByteLength -= 2;
      } else if (input.slice(-1) === "=") {
        totalByteLength--;
      }
      const out = new ArrayBuffer(totalByteLength);
      const dataView = new DataView(out);
      for (let i2 = 0; i2 < input.length; i2 += 4) {
        let bits = 0;
        let bitLength = 0;
        for (let j2 = i2, limit = i2 + 3; j2 <= limit; j2++) {
          if (input[j2] !== "=") {
            if (!(input[j2] in alphabetByEncoding)) {
              throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
            }
            bits |= alphabetByEncoding[input[j2]] << (limit - j2) * bitsPerLetter;
            bitLength += bitsPerLetter;
          } else {
            bits >>= bitsPerLetter;
          }
        }
        const chunkOffset = i2 / 4 * 3;
        bits >>= bitLength % bitsPerByte;
        const byteLength2 = Math.floor(bitLength / bitsPerByte);
        for (let k2 = 0; k2 < byteLength2; k2++) {
          const offset = (byteLength2 - k2 - 1) * bitsPerByte;
          dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
        }
      }
      return new Uint8Array(out);
    };
  }
});

// ../node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf8;
var init_fromUtf8_browser = __esm({
  "../node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    fromUtf8 = (input) => new TextEncoder().encode(input);
  }
});

// ../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array2;
var init_toUint8Array = __esm({
  "../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_fromUtf8_browser();
    toUint8Array2 = (data) => {
      if (typeof data === "string") {
        return fromUtf8(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    };
  }
});

// ../node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
var toUtf8;
var init_toUtf8_browser = __esm({
  "../node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    toUtf8 = (input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return new TextDecoder("utf-8").decode(input);
    };
  }
});

// ../node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es8 = __esm({
  "../node_modules/@smithy/util-utf8/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_fromUtf8_browser();
    init_toUint8Array();
    init_toUtf8_browser();
  }
});

// ../node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
function toBase64(_input) {
  let input;
  if (typeof _input === "string") {
    input = fromUtf8(_input);
  } else {
    input = _input;
  }
  const isArrayLike = typeof input === "object" && typeof input.length === "number";
  const isUint8Array2 = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
  if (!isArrayLike && !isUint8Array2) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i2 = 0; i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = Math.min(i2 + 3, input.length); j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
var init_toBase64_browser = __esm({
  "../node_modules/@smithy/util-base64/dist-es/toBase64.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es8();
    init_constants_browser();
  }
});

// ../node_modules/@smithy/util-base64/dist-es/index.js
var init_dist_es9 = __esm({
  "../node_modules/@smithy/util-base64/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_fromBase64_browser();
    init_toBase64_browser();
  }
});

// ../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf8(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}
var init_transforms = __esm({
  "../node_modules/@smithy/util-stream/dist-es/blob/transforms.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es9();
    init_dist_es8();
    init_Uint8ArrayBlobAdapter();
  }
});

// ../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter;
var init_Uint8ArrayBlobAdapter = __esm({
  "../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_transforms();
    Uint8ArrayBlobAdapter = class extends Uint8Array {
      static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
          case "string":
            return transformFromString(source, encoding);
          default:
            throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
      }
      static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
      }
      transformToString(encoding = "utf-8") {
        return transformToString(this, encoding);
      }
    };
  }
});

// ../node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
var getAwsChunkedEncodingStream;
var init_getAwsChunkedEncodingStream_browser = __esm({
  "../node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getAwsChunkedEncodingStream = (readableStream, options) => {
      const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
      const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
      const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
      const reader = readableStream.getReader();
      return new ReadableStream({
        async pull(controller) {
          const { value, done } = await reader.read();
          if (done) {
            controller.enqueue(`0\r
`);
            if (checksumRequired) {
              const checksum = base64Encoder(await digest);
              controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
              controller.enqueue(`\r
`);
            }
            controller.close();
          } else {
            controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
          }
        }
      });
    };
  }
});

// ../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri, hexEncode;
var init_escape_uri = __esm({
  "../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;
  }
});

// ../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = __esm({
  "../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_escape_uri();
  }
});

// ../node_modules/@smithy/util-uri-escape/dist-es/index.js
var init_dist_es10 = __esm({
  "../node_modules/@smithy/util-uri-escape/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_escape_uri();
    init_escape_uri_path();
  }
});

// ../node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i2 = 0, iLen = value.length; i2 < iLen; i2++) {
        parts.push(`${key}=${escapeUri(value[i2])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
var init_dist_es11 = __esm({
  "../node_modules/@smithy/querystring-builder/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es10();
  }
});

// ../node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}
var init_request_timeout = __esm({
  "../node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport, FetchHttpHandler;
var init_fetch_http_handler = __esm({
  "../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es11();
    init_request_timeout();
    keepAliveSupport = {
      supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
    };
    FetchHttpHandler = class {
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
      }
      constructor(options) {
        if (typeof options === "function") {
          this.configProvider = options().then((opts) => opts || {});
        } else {
          this.config = options ?? {};
          this.configProvider = Promise.resolve(this.config);
        }
      }
      destroy() {
      }
      async handle(request, { abortSignal } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
        const requestOptions = {
          body,
          headers: new Headers(request.headers),
          method
        };
        if (body) {
          requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
          requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
          requestOptions.keepalive = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
          fetch(fetchRequest).then((response) => {
            const fetchHeaders = response.headers;
            const transformedHeaders = {};
            for (const pair of fetchHeaders.entries()) {
              transformedHeaders[pair[0]] = pair[1];
            }
            const hasReadableStream = response.body != void 0;
            if (!hasReadableStream) {
              return response.blob().then((body2) => ({
                response: new HttpResponse({
                  headers: transformedHeaders,
                  reason: response.statusText,
                  statusCode: response.status,
                  body: body2
                })
              }));
            }
            return {
              response: new HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: response.body
              })
            };
          }),
          requestTimeout(requestTimeoutInMs)
        ];
        if (abortSignal) {
          raceOfPromises.push(new Promise((resolve, reject) => {
            abortSignal.onabort = () => {
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            };
          }));
        }
        return Promise.race(raceOfPromises);
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          config[key] = value;
          return config;
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
  }
});

// ../node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}
var streamCollector;
var init_stream_collector = __esm({
  "../node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es9();
    streamCollector = (stream) => {
      if (typeof Blob === "function" && stream instanceof Blob) {
        return collectBlob(stream);
      }
      return collectStream(stream);
    };
  }
});

// ../node_modules/@smithy/fetch-http-handler/dist-es/index.js
var init_dist_es12 = __esm({
  "../node_modules/@smithy/fetch-http-handler/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_fetch_http_handler();
    init_stream_collector();
  }
});

// ../node_modules/@smithy/util-hex-encoding/dist-es/index.js
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i2 = 0; i2 < encoded.length; i2 += 2) {
    const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i2 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    out += SHORT_TO_HEX[bytes[i2]];
  }
  return out;
}
var SHORT_TO_HEX, HEX_TO_SHORT;
var init_dist_es13 = __esm({
  "../node_modules/@smithy/util-hex-encoding/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    SHORT_TO_HEX = {};
    HEX_TO_SHORT = {};
    for (let i2 = 0; i2 < 256; i2++) {
      let encodedByte = i2.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i2] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i2;
    }
  }
});

// ../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED, sdkStreamMixin, isBlobInstance, isReadableStreamInstance;
var init_sdk_stream_mixin_browser = __esm({
  "../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es12();
    init_dist_es9();
    init_dist_es13();
    init_dist_es8();
    ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    sdkStreamMixin = (stream) => {
      if (!isBlobInstance(stream) && !isReadableStreamInstance(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
      };
      const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
          throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
      };
      return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
          const buf = await transformToByteArray();
          if (encoding === "base64") {
            return toBase64(buf);
          } else if (encoding === "hex") {
            return toHex(buf);
          } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
            return toUtf8(buf);
          } else if (typeof TextDecoder === "function") {
            return new TextDecoder(encoding).decode(buf);
          } else {
            throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          transformed = true;
          if (isBlobInstance(stream)) {
            return blobToWebStream(stream);
          } else if (isReadableStreamInstance(stream)) {
            return stream;
          } else {
            throw new Error(`Cannot transform payload to web stream, got ${stream}`);
          }
        }
      });
    };
    isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
    isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
  }
});

// ../node_modules/@smithy/util-stream/dist-es/index.js
var init_dist_es14 = __esm({
  "../node_modules/@smithy/util-stream/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_Uint8ArrayBlobAdapter();
    init_getAwsChunkedEncodingStream_browser();
    init_sdk_stream_mixin_browser();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var collectBody;
var init_collect_stream_body = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es14();
    collectBody = async (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
      }
      if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
      }
      const fromContext = context.streamCollector(streamBody);
      return Uint8ArrayBlobAdapter.mutate(await fromContext);
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/command.js
var Command, ClassBuilder;
var init_command2 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/command.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es7();
    init_dist_es();
    Command = class {
      constructor() {
        this.middlewareStack = constructStack();
      }
      static classBuilder() {
        return new ClassBuilder();
      }
      resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
          this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger2 } = configuration;
        const handlerExecutionContext = {
          logger: logger2,
          clientName,
          commandName,
          inputFilterSensitiveLog,
          outputFilterSensitiveLog,
          [SMITHY_CONTEXT_KEY]: {
            ...smithyContext
          },
          ...additionalContext
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
      }
    };
    ClassBuilder = class {
      constructor() {
        this._init = () => {
        };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
      }
      init(cb2) {
        this._init = cb2;
      }
      ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
      }
      m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
      }
      s(service, operation, smithyContext = {}) {
        this._smithyContext = {
          service,
          operation,
          ...smithyContext
        };
        return this;
      }
      c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
      }
      n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
      }
      f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
      }
      ser(serializer) {
        this._serializer = serializer;
        return this;
      }
      de(deserializer) {
        this._deserializer = deserializer;
        return this;
      }
      build() {
        const closure = this;
        let CommandRef;
        return CommandRef = class extends Command {
          static getEndpointParameterInstructions() {
            return closure._ep;
          }
          constructor(...[input]) {
            super();
            this.serialize = closure._serializer;
            this.deserialize = closure._deserializer;
            this.input = input ?? {};
            closure._init(this);
          }
          resolveMiddleware(stack, configuration, options) {
            return this.resolveMiddlewareWithContext(stack, configuration, options, {
              CommandCtor: CommandRef,
              middlewareFn: closure._middlewareFn,
              clientName: closure._clientName,
              commandName: closure._commandName,
              inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
              outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
              smithyContext: closure._smithyContext,
              additionalContext: closure._additionalContext
            });
          }
        };
      }
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING;
var init_constants = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    SENSITIVE_STRING = "***SensitiveInformation***";
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var createAggregatedClient;
var init_create_aggregated_client = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    createAggregatedClient = (commands2, Client2) => {
      for (const command of Object.keys(commands2)) {
        const CommandCtor = commands2[command];
        const methodImpl = async function(args, optionsOrCb, cb2) {
          const command2 = new CommandCtor(args);
          if (typeof optionsOrCb === "function") {
            this.send(command2, optionsOrCb);
          } else if (typeof cb2 === "function") {
            if (typeof optionsOrCb !== "object")
              throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
            this.send(command2, optionsOrCb || {}, cb2);
          } else {
            return this.send(command2, optionsOrCb);
          }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client2.prototype[methodName] = methodImpl;
      }
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var parseBoolean, expectNumber, MAX_FLOAT, expectFloat32, expectLong, expectInt32, expectShort, expectByte, expectSizedInt, castInt, expectNonNull, expectObject, expectString, expectUnion, strictParseFloat32, NUMBER_REGEX, parseNumber, strictParseLong, strictParseInt32, strictParseShort, strictParseByte, stackTraceWarning, logger;
var init_parse_utils = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/parse-utils.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    parseBoolean = (value) => {
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(`Unable to parse boolean value "${value}"`);
      }
    };
    expectNumber = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          if (String(parsed) !== String(value)) {
            logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
          }
          return parsed;
        }
      }
      if (typeof value === "number") {
        return value;
      }
      throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    expectFloat32 = (value) => {
      const expected = expectNumber(value);
      if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
          throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
      }
      return expected;
    };
    expectLong = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
      }
      throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    expectInt32 = (value) => expectSizedInt(value, 32);
    expectShort = (value) => expectSizedInt(value, 16);
    expectByte = (value) => expectSizedInt(value, 8);
    expectSizedInt = (value, size) => {
      const expected = expectLong(value);
      if (expected !== void 0 && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
      }
      return expected;
    };
    castInt = (value, size) => {
      switch (size) {
        case 32:
          return Int32Array.of(value)[0];
        case 16:
          return Int16Array.of(value)[0];
        case 8:
          return Int8Array.of(value)[0];
      }
    };
    expectNonNull = (value, location) => {
      if (value === null || value === void 0) {
        if (location) {
          throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
      }
      return value;
    };
    expectObject = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value;
      }
      const receivedType = Array.isArray(value) ? "array" : typeof value;
      throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    expectString = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        return value;
      }
      if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
      }
      throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    expectUnion = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      const asObject = expectObject(value);
      const setKeys = Object.entries(asObject).filter(([, v2]) => v2 != null).map(([k2]) => k2);
      if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
      }
      if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
      }
      return asObject;
    };
    strictParseFloat32 = (value) => {
      if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
      }
      return expectFloat32(value);
    };
    NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    parseNumber = (value) => {
      const matches = value.match(NUMBER_REGEX);
      if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
      }
      return parseFloat(value);
    };
    strictParseLong = (value) => {
      if (typeof value === "string") {
        return expectLong(parseNumber(value));
      }
      return expectLong(value);
    };
    strictParseInt32 = (value) => {
      if (typeof value === "string") {
        return expectInt32(parseNumber(value));
      }
      return expectInt32(value);
    };
    strictParseShort = (value) => {
      if (typeof value === "string") {
        return expectShort(parseNumber(value));
      }
      return expectShort(value);
    };
    strictParseByte = (value) => {
      if (typeof value === "string") {
        return expectByte(parseNumber(value));
      }
      return expectByte(value);
    };
    stackTraceWarning = (message) => {
      return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join("\n");
    };
    logger = {
      warn: console.warn
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/date-utils.js
function dateToUtcString(date) {
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const dayOfWeek = date.getUTCDay();
  const dayOfMonthInt = date.getUTCDate();
  const hoursInt = date.getUTCHours();
  const minutesInt = date.getUTCMinutes();
  const secondsInt = date.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var DAYS, MONTHS, RFC3339, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, parseRfc7231DateTime, buildDate, parseTwoDigitYear, FIFTY_YEARS_IN_MILLIS, adjustRfc850Year, parseMonthByShortName, DAYS_IN_MONTH, validateDayOfMonth, isLeapYear, parseDateValue, parseMilliseconds, parseOffsetToMilliseconds, stripLeadingZeroes;
var init_date_utils = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/date-utils.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_parse_utils();
    DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    parseRfc3339DateTimeWithOffset = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match2 = RFC3339_WITH_OFFSET.exec(value);
      if (!match2) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match2;
      const year = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
      if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
      }
      return date;
    };
    IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
    parseRfc7231DateTime = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      }
      let match2 = IMF_FIXDATE.exec(value);
      if (match2) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match2;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      match2 = RFC_850_DATE.exec(value);
      if (match2) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match2;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
          hours,
          minutes,
          seconds,
          fractionalMilliseconds
        }));
      }
      match2 = ASC_TIME.exec(value);
      if (match2) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match2;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    };
    buildDate = (year, month, day, time) => {
      const adjustedMonth = month - 1;
      validateDayOfMonth(year, adjustedMonth, day);
      return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
    };
    parseTwoDigitYear = (value) => {
      const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
      const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
      if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
      }
      return valueInThisCentury;
    };
    FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
    adjustRfc850Year = (input) => {
      if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
      }
      return input;
    };
    parseMonthByShortName = (value) => {
      const monthIdx = MONTHS.indexOf(value);
      if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
      }
      return monthIdx + 1;
    };
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    validateDayOfMonth = (year, month, day) => {
      let maxDays = DAYS_IN_MONTH[month];
      if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
      }
      if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
      }
    };
    isLeapYear = (year) => {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };
    parseDateValue = (value, type, lower, upper) => {
      const dateVal = strictParseByte(stripLeadingZeroes(value));
      if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
      }
      return dateVal;
    };
    parseMilliseconds = (value) => {
      if (value === null || value === void 0) {
        return 0;
      }
      return strictParseFloat32("0." + value) * 1e3;
    };
    parseOffsetToMilliseconds = (value) => {
      const directionStr = value[0];
      let direction = 1;
      if (directionStr == "+") {
        direction = 1;
      } else if (directionStr == "-") {
        direction = -1;
      } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
      }
      const hour = Number(value.substring(1, 3));
      const minute = Number(value.substring(4, 6));
      return direction * (hour * 60 + minute) * 60 * 1e3;
    };
    stripLeadingZeroes = (value) => {
      let idx = 0;
      while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
      }
      if (idx === 0) {
        return value;
      }
      return value.slice(idx);
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException, decorateServiceException;
var init_exceptions = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/exceptions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    ServiceException = class extends Error {
      constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
      }
    };
    decorateServiceException = (exception, additions = {}) => {
      Object.entries(additions).filter(([, v2]) => v2 !== void 0).forEach(([k2, v2]) => {
        if (exception[k2] == void 0 || exception[k2] === "") {
          exception[k2] = v2;
        }
      });
      const message = exception.message || exception.Message || "UnknownError";
      exception.message = message;
      delete exception.Message;
      return exception;
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError, withBaseException, deserializeMetadata;
var init_default_error_handler = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_exceptions();
    throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
      const $metadata = deserializeMetadata(output);
      const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
      const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
      });
      throw decorateServiceException(response, parsedBody);
    };
    withBaseException = (ExceptionCtor) => {
      return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
      };
    };
    deserializeMetadata = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode;
var init_defaults_mode = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    loadConfigsForDefaultMode = (mode) => {
      switch (mode) {
        case "standard":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard",
            connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard",
            connectionTimeout: 3e4
          };
        default:
          return {};
      }
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var init_emitWarningIfUnsupportedVersion = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
var getChecksumConfiguration2, resolveChecksumRuntimeConfig2;
var init_checksum3 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
    getChecksumConfiguration2 = (runtimeConfig) => {
      const checksumAlgorithms = [];
      for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === void 0) {
          continue;
        }
        checksumAlgorithms.push({
          algorithmId: () => algorithmId,
          checksumConstructor: () => runtimeConfig[algorithmId]
        });
      }
      return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
          this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms;
        }
      };
    };
    resolveChecksumRuntimeConfig2 = (clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
var getRetryConfiguration, resolveRetryRuntimeConfig;
var init_retry2 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getRetryConfiguration = (runtimeConfig) => {
      let _retryStrategy = runtimeConfig.retryStrategy;
      return {
        setRetryStrategy(retryStrategy) {
          _retryStrategy = retryStrategy;
        },
        retryStrategy() {
          return _retryStrategy;
        }
      };
    };
    resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
      const runtimeConfig = {};
      runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
      return runtimeConfig;
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration, resolveDefaultRuntimeConfig;
var init_defaultExtensionConfiguration2 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_checksum3();
    init_retry2();
    getDefaultExtensionConfiguration = (runtimeConfig) => {
      return {
        ...getChecksumConfiguration2(runtimeConfig),
        ...getRetryConfiguration(runtimeConfig)
      };
    };
    resolveDefaultRuntimeConfig = (config) => {
      return {
        ...resolveChecksumRuntimeConfig2(config),
        ...resolveRetryRuntimeConfig(config)
      };
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/extensions/index.js
var init_extensions3 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/extensions/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_defaultExtensionConfiguration2();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
var init_extended_encode_uri_component = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
var getArrayIfSingleItem;
var init_get_array_if_single_item = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode;
var init_get_value_from_text_node = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getValueFromTextNode = (obj) => {
      const textNodeName = "#text";
      for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
          obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          obj[key] = getValueFromTextNode(obj[key]);
        }
      }
      return obj;
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var StringWrapper;
var init_lazy_json = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/lazy-json.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    StringWrapper = function() {
      const Class = Object.getPrototypeOf(this).constructor;
      const Constructor = Function.bind.apply(String, [null, ...arguments]);
      const instance = new Constructor();
      Object.setPrototypeOf(instance, Class.prototype);
      return instance;
    };
    StringWrapper.prototype = Object.create(String.prototype, {
      constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    Object.setPrototypeOf(StringWrapper, String);
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var mapWithFilter, applyInstruction, nonNullish, pass;
var init_object_mapping = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/object-mapping.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    mapWithFilter = (target, filter, instructions) => {
      return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
          _instructions[key] = value;
        } else {
          if (typeof value === "function") {
            _instructions[key] = [filter, value()];
          } else {
            _instructions[key] = [filter, value];
          }
        }
        return _instructions;
      }, {}));
    };
    applyInstruction = (target, source, instructions, targetKey) => {
      if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
          instruction = [, instruction];
        }
        const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
          target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
      }
      let [filter, value] = instructions[targetKey];
      if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
        const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed) {
          target[targetKey] = _value;
        } else if (customFilterPassed) {
          target[targetKey] = value();
        }
      } else {
        const defaultFilterPassed = filter === void 0 && value != null;
        const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed || customFilterPassed) {
          target[targetKey] = value;
        }
      }
    };
    nonNullish = (_) => _ != null;
    pass = (_) => _;
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/resolve-path.js
var resolvedPath;
var init_resolve_path = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/resolve-path.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_extended_encode_uri_component();
    resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
      if (input != null && input[memberName] !== void 0) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
          throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
      } else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
      }
      return resolvedPath2;
    };
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/ser-utils.js
var init_ser_utils = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/ser-utils.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/serde-json.js
var init_serde_json = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/serde-json.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/split-every.js
var init_split_every = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/split-every.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/smithy-client/dist-es/index.js
var init_dist_es15 = __esm({
  "../node_modules/@smithy/smithy-client/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_NoOpLogger();
    init_client2();
    init_collect_stream_body();
    init_command2();
    init_constants();
    init_create_aggregated_client();
    init_date_utils();
    init_default_error_handler();
    init_defaults_mode();
    init_emitWarningIfUnsupportedVersion();
    init_extensions3();
    init_exceptions();
    init_extended_encode_uri_component();
    init_get_array_if_single_item();
    init_get_value_from_text_node();
    init_lazy_json();
    init_object_mapping();
    init_parse_utils();
    init_resolve_path();
    init_ser_utils();
    init_serde_json();
    init_split_every();
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
      if (!(CONTENT_LENGTH_HEADER in request.headers)) {
        const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof context?.logger?.warn === "function" && !(context.logger instanceof NoOpLogger)) {
          context.logger.warn(message);
        } else {
          console.warn(message);
        }
      }
    }
    return next({ ...args });
  };
}
var CONTENT_LENGTH_HEADER, checkContentLengthHeaderMiddlewareOptions, getCheckContentLengthHeaderPlugin;
var init_check_content_length_header = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es15();
    CONTENT_LENGTH_HEADER = "content-length";
    checkContentLengthHeaderMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["CHECK_CONTENT_LENGTH_HEADER"],
      name: "getCheckContentLengthHeaderPlugin",
      override: true
    };
    getCheckContentLengthHeaderPlugin = (unused) => ({
      applyToStack: (clientStack) => {
        clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
var regionRedirectEndpointMiddleware, regionRedirectEndpointMiddlewareOptions;
var init_region_redirect_endpoint_middleware = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    regionRedirectEndpointMiddleware = (config) => {
      return (next, context) => async (args) => {
        const originalRegion = await config.region();
        const regionProviderRef = config.region;
        if (context.__s3RegionRedirect) {
          config.region = async () => {
            config.region = regionProviderRef;
            return context.__s3RegionRedirect;
          };
        }
        const result = await next(args);
        if (context.__s3RegionRedirect) {
          const region = await config.region();
          if (originalRegion !== region) {
            throw new Error("Region was not restored following S3 region redirect.");
          }
        }
        return result;
      };
    };
    regionRedirectEndpointMiddlewareOptions = {
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectEndpointMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err) {
      if (clientConfig.followRegionRedirects && err?.$metadata?.httpStatusCode === 301) {
        try {
          const actualRegion = err.$response.headers["x-amz-bucket-region"];
          context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
          context.__s3RegionRedirect = actualRegion;
        } catch (e2) {
          throw new Error("Region redirect failed: " + e2);
        }
        return next(args);
      } else {
        throw err;
      }
    }
  };
}
var regionRedirectMiddlewareOptions, getRegionRedirectMiddlewarePlugin;
var init_region_redirect_middleware = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_region_redirect_endpoint_middleware();
    regionRedirectMiddlewareOptions = {
      step: "initialize",
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectMiddleware",
      override: true
    };
    getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
        clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
var s3ExpiresMiddleware, s3ExpiresMiddlewareOptions, getS3ExpiresMiddlewarePlugin;
var init_s3_expires_middleware = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es15();
    s3ExpiresMiddleware = (config) => {
      return (next, context) => async (args) => {
        const result = await next(args);
        const { response } = result;
        if (HttpResponse.isInstance(response)) {
          if (response.headers.expires) {
            response.headers.expiresstring = response.headers.expires;
            try {
              parseRfc7231DateTime(response.headers.expires);
            } catch (e2) {
              context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response.headers.expires}): ${e2}`);
              delete response.headers.expires;
            }
          }
        }
        return result;
      };
    };
    s3ExpiresMiddlewareOptions = {
      tags: ["S3"],
      name: "s3ExpiresMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "deserializerMiddleware"
    };
    getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpiresMiddleware(clientConfig), s3ExpiresMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
var S3ExpressIdentityCache;
var init_S3ExpressIdentityCache = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    S3ExpressIdentityCache = class {
      constructor(data = {}) {
        this.data = data;
        this.lastPurgeTime = Date.now();
      }
      get(key) {
        const entry = this.data[key];
        if (!entry) {
          return;
        }
        return entry;
      }
      set(key, entry) {
        this.data[key] = entry;
        return entry;
      }
      delete(key) {
        delete this.data[key];
      }
      async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
          return;
        }
        for (const key in this.data) {
          const entry = this.data[key];
          if (!entry.isRefreshing) {
            const credential = await entry.identity;
            if (credential.expiration) {
              if (credential.expiration.getTime() < now) {
                delete this.data[key];
              }
            }
          }
        }
      }
    };
    S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
var S3ExpressIdentityCacheEntry;
var init_S3ExpressIdentityCacheEntry = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    S3ExpressIdentityCacheEntry = class {
      constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
      }
      get identity() {
        this.accessed = Date.now();
        return this._identity;
      }
    };
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
var S3ExpressIdentityProviderImpl;
var init_S3ExpressIdentityProviderImpl = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_S3ExpressIdentityCache();
    init_S3ExpressIdentityCacheEntry();
    S3ExpressIdentityProviderImpl = class {
      constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache;
      }
      async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache } = this;
        const entry = cache.get(key);
        if (entry) {
          return entry.identity.then((identity) => {
            const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
            if (isExpired) {
              return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
            }
            const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
            if (isExpiringSoon && !entry.isRefreshing) {
              entry.isRefreshing = true;
              this.getIdentity(key).then((id) => {
                cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
              });
            }
            return identity;
          });
        }
        return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
      }
      async getIdentity(key) {
        await this.cache.purgeExpired().catch((error) => {
          console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
        });
        const session = await this.createSessionFn(key);
        if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
          throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity = {
          accessKeyId: session.Credentials.AccessKeyId,
          secretAccessKey: session.Credentials.SecretAccessKey,
          sessionToken: session.Credentials.SessionToken,
          expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
        };
        return identity;
      }
    };
    S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;
  }
});

// ../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
var getSmithyContext;
var init_getSmithyContext = __esm({
  "../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
    getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});
  }
});

// ../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// ../node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es16 = __esm({
  "../node_modules/@smithy/util-middleware/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getSmithyContext();
    init_normalizeProvider();
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM, CREDENTIAL_QUERY_PARAM, AMZ_DATE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, EXPIRES_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER, GENERATED_HEADERS, SIGNATURE_HEADER, SHA256_HEADER, TOKEN_HEADER, ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN, ALGORITHM_IDENTIFIER, EVENT_ALGORITHM_IDENTIFIER, UNSIGNED_PAYLOAD, MAX_CACHE_SIZE, KEY_TYPE_IDENTIFIER, MAX_PRESIGNED_TTL;
var init_constants2 = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    AUTH_HEADER = "authorization";
    AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    DATE_HEADER = "date";
    GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    SHA256_HEADER = "x-amz-content-sha256";
    TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    PROXY_HEADER_PATTERN = /^proxy-/;
    SEC_HEADER_PATTERN = /^sec-/;
    ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    MAX_CACHE_SIZE = 50;
    KEY_TYPE_IDENTIFIER = "aws4_request";
    MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache, cacheQueue, createScope, getSigningKey, hmac;
var init_credentialDerivation = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es13();
    init_dist_es8();
    init_constants2();
    signingKeyCache = {};
    cacheQueue = [];
    createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
    getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    };
    hmac = (ctor, secret, data) => {
      const hash = new ctor(secret);
      hash.update(toUint8Array2(data));
      return hash.digest();
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders;
var init_getCanonicalHeaders = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants2();
    getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery;
var init_getCanonicalQuery = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es10();
    init_constants2();
    getCanonicalQuery = ({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
          serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[key] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).sort().join("&");
        }
      }
      return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    };
  }
});

// ../node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer;
var init_dist_es17 = __esm({
  "../node_modules/@smithy/is-array-buffer/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash;
var init_getPayloadHash = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es17();
    init_dist_es13();
    init_dist_es8();
    init_constants2();
    getPayloadHash = async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array2(body));
        return toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
function negate(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}
var HeaderFormatter, HEADER_VALUE_TYPE, UUID_PATTERN, Int64;
var init_HeaderFormatter = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es13();
    init_dist_es8();
    HeaderFormatter = class {
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
    };
    (function(HEADER_VALUE_TYPE3) {
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
    UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    Int64 = class {
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
          bytes[i2] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var hasHeader;
var init_headerUtil = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/headerUtil.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    hasHeader = (soughtHeader, headers) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
var cloneRequest, cloneQuery2;
var init_cloneRequest = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    cloneRequest = ({ headers, query, ...rest }) => ({
      ...rest,
      headers: { ...headers },
      query: query ? cloneQuery2(query) : void 0
    });
    cloneQuery2 = (query) => Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery;
var init_moveHeadersToQuery = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_cloneRequest();
    moveHeadersToQuery = (request, options = {}) => {
      const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
      for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
          query[name] = headers[name];
          delete headers[name];
        }
      }
      return {
        ...request,
        headers,
        query
      };
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
var prepareRequest;
var init_prepareRequest = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_cloneRequest();
    init_constants2();
    prepareRequest = (request) => {
      request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
      for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request.headers[headerName];
        }
      }
      return request;
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/utilDate.js
var iso8601, toDate;
var init_utilDate = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/utilDate.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
    toDate = (time) => {
      if (typeof time === "number") {
        return new Date(time * 1e3);
      }
      if (typeof time === "string") {
        if (Number(time)) {
          return new Date(Number(time) * 1e3);
        }
        return new Date(time);
      }
      return time;
    };
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV4, formatDate, getCanonicalHeaderList;
var init_SignatureV4 = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es13();
    init_dist_es16();
    init_dist_es10();
    init_dist_es8();
    init_constants2();
    init_credentialDerivation();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_HeaderFormatter();
    init_headerUtil();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_utilDate();
    SignatureV4 = class {
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.headerFormatter = new HeaderFormatter();
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
      }
      async presign(originalRequest, options = {}) {
        const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
          request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else if (toSign.message) {
          return this.signMessage(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = toHex(await hash.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
          headers: this.headerFormatter.format(signableMessage.message.headers),
          payload: signableMessage.message.body
        }, {
          signingDate,
          signingRegion,
          signingService,
          priorSignature: signableMessage.priorSignature
        });
        return promise.then((signature) => {
          return { message: signableMessage.message, signature };
        });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(toUint8Array2(stringToSign));
        return toHex(await hash.digest());
      }
      async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
          request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request;
      }
      createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(toUint8Array2(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
      }
      getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = escapeUri(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(toUint8Array2(stringToSign));
        return toHex(await hash.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
    };
    formatDate = (now) => {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    };
    getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
  }
});

// ../node_modules/@smithy/signature-v4/dist-es/index.js
var init_dist_es18 = __esm({
  "../node_modules/@smithy/signature-v4/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_SignatureV4();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_credentialDerivation();
  }
});

// ../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var init_booleanSelector = __esm({
  "../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-config-provider/dist-es/numberSelector.js
var init_numberSelector = __esm({
  "../node_modules/@smithy/util-config-provider/dist-es/numberSelector.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-config-provider/dist-es/types.js
var SelectorType;
var init_types2 = __esm({
  "../node_modules/@smithy/util-config-provider/dist-es/types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(SelectorType2) {
      SelectorType2["ENV"] = "env";
      SelectorType2["CONFIG"] = "shared config entry";
    })(SelectorType || (SelectorType = {}));
  }
});

// ../node_modules/@smithy/util-config-provider/dist-es/index.js
var init_dist_es19 = __esm({
  "../node_modules/@smithy/util-config-provider/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_booleanSelector();
    init_numberSelector();
    init_types2();
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var S3_EXPRESS_BUCKET_TYPE, S3_EXPRESS_BACKEND, S3_EXPRESS_AUTH_SCHEME, SESSION_TOKEN_QUERY_PARAM, SESSION_TOKEN_HEADER;
var init_constants3 = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es19();
    S3_EXPRESS_BUCKET_TYPE = "Directory";
    S3_EXPRESS_BACKEND = "S3Express";
    S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
    SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
    SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}
var SignatureV4S3Express;
var init_SignatureV4S3Express = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es18();
    init_constants3();
    SignatureV4S3Express = class extends SignatureV4 {
      async signWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return privateAccess.signRequest(requestToSign, options ?? {});
      }
      async presignWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        delete requestToSign.headers[SESSION_TOKEN_HEADER];
        requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        requestToSign.query = requestToSign.query ?? {};
        requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return this.presign(requestToSign, options);
      }
    };
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
var s3ExpressMiddleware, s3ExpressMiddlewareOptions, getS3ExpressPlugin;
var init_s3ExpressMiddleware = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_constants3();
    s3ExpressMiddleware = (options) => {
      return (next, context) => async (args) => {
        if (context.endpointV2) {
          const endpoint = context.endpointV2;
          const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
          const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
          if (isS3ExpressBucket) {
            context.isS3ExpressBucket = true;
          }
          if (isS3ExpressAuth) {
            const requestBucket = args.input.Bucket;
            if (requestBucket) {
              const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
                Bucket: requestBucket
              });
              context.s3ExpressIdentity = s3ExpressIdentity;
              if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
                args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
              }
            }
          }
        }
        return next(args);
      };
    };
    s3ExpressMiddlewareOptions = {
      name: "s3ExpressMiddleware",
      step: "build",
      tags: ["S3", "S3_EXPRESS"],
      override: true
    };
    getS3ExpressPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
var init_s3_express = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_S3ExpressIdentityCache();
    init_S3ExpressIdentityCacheEntry();
    init_S3ExpressIdentityProviderImpl();
    init_SignatureV4S3Express();
    init_constants3();
    init_s3ExpressMiddleware();
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
var resolveS3Config;
var init_s3Configuration = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_s3_express();
    resolveS3Config = (input, { session }) => {
      const [s3ClientProvider, CreateSessionCommandCtor] = session;
      return {
        ...input,
        forcePathStyle: input.forcePathStyle ?? false,
        useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
        disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
        followRegionRedirects: input.followRegionRedirects ?? false,
        s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
          Bucket: key,
          SessionMode: "ReadWrite"
        }))),
        bucketEndpoint: input.bucketEndpoint ?? false
      };
    };
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
var throw200ExceptionsMiddleware, collectBody2, collectBodyString, throw200ExceptionsMiddlewareOptions, getThrow200ExceptionsPlugin;
var init_throw_200_exceptions = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    throw200ExceptionsMiddleware = (config) => (next) => async (args) => {
      const result = await next(args);
      const { response } = result;
      if (!HttpResponse.isInstance(response))
        return result;
      const { statusCode, body } = response;
      if (statusCode < 200 || statusCode >= 300)
        return result;
      const bodyBytes = await collectBody2(body, config);
      const bodyString = await collectBodyString(bodyBytes, config);
      if (bodyBytes.length === 0) {
        const err = new Error("S3 aborted request");
        err.name = "InternalError";
        throw err;
      }
      if (bodyString && bodyString.match("<Error>")) {
        response.statusCode = 400;
      }
      response.body = bodyBytes;
      return result;
    };
    collectBody2 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    collectBodyString = (streamBody, context) => collectBody2(streamBody, context).then((body) => context.utf8Encoder(body));
    throw200ExceptionsMiddlewareOptions = {
      relation: "after",
      toMiddleware: "deserializerMiddleware",
      tags: ["THROW_200_EXCEPTIONS", "S3"],
      name: "throw200ExceptionsMiddleware",
      override: true
    };
    getThrow200ExceptionsPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate;
var init_dist_es20 = __esm({
  "../node_modules/@aws-sdk/util-arn-parser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            endpoint.url = bucketEndpointUrl;
          } catch (e2) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e2;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions;
var init_bucket_endpoint_middleware = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    bucketEndpointMiddlewareOptions = {
      name: "bucketEndpointMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "endpointV2Middleware"
    };
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions, getValidateBucketNamePlugin;
var init_validate_bucket_name = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es20();
    init_bucket_endpoint_middleware();
    validateBucketNameMiddlewareOptions = {
      step: "initialize",
      tags: ["VALIDATE_BUCKET_NAME"],
      name: "validateBucketNameMiddleware",
      override: true
    };
    getValidateBucketNamePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
var init_dist_es21 = __esm({
  "../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_check_content_length_header();
    init_region_redirect_endpoint_middleware();
    init_region_redirect_middleware();
    init_s3_expires_middleware();
    init_s3_express();
    init_s3Configuration();
    init_throw_200_exceptions();
    init_validate_bucket_name();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/ProviderError.js
var init_ProviderError = __esm({
  "../node_modules/@smithy/property-provider/dist-es/ProviderError.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var init_CredentialsProviderError = __esm({
  "../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_ProviderError();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var init_TokenProviderError = __esm({
  "../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_ProviderError();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/chain.js
var init_chain = __esm({
  "../node_modules/@smithy/property-provider/dist-es/chain.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_ProviderError();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/fromStatic.js
var init_fromStatic = __esm({
  "../node_modules/@smithy/property-provider/dist-es/fromStatic.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/property-provider/dist-es/memoize.js
var memoize;
var init_memoize = __esm({
  "../node_modules/@smithy/property-provider/dist-es/memoize.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    memoize = (provider, isExpired, requiresRefresh) => {
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async () => {
        if (!pending) {
          pending = provider();
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        if (isConstant) {
          return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider();
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// ../node_modules/@smithy/property-provider/dist-es/index.js
var init_dist_es22 = __esm({
  "../node_modules/@smithy/property-provider/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_CredentialsProviderError();
    init_ProviderError();
    init_TokenProviderError();
    init_chain();
    init_fromStatic();
    init_memoize();
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
var CREDENTIAL_EXPIRE_WINDOW, resolveAwsAuthConfig, normalizeCredentialProvider;
var init_awsAuthConfiguration = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es22();
    init_dist_es18();
    init_dist_es16();
    CREDENTIAL_EXPIRE_WINDOW = 3e5;
    resolveAwsAuthConfig = (input) => {
      const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(Object.assign({}, input, {
        parentClientConfig: input
      }));
      const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
      let signer;
      if (input.signer) {
        signer = normalizeProvider(input.signer);
      } else if (input.regionInfoProvider) {
        signer = () => normalizeProvider(input.region)().then(async (region) => [
          await input.regionInfoProvider(region, {
            useFipsEndpoint: await input.useFipsEndpoint(),
            useDualstackEndpoint: await input.useDualstackEndpoint()
          }) || {},
          region
        ]).then(([regionInfo, region]) => {
          const { signingRegion, signingService } = regionInfo;
          input.signingRegion = input.signingRegion || signingRegion || region;
          input.signingName = input.signingName || signingService || input.serviceId;
          const params = {
            ...input,
            credentials: normalizedCreds,
            region: input.signingRegion,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = input.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        });
      } else {
        signer = async (authScheme) => {
          authScheme = Object.assign({}, {
            name: "sigv4",
            signingName: input.signingName || input.defaultSigningName,
            signingRegion: await normalizeProvider(input.region)(),
            properties: {}
          }, authScheme);
          const isSigv4a = authScheme?.name === "sigv4a";
          const signingRegion = authScheme.signingRegion;
          const signingService = authScheme.signingName;
          let regionForSigner;
          if (isSigv4a) {
            regionForSigner = input.signingRegion || signingRegion;
          } else {
            input.signingRegion = input.signingRegion || signingRegion;
            regionForSigner = input.signingRegion;
          }
          input.signingName = input.signingName || signingService || input.serviceId;
          const params = {
            ...input,
            credentials: normalizedCreds,
            region: regionForSigner,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = input.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        };
      }
      return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer
      };
    };
    normalizeCredentialProvider = (credentials) => {
      if (typeof credentials === "function") {
        return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== void 0);
      }
      return normalizeProvider(credentials);
    };
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getSkewCorrectedDate();
    isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_isClockSkewed();
    getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
      const clockTimeInMs = Date.parse(clockTime);
      if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
      }
      return currentSystemClockOffset;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
var awsAuthMiddleware, getDateHeader, awsAuthMiddlewareOptions, getAwsAuthPlugin;
var init_awsAuthMiddleware = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_getSkewCorrectedDate();
    init_getUpdatedSystemClockOffset();
    awsAuthMiddleware = (options) => (next, context) => async function(args) {
      if (!HttpRequest.isInstance(args.request))
        return next(args);
      let authScheme;
      let signer;
      const firstAuthScheme = context.endpointV2?.properties?.authSchemes?.[0];
      const secondAuthScheme = context.endpointV2?.properties?.authSchemes?.[1];
      const firstAuthSchemeIsSigv4a = firstAuthScheme?.name === "sigv4a";
      if (firstAuthSchemeIsSigv4a && secondAuthScheme) {
        signer = await options.signer(authScheme = firstAuthScheme);
        const uncheckedSigner = signer;
        const sigv4aAvailable = (() => {
          if (typeof uncheckedSigner?.getSigv4aSigner === "function") {
            if (uncheckedSigner?.signerOptions?.runtime !== "node") {
              return false;
            }
            try {
              uncheckedSigner.getSigv4aSigner();
              return true;
            } catch (e2) {
            }
          }
          return false;
        })();
        if (!sigv4aAvailable) {
          signer = await options.signer(authScheme = secondAuthScheme);
        }
      } else {
        signer = await options.signer(authScheme = firstAuthScheme);
      }
      let signedRequest;
      const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
      const signingOptions = {
        signingDate: getSkewCorrectedDate(options.systemClockOffset),
        signingRegion: multiRegionOverride || context["signing_region"],
        signingService: context["signing_service"]
      };
      if (context.s3ExpressIdentity) {
        const sigV4MultiRegion = signer;
        signedRequest = await sigV4MultiRegion.signWithCredentials(args.request, context.s3ExpressIdentity, signingOptions);
        if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
          throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
        }
      } else {
        signedRequest = await signer.sign(args.request, signingOptions);
      }
      const output = await next({
        ...args,
        request: signedRequest
      }).catch((error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
        }
        throw error;
      });
      const dateHeader = getDateHeader(output.response);
      if (dateHeader) {
        options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
      }
      return output;
    };
    getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
    awsAuthMiddlewareOptions = {
      name: "awsAuthMiddleware",
      tags: ["SIGNATURE", "AWSAUTH"],
      relation: "after",
      toMiddleware: "retryMiddleware",
      override: true
    };
    getAwsAuthPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-signing/dist-es/index.js
var init_dist_es23 = __esm({
  "../node_modules/@aws-sdk/middleware-signing/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_awsAuthConfiguration();
    init_awsAuthMiddleware();
  }
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}
var init_configurations = __esm({
  "../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX, isIpAddress;
var init_isIpAddress = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
    isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX, isValidHostLabel;
var init_isValidHostLabel = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    isValidHostLabel = (value, allowSubDomains = false) => {
      if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
      }
      const labels = value.split(".");
      for (const label of labels) {
        if (!isValidHostLabel(label)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
var customEndpointFunctions;
var init_customEndpointFunctions = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    customEndpointFunctions = {};
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
var debugId;
var init_debugId = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    debugId = "endpoints";
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}
var init_toDebugString = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/debug/index.js
var init_debug = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/debug/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_debugId();
    init_toDebugString();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
var EndpointError;
var init_EndpointError = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    EndpointError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EndpointError";
      }
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
var init_EndpointFunctions = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject2 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject2 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject2 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject2 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/shared.js
var init_shared2 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/shared.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/types/index.js
var init_types3 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/types/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EndpointError();
    init_EndpointFunctions();
    init_EndpointRuleObject2();
    init_ErrorRuleObject2();
    init_RuleSetObject2();
    init_TreeRuleObject2();
    init_shared2();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals;
var init_booleanEquals = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    booleanEquals = (value1, value2) => value1 === value2;
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList;
var init_getAttrPathList = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    getAttrPathList = (path) => {
      const parts = path.split(".");
      const pathList = [];
      for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
          if (part.indexOf("]") !== part.length - 1) {
            throw new EndpointError(`Path: '${path}' does not end with ']'`);
          }
          const arrayIndex = part.slice(squareBracketIndex + 1, -1);
          if (Number.isNaN(parseInt(arrayIndex))) {
            throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
          }
          if (squareBracketIndex !== 0) {
            pathList.push(part.slice(0, squareBracketIndex));
          }
          pathList.push(arrayIndex);
        } else {
          pathList.push(part);
        }
      }
      return pathList;
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr;
var init_getAttr = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_getAttrPathList();
    getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
      if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
      } else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
      }
      return acc[index];
    }, value);
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
var isSet;
var init_isSet = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    isSet = (value) => value != null;
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/not.js
var not;
var init_not = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/not.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    not = (value) => !value;
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS, parseURL;
var init_parseURL = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
    init_isIpAddress();
    DEFAULT_PORTS = {
      [EndpointURLScheme.HTTP]: 80,
      [EndpointURLScheme.HTTPS]: 443
    };
    parseURL = (value) => {
      const whatwgURL = (() => {
        try {
          if (value instanceof URL) {
            return value;
          }
          if (typeof value === "object" && "hostname" in value) {
            const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
            const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
            url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
            return url;
          }
          return new URL(value);
        } catch (error) {
          return null;
        }
      })();
      if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
      }
      const urlString = whatwgURL.href;
      const { host, hostname, pathname, protocol, search } = whatwgURL;
      if (search) {
        return null;
      }
      const scheme = protocol.slice(0, -1);
      if (!Object.values(EndpointURLScheme).includes(scheme)) {
        return null;
      }
      const isIp = isIpAddress(hostname);
      const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
      const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
      return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
      };
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals;
var init_stringEquals = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    stringEquals = (value1, value2) => value1 === value2;
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
var substring;
var init_substring = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    substring = (input, start, stop, reverse) => {
      if (start >= stop || input.length < stop) {
        return null;
      }
      if (!reverse) {
        return input.substring(start, stop);
      }
      return input.substring(input.length - stop, input.length - start);
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode;
var init_uriEncode = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/lib/index.js
var init_lib = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/lib/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_booleanEquals();
    init_getAttr();
    init_isSet();
    init_isValidHostLabel();
    init_not();
    init_parseURL();
    init_stringEquals();
    init_substring();
    init_uriEncode();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions;
var init_endpointFunctions = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_lib();
    endpointFunctions = {
      booleanEquals,
      getAttr,
      isSet,
      isValidHostLabel,
      not,
      parseURL,
      stringEquals,
      substring,
      uriEncode
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate;
var init_evaluateTemplate = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_lib();
    evaluateTemplate = (template, options) => {
      const evaluatedTemplateArr = [];
      const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      let currentIndex = 0;
      while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(currentIndex));
          break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex));
          break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
          currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
          const [refName, attrName] = parameterName.split("#");
          evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        } else {
          evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
      }
      return evaluatedTemplateArr.join("");
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue;
var init_getReferenceValue = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getReferenceValue = ({ ref }, options) => {
      const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      return referenceRecord[ref];
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression;
var init_evaluateExpression = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_callFunction();
    init_evaluateTemplate();
    init_getReferenceValue();
    evaluateExpression = (obj, keyName, options) => {
      if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
      } else if (obj["fn"]) {
        return callFunction(obj, options);
      } else if (obj["ref"]) {
        return getReferenceValue(obj, options);
      }
      throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var callFunction;
var init_callFunction = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_customEndpointFunctions();
    init_endpointFunctions();
    init_evaluateExpression();
    callFunction = ({ fn, argv }, options) => {
      const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
      const fnSegments = fn.split(".");
      if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
      }
      return endpointFunctions[fn](...evaluatedArgs);
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition;
var init_evaluateCondition = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_debug();
    init_types3();
    init_callFunction();
    evaluateCondition = ({ assign, ...fnArgs }, options) => {
      if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
      }
      const value = callFunction(fnArgs, options);
      options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
      return {
        result: value === "" ? true : !!value,
        ...assign != null && { toAssign: { name: assign, value } }
      };
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions;
var init_evaluateConditions = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_debug();
    init_evaluateCondition();
    evaluateConditions = (conditions = [], options) => {
      const conditionsReferenceRecord = {};
      for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...conditionsReferenceRecord
          }
        });
        if (!result) {
          return { result };
        }
        if (toAssign) {
          conditionsReferenceRecord[toAssign.name] = toAssign.value;
          options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
      }
      return { result: true, referenceRecord: conditionsReferenceRecord };
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders;
var init_getEndpointHeaders = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_evaluateExpression();
    getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
      ...acc,
      [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
          throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
      })
    }), {});
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty;
var init_getEndpointProperty = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_evaluateTemplate();
    init_getEndpointProperties();
    getEndpointProperty = (property, options) => {
      if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
      }
      switch (typeof property) {
        case "string":
          return evaluateTemplate(property, options);
        case "object":
          if (property === null) {
            throw new EndpointError(`Unexpected endpoint property: ${property}`);
          }
          return getEndpointProperties(property, options);
        case "boolean":
          return property;
        default:
          throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
      }
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties;
var init_getEndpointProperties = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getEndpointProperty();
    getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
      ...acc,
      [propertyKey]: getEndpointProperty(propertyVal, options)
    }), {});
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl;
var init_getEndpointUrl = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_evaluateExpression();
    getEndpointUrl = (endpointUrl, options) => {
      const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
      if (typeof expression === "string") {
        try {
          return new URL(expression);
        } catch (error) {
          console.error(`Failed to construct URL with ${expression}`, error);
          throw error;
        }
      }
      throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule;
var init_evaluateEndpointRule = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_debug();
    init_evaluateConditions();
    init_getEndpointHeaders();
    init_getEndpointProperties();
    init_getEndpointUrl();
    evaluateEndpointRule = (endpointRule, options) => {
      const { conditions, endpoint } = endpointRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      };
      const { url, properties, headers } = endpoint;
      options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
      return {
        ...headers != void 0 && {
          headers: getEndpointHeaders(headers, endpointRuleOptions)
        },
        ...properties != void 0 && {
          properties: getEndpointProperties(properties, endpointRuleOptions)
        },
        url: getEndpointUrl(url, endpointRuleOptions)
      };
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule;
var init_evaluateErrorRule = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_evaluateConditions();
    init_evaluateExpression();
    evaluateErrorRule = (errorRule, options) => {
      const { conditions, error } = errorRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      }));
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule;
var init_evaluateTreeRule = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_evaluateConditions();
    init_evaluateRules();
    evaluateTreeRule = (treeRule, options) => {
      const { conditions, rules } = treeRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      return evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      });
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules;
var init_evaluateRules = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types3();
    init_evaluateEndpointRule();
    init_evaluateErrorRule();
    init_evaluateTreeRule();
    evaluateRules = (rules, options) => {
      for (const rule of rules) {
        if (rule.type === "endpoint") {
          const endpointOrUndefined = evaluateEndpointRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else if (rule.type === "error") {
          evaluateErrorRule(rule, options);
        } else if (rule.type === "tree") {
          const endpointOrUndefined = evaluateTreeRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else {
          throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
      }
      throw new EndpointError(`Rules evaluation failed`);
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/utils/index.js
var init_utils = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/utils/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_customEndpointFunctions();
    init_evaluateRules();
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint;
var init_resolveEndpoint = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_debug();
    init_types3();
    init_utils();
    resolveEndpoint = (ruleSetObject, options) => {
      const { endpointParams, logger: logger2 } = options;
      const { parameters, rules } = ruleSetObject;
      options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
      const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
      if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
          endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
      }
      const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
      for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
          throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
      }
      const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
      if (options.endpointParams?.Endpoint) {
        try {
          const givenEndpoint = new URL(options.endpointParams.Endpoint);
          const { protocol, port } = givenEndpoint;
          endpoint.url.protocol = protocol;
          endpoint.url.port = port;
        } catch (e2) {
        }
      }
      options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
      return endpoint;
    };
  }
});

// ../node_modules/@smithy/util-endpoints/dist-es/index.js
var init_dist_es24 = __esm({
  "../node_modules/@smithy/util-endpoints/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_isIpAddress();
    init_isValidHostLabel();
    init_customEndpointFunctions();
    init_resolveEndpoint();
    init_types3();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var init_isIpAddress2 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es24();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket;
var init_isVirtualHostableS3Bucket = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es24();
    init_isIpAddress2();
    isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
      if (allowSubDomains) {
        for (const label of value.split(".")) {
          if (!isVirtualHostableS3Bucket(label)) {
            return false;
          }
        }
        return true;
      }
      if (!isValidHostLabel(value)) {
        return false;
      }
      if (value.length < 3 || value.length > 63) {
        return false;
      }
      if (value !== value.toLowerCase()) {
        return false;
      }
      if (isIpAddress(value)) {
        return false;
      }
      return true;
    };
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn;
var init_parseArn = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    parseArn = (value) => {
      const segments = value.split(":");
      if (segments.length < 6)
        return null;
      const [arn, partition2, service, region, accountId, ...resourceId] = segments;
      if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
        return null;
      return {
        partition: partition2,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
      };
    };
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default;
var init_partitions = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json"() {
    partitions_default = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {}
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {}
      }],
      version: "1.1"
    };
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo, selectedUserAgentPrefix, partition, getUserAgentPrefix;
var init_partition = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_partitions();
    selectedPartitionsInfo = partitions_default;
    selectedUserAgentPrefix = "";
    partition = (value) => {
      const { partitions } = selectedPartitionsInfo;
      for (const partition2 of partitions) {
        const { regions, outputs } = partition2;
        for (const [region, regionData] of Object.entries(regions)) {
          if (region === value) {
            return {
              ...outputs,
              ...regionData
            };
          }
        }
      }
      for (const partition2 of partitions) {
        const { regionRegex, outputs } = partition2;
        if (new RegExp(regionRegex).test(value)) {
          return {
            ...outputs
          };
        }
      }
      const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
      if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      }
      return {
        ...DEFAULT_PARTITION.outputs
      };
    };
    getUserAgentPrefix = () => selectedUserAgentPrefix;
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions;
var init_aws = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es24();
    init_isVirtualHostableS3Bucket();
    init_parseArn();
    init_partition();
    awsEndpointFunctions = {
      isVirtualHostableS3Bucket,
      parseArn,
      partition
    };
    customEndpointFunctions.aws = awsEndpointFunctions;
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var init_resolveEndpoint2 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es24();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var init_EndpointError2 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es24();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject3 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject3 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject3 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject3 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
var init_shared3 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
var init_types4 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EndpointError2();
    init_EndpointRuleObject3();
    init_ErrorRuleObject3();
    init_RuleSetObject3();
    init_TreeRuleObject3();
    init_shared3();
  }
});

// ../node_modules/@aws-sdk/util-endpoints/dist-es/index.js
var init_dist_es25 = __esm({
  "../node_modules/@aws-sdk/util-endpoints/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_aws();
    init_partition();
    init_isIpAddress2();
    init_resolveEndpoint2();
    init_types4();
  }
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT, X_AMZ_USER_AGENT, SPACE, UA_NAME_SEPARATOR, UA_NAME_ESCAPE_REGEX, UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR;
var init_constants4 = __esm({
  "../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    USER_AGENT = "user-agent";
    X_AMZ_USER_AGENT = "x-amz-user-agent";
    SPACE = " ";
    UA_NAME_SEPARATOR = "/";
    UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    UA_ESCAPE_CHAR = "-";
  }
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware, escapeUserAgent, getUserAgentMiddlewareOptions, getUserAgentPlugin;
var init_user_agent_middleware = __esm({
  "../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es25();
    init_dist_es2();
    init_constants4();
    userAgentMiddleware = (options) => (next, context) => async (args) => {
      const { request } = args;
      if (!HttpRequest.isInstance(request))
        return next(args);
      const { headers } = request;
      const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
      const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
      const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
      const prefix = getUserAgentPrefix();
      const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE);
      const normalUAValue = [
        ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent
      ].join(SPACE);
      if (options.runtime !== "browser") {
        if (normalUAValue) {
          headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
      } else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
      }
      return next({
        ...args,
        request
      });
    };
    escapeUserAgent = (userAgentPair) => {
      const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
      const version2 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
      const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
      const prefix = name.substring(0, prefixSeparatorIndex);
      let uaName = name.substring(prefixSeparatorIndex + 1);
      if (prefix === "api") {
        uaName = uaName.toLowerCase();
      }
      return [prefix, uaName, version2].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
        switch (index) {
          case 0:
            return item;
          case 1:
            return `${acc}/${item}`;
          default:
            return `${acc}#${item}`;
        }
      }, "");
    };
    getUserAgentMiddlewareOptions = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: true
    };
    getUserAgentPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
var init_dist_es26 = __esm({
  "../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_configurations();
    init_user_agent_middleware();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var DEFAULT_USE_DUALSTACK_ENDPOINT;
var init_NodeUseDualstackEndpointConfigOptions = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es19();
    DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var DEFAULT_USE_FIPS_ENDPOINT;
var init_NodeUseFipsEndpointConfigOptions = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es19();
    DEFAULT_USE_FIPS_ENDPOINT = false;
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
var init_resolveCustomEndpointsConfig = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es16();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js
var init_getEndpointFromRegion = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
var init_resolveEndpointsConfig = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es16();
    init_getEndpointFromRegion();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
var init_endpointsConfig = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_NodeUseDualstackEndpointConfigOptions();
    init_NodeUseFipsEndpointConfigOptions();
    init_resolveCustomEndpointsConfig();
    init_resolveEndpointsConfig();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var init_config2 = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion;
var init_isFipsRegion = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion;
var init_getRealRegion = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_isFipsRegion();
    getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig;
var init_resolveRegionConfig = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getRealRegion();
    init_isFipsRegion();
    resolveRegionConfig = (input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return {
        ...input,
        region: async () => {
          if (typeof region === "string") {
            return getRealRegion(region);
          }
          const providedRegion = await region();
          return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      };
    };
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
var init_regionConfig = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_config2();
    init_resolveRegionConfig();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
var init_PartitionHash = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
var init_RegionHash = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js
var init_getHostnameFromVariants = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedHostname.js
var init_getResolvedHostname = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedHostname.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedPartition.js
var init_getResolvedPartition = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedPartition.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js
var init_getResolvedSigningRegion = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
var init_getRegionInfo = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getHostnameFromVariants();
    init_getResolvedHostname();
    init_getResolvedPartition();
    init_getResolvedSigningRegion();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
var init_regionInfo = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_PartitionHash();
    init_RegionHash();
    init_getRegionInfo();
  }
});

// ../node_modules/@smithy/config-resolver/dist-es/index.js
var init_dist_es27 = __esm({
  "../node_modules/@smithy/config-resolver/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_endpointsConfig();
    init_regionConfig();
    init_regionInfo();
  }
});

// ../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig;
var init_EventStreamSerdeConfig = __esm({
  "../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    resolveEventStreamSerdeConfig = (input) => ({
      ...input,
      eventStreamMarshaller: input.eventStreamSerdeProvider(input)
    });
  }
});

// ../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js
var init_dist_es28 = __esm({
  "../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamSerdeConfig();
  }
});

// ../node_modules/@smithy/middleware-content-length/dist-es/index.js
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var CONTENT_LENGTH_HEADER2, contentLengthMiddlewareOptions, getContentLengthPlugin;
var init_dist_es29 = __esm({
  "../node_modules/@smithy/middleware-content-length/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    CONTENT_LENGTH_HEADER2 = "content-length";
    contentLengthMiddlewareOptions = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: true
    };
    getContentLengthPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3, DOMAIN_PATTERN, IP_ADDRESS_PATTERN, DOTS_PATTERN, isDnsCompatibleBucketName, isArnBucketName;
var init_s3 = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    resolveParamsForS3 = async (endpointParams) => {
      const bucket = endpointParams?.Bucket || "";
      if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      }
      if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
          throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
      } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
      }
      if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
      }
      return endpointParams;
    };
    DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    DOTS_PATTERN = /\.\./;
    isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    isArnBucketName = (bucketName) => {
      const [arn, partition2, service, , , bucket] = bucketName.split(":");
      const isArn = arn === "arn" && bucketName.split(":").length >= 6;
      const isValidArn = Boolean(isArn && partition2 && service && bucket);
      if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
      }
      return isValidArn;
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
var init_service_customizations = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_s3();
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider;
var init_createConfigValueProvider = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
      const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
          return configValue();
        }
        return configValue;
      };
      if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
          return configValue;
        };
      }
      if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
          const endpoint = await configProvider();
          if (endpoint && typeof endpoint === "object") {
            if ("url" in endpoint) {
              return endpoint.url.href;
            }
            if ("hostname" in endpoint) {
              const { protocol, hostname, port, path } = endpoint;
              return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
            }
          }
          return endpoint;
        };
      }
      return configProvider;
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
var getEndpointFromConfig;
var init_getEndpointFromConfig_browser = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getEndpointFromConfig = async (serviceId) => void 0;
  }
});

// ../node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
var init_dist_es30 = __esm({
  "../node_modules/@smithy/querystring-parser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl;
var init_dist_es31 = __esm({
  "../node_modules/@smithy/url-parser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es30();
    parseUrl = (url) => {
      if (typeof url === "string") {
        return parseUrl(new URL(url));
      }
      const { hostname, pathname, port, protocol, search } = url;
      let query;
      if (search) {
        query = parseQueryString(search);
      }
      return {
        hostname,
        port: port ? parseInt(port) : void 0,
        protocol,
        path: pathname,
        query
      };
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1;
var init_toEndpointV1 = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es31();
    toEndpointV1 = (endpoint) => {
      if (typeof endpoint === "object") {
        if ("url" in endpoint) {
          return parseUrl(endpoint.url);
        }
        return endpoint;
      }
      return parseUrl(endpoint);
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions, resolveParams;
var init_getEndpointFromInstructions = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_service_customizations();
    init_createConfigValueProvider();
    init_getEndpointFromConfig_browser();
    init_toEndpointV1();
    getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
      if (!clientConfig.endpoint) {
        const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
        if (endpointFromConfig) {
          clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        }
      }
      const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
      if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
      }
      const endpoint = clientConfig.endpointProvider(endpointParams, context);
      return endpoint;
    };
    resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
      const endpointParams = {};
      const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
      for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
          case "staticContextParams":
            endpointParams[name] = instruction.value;
            break;
          case "contextParams":
            endpointParams[name] = commandInput[instruction.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
            break;
          default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
      }
      if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
      }
      if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
      }
      return endpointParams;
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
var init_adaptors = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getEndpointFromInstructions();
    init_toEndpointV1();
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware;
var init_endpointMiddleware = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es16();
    init_getEndpointFromInstructions();
    endpointMiddleware = ({ config, instructions }) => {
      return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
          getEndpointParameterInstructions() {
            return instructions;
          }
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
          context["signing_region"] = authScheme.signingRegion;
          context["signing_service"] = authScheme.signingName;
          const smithyContext = getSmithyContext(context);
          const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
          if (httpAuthOption) {
            httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
              signing_region: authScheme.signingRegion,
              signingRegion: authScheme.signingRegion,
              signing_service: authScheme.signingName,
              signingName: authScheme.signingName,
              signingRegionSet: authScheme.signingRegionSet
            }, authScheme.properties);
          }
        }
        return next({
          ...args
        });
      };
    };
  }
});

// ../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware;
var init_deserializerMiddleware = __esm({
  "../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
      const { response } = await next(args);
      try {
        const parsed = await deserializer(response, options);
        return {
          response,
          output: parsed
        };
      } catch (error) {
        Object.defineProperty(error, "$response", {
          value: response
        });
        if (!("$metadata" in error)) {
          const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
          error.message += "\n  " + hint;
          if (typeof error.$responseBodyText !== "undefined") {
            if (error.$response) {
              error.$response.body = error.$responseBodyText;
            }
          }
        }
        throw error;
      }
    };
  }
});

// ../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware;
var init_serializerMiddleware = __esm({
  "../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
      const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
      if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
      }
      const request = await serializer(args.input, { ...options, endpoint });
      return next({
        ...args,
        request
      });
    };
  }
});

// ../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}
var deserializerMiddlewareOption, serializerMiddlewareOption;
var init_serdePlugin = __esm({
  "../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_deserializerMiddleware();
    init_serializerMiddleware();
    deserializerMiddlewareOption = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    serializerMiddlewareOption = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
  }
});

// ../node_modules/@smithy/middleware-serde/dist-es/index.js
var init_dist_es32 = __esm({
  "../node_modules/@smithy/middleware-serde/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_deserializerMiddleware();
    init_serdePlugin();
    init_serializerMiddleware();
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions, getEndpointPlugin;
var init_getEndpointPlugin = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es32();
    init_endpointMiddleware();
    endpointMiddlewareOptions = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: true,
      relation: "before",
      toMiddleware: serializerMiddlewareOption.name
    };
    getEndpointPlugin = (config, instructions) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
          config,
          instructions
        }), endpointMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig;
var init_resolveEndpointConfig = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es16();
    init_toEndpointV1();
    resolveEndpointConfig = (input) => {
      const tls = input.tls ?? true;
      const { endpoint } = input;
      const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
      const isCustomEndpoint = !!endpoint;
      return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
      };
    };
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/types.js
var init_types5 = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/middleware-endpoint/dist-es/index.js
var init_dist_es33 = __esm({
  "../node_modules/@smithy/middleware-endpoint/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_adaptors();
    init_endpointMiddleware();
    init_getEndpointPlugin();
    init_resolveEndpointConfig();
    init_types5();
  }
});

// ../node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES, DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE;
var init_config3 = __esm({
  "../node_modules/@smithy/util-retry/dist-es/config.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(RETRY_MODES2) {
      RETRY_MODES2["STANDARD"] = "standard";
      RETRY_MODES2["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES || (RETRY_MODES = {}));
    DEFAULT_MAX_ATTEMPTS = 3;
    DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
  }
});

// ../node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, NODEJS_TIMEOUT_ERROR_CODES;
var init_constants5 = __esm({
  "../node_modules/@smithy/service-error-classification/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    THROTTLING_ERROR_CODES = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException"
    ];
    TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
  }
});

// ../node_modules/@smithy/service-error-classification/dist-es/index.js
var isClockSkewCorrectedError, isThrottlingError, isTransientError, isServerError;
var init_dist_es34 = __esm({
  "../node_modules/@smithy/service-error-classification/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants5();
    isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
    isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
    isTransientError = (error) => isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
    isServerError = (error) => {
      if (error.$metadata?.httpStatusCode !== void 0) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
          return true;
        }
        return false;
      }
      return false;
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter;
var init_DefaultRateLimiter = __esm({
  "../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es34();
    DefaultRateLimiter = class {
      constructor(options) {
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(amount) {
        if (!this.enabled) {
          return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
          const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
      }
      refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
          return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
      }
      updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (isThrottlingError(response)) {
          const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = rateToUse;
          this.calculateTimeWindow();
          this.lastThrottleTime = this.getCurrentTimeInSeconds();
          calculatedRate = this.cubicThrottle(rateToUse);
          this.enableTokenBucket();
        } else {
          this.calculateTimeWindow();
          calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
      }
      cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
      }
      cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
      }
      enableTokenBucket() {
        this.enabled = true;
      }
      updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
      }
      updateMeasuredRate() {
        const t2 = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t2 * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
          const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
          this.requestCount = 0;
          this.lastTxRateBucket = timeBucket;
        }
      }
      getPrecise(num) {
        return parseFloat(num.toFixed(8));
      }
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, THROTTLING_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, RETRY_COST, TIMEOUT_RETRY_COST, NO_RETRY_INCREMENT, INVOCATION_ID_HEADER, REQUEST_HEADER;
var init_constants6 = __esm({
  "../node_modules/@smithy/util-retry/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    DEFAULT_RETRY_DELAY_BASE = 100;
    MAXIMUM_RETRY_DELAY = 20 * 1e3;
    THROTTLING_RETRY_DELAY_BASE = 500;
    INITIAL_RETRY_TOKENS = 500;
    RETRY_COST = 5;
    TIMEOUT_RETRY_COST = 10;
    NO_RETRY_INCREMENT = 1;
    INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    REQUEST_HEADER = "amz-sdk-request";
  }
});

// ../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy;
var init_defaultRetryBackoffStrategy = __esm({
  "../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants6();
    getDefaultRetryBackoffStrategy = () => {
      let delayBase = DEFAULT_RETRY_DELAY_BASE;
      const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      };
      const setDelayBase = (delay) => {
        delayBase = delay;
      };
      return {
        computeNextBackoffDelay,
        setDelayBase
      };
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken;
var init_defaultRetryToken = __esm({
  "../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants6();
    createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
      const getRetryCount = () => retryCount;
      const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
      const getRetryCost = () => retryCost;
      return {
        getRetryCount,
        getRetryDelay,
        getRetryCost
      };
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy;
var init_StandardRetryStrategy = __esm({
  "../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_config3();
    init_constants6();
    init_defaultRetryBackoffStrategy();
    init_defaultRetryToken();
    StandardRetryStrategy = class {
      constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = RETRY_MODES.STANDARD;
        this.capacity = INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
      }
      async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
          retryDelay: DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0
        });
      }
      async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
          const errorType = errorInfo.errorType;
          this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
          const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
          const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
          const capacityCost = this.getCapacityCost(errorType);
          this.capacity -= capacityCost;
          return createDefaultRetryToken({
            retryDelay,
            retryCount: token.getRetryCount() + 1,
            retryCost: capacityCost
          });
        }
        throw new Error("No retry token available");
      }
      recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch (error) {
          console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
          return DEFAULT_MAX_ATTEMPTS;
        }
      }
      shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
      }
      getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
      }
      isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
      }
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy;
var init_AdaptiveRetryStrategy = __esm({
  "../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_config3();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    AdaptiveRetryStrategy = class {
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
      }
      async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      }
      recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
      }
    };
  }
});

// ../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
var init_ConfiguredRetryStrategy = __esm({
  "../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants6();
    init_StandardRetryStrategy();
  }
});

// ../node_modules/@smithy/util-retry/dist-es/types.js
var init_types6 = __esm({
  "../node_modules/@smithy/util-retry/dist-es/types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-retry/dist-es/index.js
var init_dist_es35 = __esm({
  "../node_modules/@smithy/util-retry/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_AdaptiveRetryStrategy();
    init_ConfiguredRetryStrategy();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    init_config3();
    init_constants6();
    init_types6();
  }
});

// ../node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "../node_modules/uuid/dist/esm-browser/rng.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    rnds8 = new Uint8Array(16);
  }
});

// ../node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex;
var init_stringify = __esm({
  "../node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
  }
});

// ../node_modules/uuid/dist/esm-browser/native.js
var randomUUID, native_default;
var init_native = __esm({
  "../node_modules/uuid/dist/esm-browser/native.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = {
      randomUUID
    };
  }
});

// ../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../node_modules/uuid/dist/esm-browser/v4.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "../node_modules/uuid/dist/esm-browser/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_v4();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
var init_defaultRetryQuota = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es35();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
var init_delayDecider = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es35();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
var init_retryDecider = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es34();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError;
var init_util2 = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/util.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    asSdkError = (error) => {
      if (error instanceof Error)
        return error;
      if (error instanceof Object)
        return Object.assign(new Error(), error);
      if (typeof error === "string")
        return new Error(error);
      return new Error(`AWS SDK error wrapper for ${error}`);
    };
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
var init_StandardRetryStrategy2 = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es34();
    init_dist_es35();
    init_defaultRetryQuota();
    init_delayDecider();
    init_retryDecider();
    init_util2();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
var init_AdaptiveRetryStrategy2 = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es35();
    init_StandardRetryStrategy2();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/configurations.js
var resolveRetryConfig;
var init_configurations2 = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/configurations.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es16();
    init_dist_es35();
    resolveRetryConfig = (input) => {
      const { retryStrategy } = input;
      const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
      return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
          if (retryStrategy) {
            return retryStrategy;
          }
          const retryMode = await normalizeProvider(input.retryMode)();
          if (retryMode === RETRY_MODES.ADAPTIVE) {
            return new AdaptiveRetryStrategy(maxAttempts);
          }
          return new StandardRetryStrategy(maxAttempts);
        }
      };
    };
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
var init_omitRetryHeadersMiddleware = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es35();
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
var isStreamingPayload;
var init_isStreamingPayload_browser = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    isStreamingPayload = (request) => request?.body instanceof ReadableStream;
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware, isRetryStrategyV2, getRetryErrorInfo, getRetryErrorType, retryMiddlewareOptions, getRetryPlugin, getRetryAfterHint;
var init_retryMiddleware = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es34();
    init_dist_es15();
    init_dist_es35();
    init_esm_browser();
    init_isStreamingPayload_browser();
    init_util2();
    retryMiddleware = (options) => (next, context) => async (args) => {
      let retryStrategy = await options.retryStrategy();
      const maxAttempts = await options.maxAttempts();
      if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = HttpRequest.isInstance(request);
        if (isRequest) {
          request.headers[INVOCATION_ID_HEADER] = v4_default();
        }
        while (true) {
          try {
            if (isRequest) {
              request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            const { response, output } = await next(args);
            retryStrategy.recordSuccess(retryToken);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalRetryDelay;
            return { response, output };
          } catch (e2) {
            const retryErrorInfo = getRetryErrorInfo(e2);
            lastError = asSdkError(e2);
            if (isRequest && isStreamingPayload(request)) {
              (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
              throw lastError;
            }
            try {
              retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
            } catch (refreshError) {
              if (!lastError.$metadata) {
                lastError.$metadata = {};
              }
              lastError.$metadata.attempts = attempts + 1;
              lastError.$metadata.totalRetryDelay = totalRetryDelay;
              throw lastError;
            }
            attempts = retryToken.getRetryCount();
            const delay = retryToken.getRetryDelay();
            totalRetryDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      } else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
          context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
      }
    };
    isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
    getRetryErrorInfo = (error) => {
      const errorInfo = {
        error,
        errorType: getRetryErrorType(error)
      };
      const retryAfterHint = getRetryAfterHint(error.$response);
      if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
      }
      return errorInfo;
    };
    getRetryErrorType = (error) => {
      if (isThrottlingError(error))
        return "THROTTLING";
      if (isTransientError(error))
        return "TRANSIENT";
      if (isServerError(error))
        return "SERVER_ERROR";
      return "CLIENT_ERROR";
    };
    retryMiddlewareOptions = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: true
    };
    getRetryPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
      }
    });
    getRetryAfterHint = (response) => {
      if (!HttpResponse.isInstance(response))
        return;
      const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1e3);
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate;
    };
  }
});

// ../node_modules/@smithy/middleware-retry/dist-es/index.js
var init_dist_es36 = __esm({
  "../node_modules/@smithy/middleware-retry/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_AdaptiveRetryStrategy2();
    init_StandardRetryStrategy2();
    init_configurations2();
    init_delayDecider();
    init_omitRetryHeadersMiddleware();
    init_retryDecider();
    init_retryMiddleware();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters, commonParams;
var init_EndpointParameters = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    resolveClientEndpointParameters = (options) => {
      return {
        ...options,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        forcePathStyle: options.forcePathStyle ?? false,
        useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
        defaultSigningName: "s3"
      };
    };
    commonParams = {
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
var S3ServiceException;
var init_S3ServiceException = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    S3ServiceException = class extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, S3ServiceException.prototype);
      }
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var NoSuchUpload, ObjectNotInActiveTierError, BucketAlreadyExists, BucketAlreadyOwnedByYou, NoSuchBucket, AnalyticsFilter, LifecycleRuleFilter, MetricsFilter, ReplicationRuleFilter, InvalidObjectState, NoSuchKey, NotFound, CompleteMultipartUploadOutputFilterSensitiveLog, CompleteMultipartUploadRequestFilterSensitiveLog, CopyObjectOutputFilterSensitiveLog, CopyObjectRequestFilterSensitiveLog, CreateMultipartUploadOutputFilterSensitiveLog, CreateMultipartUploadRequestFilterSensitiveLog, SessionCredentialsFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog, ServerSideEncryptionByDefaultFilterSensitiveLog, ServerSideEncryptionRuleFilterSensitiveLog, ServerSideEncryptionConfigurationFilterSensitiveLog, GetBucketEncryptionOutputFilterSensitiveLog, SSEKMSFilterSensitiveLog, InventoryEncryptionFilterSensitiveLog, InventoryS3BucketDestinationFilterSensitiveLog, InventoryDestinationFilterSensitiveLog, InventoryConfigurationFilterSensitiveLog, GetBucketInventoryConfigurationOutputFilterSensitiveLog, GetObjectOutputFilterSensitiveLog, GetObjectRequestFilterSensitiveLog, GetObjectAttributesRequestFilterSensitiveLog, GetObjectTorrentOutputFilterSensitiveLog, HeadObjectOutputFilterSensitiveLog, HeadObjectRequestFilterSensitiveLog, ListBucketInventoryConfigurationsOutputFilterSensitiveLog, ListPartsRequestFilterSensitiveLog, PutBucketEncryptionRequestFilterSensitiveLog, PutBucketInventoryConfigurationRequestFilterSensitiveLog;
var init_models_0 = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    init_S3ServiceException();
    NoSuchUpload = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "NoSuchUpload",
          $fault: "client",
          ...opts
        });
        this.name = "NoSuchUpload";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchUpload.prototype);
      }
    };
    ObjectNotInActiveTierError = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "ObjectNotInActiveTierError",
          $fault: "client",
          ...opts
        });
        this.name = "ObjectNotInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
      }
    };
    BucketAlreadyExists = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "BucketAlreadyExists",
          $fault: "client",
          ...opts
        });
        this.name = "BucketAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
      }
    };
    BucketAlreadyOwnedByYou = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "BucketAlreadyOwnedByYou",
          $fault: "client",
          ...opts
        });
        this.name = "BucketAlreadyOwnedByYou";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
      }
    };
    NoSuchBucket = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "NoSuchBucket",
          $fault: "client",
          ...opts
        });
        this.name = "NoSuchBucket";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchBucket.prototype);
      }
    };
    (function(AnalyticsFilter2) {
      AnalyticsFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(AnalyticsFilter || (AnalyticsFilter = {}));
    (function(LifecycleRuleFilter2) {
      LifecycleRuleFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.ObjectSizeGreaterThan !== void 0)
          return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
        if (value.ObjectSizeLessThan !== void 0)
          return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
    (function(MetricsFilter2) {
      MetricsFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.AccessPointArn !== void 0)
          return visitor.AccessPointArn(value.AccessPointArn);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(MetricsFilter || (MetricsFilter = {}));
    (function(ReplicationRuleFilter2) {
      ReplicationRuleFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
    InvalidObjectState = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "InvalidObjectState",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidObjectState";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidObjectState.prototype);
        this.StorageClass = opts.StorageClass;
        this.AccessTier = opts.AccessTier;
      }
    };
    NoSuchKey = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "NoSuchKey",
          $fault: "client",
          ...opts
        });
        this.name = "NoSuchKey";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchKey.prototype);
      }
    };
    NotFound = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "NotFound",
          $fault: "client",
          ...opts
        });
        this.name = "NotFound";
        this.$fault = "client";
        Object.setPrototypeOf(this, NotFound.prototype);
      }
    };
    CompleteMultipartUploadOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
    CompleteMultipartUploadRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    CopyObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
    });
    CopyObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING },
      ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: SENSITIVE_STRING }
    });
    CreateMultipartUploadOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
    });
    CreateMultipartUploadRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
    });
    SessionCredentialsFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
      ...obj.SessionToken && { SessionToken: SENSITIVE_STRING }
    });
    CreateSessionOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
    });
    ServerSideEncryptionByDefaultFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KMSMasterKeyID && { KMSMasterKeyID: SENSITIVE_STRING }
    });
    ServerSideEncryptionRuleFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ApplyServerSideEncryptionByDefault && {
        ApplyServerSideEncryptionByDefault: ServerSideEncryptionByDefaultFilterSensitiveLog(obj.ApplyServerSideEncryptionByDefault)
      }
    });
    ServerSideEncryptionConfigurationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Rules && { Rules: obj.Rules.map((item) => ServerSideEncryptionRuleFilterSensitiveLog(item)) }
    });
    GetBucketEncryptionOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: ServerSideEncryptionConfigurationFilterSensitiveLog(obj.ServerSideEncryptionConfiguration)
      }
    });
    SSEKMSFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KeyId && { KeyId: SENSITIVE_STRING }
    });
    InventoryEncryptionFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMS && { SSEKMS: SSEKMSFilterSensitiveLog(obj.SSEKMS) }
    });
    InventoryS3BucketDestinationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Encryption && { Encryption: InventoryEncryptionFilterSensitiveLog(obj.Encryption) }
    });
    InventoryDestinationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.S3BucketDestination && {
        S3BucketDestination: InventoryS3BucketDestinationFilterSensitiveLog(obj.S3BucketDestination)
      }
    });
    InventoryConfigurationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Destination && { Destination: InventoryDestinationFilterSensitiveLog(obj.Destination) }
    });
    GetBucketInventoryConfigurationOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfiguration && {
        InventoryConfiguration: InventoryConfigurationFilterSensitiveLog(obj.InventoryConfiguration)
      }
    });
    GetObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
    GetObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    GetObjectAttributesRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    GetObjectTorrentOutputFilterSensitiveLog = (obj) => ({
      ...obj
    });
    HeadObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
    HeadObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    ListBucketInventoryConfigurationsOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfigurationList && {
        InventoryConfigurationList: obj.InventoryConfigurationList.map((item) => InventoryConfigurationFilterSensitiveLog(item))
      }
    });
    ListPartsRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    PutBucketEncryptionRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: ServerSideEncryptionConfigurationFilterSensitiveLog(obj.ServerSideEncryptionConfiguration)
      }
    });
    PutBucketInventoryConfigurationRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfiguration && {
        InventoryConfiguration: InventoryConfigurationFilterSensitiveLog(obj.InventoryConfiguration)
      }
    });
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js
var init_emitWarningIfUnsupportedVersion2 = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/client/index.js
var init_client3 = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/client/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_emitWarningIfUnsupportedVersion2();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var init_AwsSdkSigV4Signer = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
var init_httpAuthSchemeMiddleware = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
    init_dist_es16();
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions;
var init_getHttpAuthSchemeEndpointRuleSetPlugin = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: endpointMiddlewareOptions.name
    };
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
var httpAuthSchemeMiddlewareOptions;
var init_getHttpAuthSchemePlugin = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es32();
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: serializerMiddlewareOption.name
    };
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
var init_middleware_http_auth_scheme = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_httpAuthSchemeMiddleware();
    init_getHttpAuthSchemeEndpointRuleSetPlugin();
    init_getHttpAuthSchemePlugin();
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
var init_httpSigningMiddleware = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es();
    init_dist_es16();
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions;
var init_getHttpSigningMiddleware = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es36();
    init_httpSigningMiddleware();
    httpSigningMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: true,
      relation: "after",
      toMiddleware: retryMiddlewareOptions.name
    };
  }
});

// ../node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
var init_middleware_http_signing = __esm({
  "../node_modules/@smithy/core/dist-es/middleware-http-signing/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_httpSigningMiddleware();
    init_getHttpSigningMiddleware();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
var init_DefaultIdentityProviderConfig = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
var init_httpApiKeyAuth = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
var init_httpBearerAuth = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
var init_noAuth = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
var init_httpAuthSchemes = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_httpApiKeyAuth();
    init_httpBearerAuth();
    init_noAuth();
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
var createIsIdentityExpiredFunction, EXPIRATION_MS, isIdentityExpired, doesIdentityRequireRefresh;
var init_memoizeIdentityProvider = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
    EXPIRATION_MS = 3e5;
    isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
    doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
  }
});

// ../node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
var init_util_identity_and_auth = __esm({
  "../node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_DefaultIdentityProviderConfig();
    init_httpAuthSchemes();
    init_memoizeIdentityProvider();
  }
});

// ../node_modules/@smithy/core/dist-es/getSmithyContext.js
var init_getSmithyContext2 = __esm({
  "../node_modules/@smithy/core/dist-es/getSmithyContext.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es();
  }
});

// ../node_modules/@smithy/core/dist-es/normalizeProvider.js
var init_normalizeProvider2 = __esm({
  "../node_modules/@smithy/core/dist-es/normalizeProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/core/dist-es/protocols/requestBuilder.js
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var RequestBuilder;
var init_requestBuilder = __esm({
  "../node_modules/@smithy/core/dist-es/protocols/requestBuilder.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_dist_es15();
    RequestBuilder = class {
      constructor(input, context) {
        this.input = input;
        this.context = context;
        this.query = {};
        this.method = "";
        this.headers = {};
        this.path = "";
        this.body = null;
        this.hostname = "";
        this.resolvePathStack = [];
      }
      async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
          resolvePath(this.path);
        }
        return new HttpRequest({
          protocol,
          hostname: this.hostname || hostname,
          port,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers
        });
      }
      hn(hostname) {
        this.hostname = hostname;
        return this;
      }
      bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
          this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
      }
      p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
          this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
      }
      h(headers) {
        this.headers = headers;
        return this;
      }
      q(query) {
        this.query = query;
        return this;
      }
      b(body) {
        this.body = body;
        return this;
      }
      m(method) {
        this.method = method;
        return this;
      }
    };
  }
});

// ../node_modules/@smithy/core/dist-es/pagination/createPaginator.js
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
  return async function* paginateOperation(config, input, ...additionalArguments) {
    let token = config.startingToken || void 0;
    let hasNext = true;
    let page;
    while (hasNext) {
      input[inputTokenName] = token;
      if (pageSizeTokenName) {
        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;
      }
      if (config.client instanceof ClientCtor) {
        page = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);
      } else {
        throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
      }
      yield page;
      const prevToken = token;
      token = get(page, outputTokenName);
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return void 0;
  };
}
var makePagedClientRequest, get;
var init_createPaginator = __esm({
  "../node_modules/@smithy/core/dist-es/pagination/createPaginator.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    makePagedClientRequest = async (CommandCtor, client, input, ...args) => {
      return await client.send(new CommandCtor(input), ...args);
    };
    get = (fromObject, path) => {
      let cursor = fromObject;
      const pathComponents = path.split(".");
      for (const step of pathComponents) {
        if (!cursor || typeof cursor !== "object") {
          return void 0;
        }
        cursor = cursor[step];
      }
      return cursor;
    };
  }
});

// ../node_modules/@smithy/core/dist-es/index.js
var init_dist_es37 = __esm({
  "../node_modules/@smithy/core/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_middleware_http_auth_scheme();
    init_middleware_http_signing();
    init_util_identity_and_auth();
    init_getSmithyContext2();
    init_normalizeProvider2();
    init_requestBuilder();
    init_createPaginator();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
var init_resolveAwsSdkSigV4Config = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es37();
    init_dist_es18();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
var init_aws_sdk = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_AwsSdkSigV4Signer();
    init_resolveAwsSdkSigV4Config();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js
var init_httpAuthSchemes2 = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_aws_sdk();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js
var init_coercing_serializers = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js
var init_awsExpectUnion = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
var collectBodyString2;
var init_common = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    collectBodyString2 = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js
var init_parseJsonBody = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match2 = regex.exec(string);
      while (match2) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match2[0].length;
        const len = match2.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match2[index]);
        }
        matches.push(allmatches);
        match2 = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match2 = regexName.exec(string);
      return !(match2 === null || typeof match2 === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          if (arrayMode === "strict") {
            target[keys[i2]] = [a2[keys[i2]]];
          } else {
            target[keys[i2]] = a2[keys[i2]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
          i2 += 2;
          i2 = readPI(xmlData, i2);
          if (i2.err)
            return i2;
        } else if (xmlData[i2] === "<") {
          let tagStartPos = i2;
          i2++;
          if (xmlData[i2] === "!") {
            i2 = readCommentAndCDATA(xmlData, i2);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i2] === "/") {
              closingTag = true;
              i2++;
            }
            let tagName = "";
            for (; i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "	" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
              tagName += xmlData[i2];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i2--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
            }
            const result = readAttributeStr(xmlData, i2);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
            }
            let attrStr = result.value;
            i2 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i2 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 !== true) {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid2.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i2++; i2 < xmlData.length; i2++) {
              if (xmlData[i2] === "<") {
                if (xmlData[i2 + 1] === "!") {
                  i2++;
                  i2 = readCommentAndCDATA(xmlData, i2);
                  continue;
                } else if (xmlData[i2 + 1] === "?") {
                  i2 = readPI(xmlData, ++i2);
                  if (i2.err)
                    return i2;
                } else {
                  break;
                }
              } else if (xmlData[i2] === "&") {
                const afterAmp = validateAmpersand(xmlData, i2);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
                i2 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
                }
              }
            }
            if (xmlData[i2] === "<") {
              i2--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i2])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i2) {
      const start = i2;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] == "?" || xmlData[i2] == " ") {
          const tagname = xmlData.substr(start, i2 - start);
          if (i2 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
          } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
            i2++;
            break;
          } else {
            continue;
          }
        }
      }
      return i2;
    }
    function readCommentAndCDATA(xmlData, i2) {
      if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
        for (i2 += 3; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i2] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      }
      return i2;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i2) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i2];
          } else if (startChar !== xmlData[i2]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i2] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i2];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i2,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i2 = 0; i2 < matches.length; i2++) {
        if (matches[i2][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
        }
        const attrName = matches[i2][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i2) {
      let re = /\d/;
      if (xmlData[i2] === "x") {
        i2++;
        re = /[\da-fA-F]/;
      }
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === ";")
          return i2;
        if (!xmlData[i2].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i2) {
      i2++;
      if (xmlData[i2] === ";")
        return -1;
      if (xmlData[i2] === "#") {
        i2++;
        return validateNumberAmpersand(xmlData, i2);
      }
      let count = 0;
      for (; i2 < xmlData.length; i2++, count++) {
        if (xmlData[i2].match(/\w/) && count < 20)
          continue;
        if (xmlData[i2] === ";")
          break;
        return -1;
      }
      return i2;
    }
    function getErrorObject(code2, message, lineNumber) {
      return {
        err: {
          code: code2,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match2) {
      return match2.startIndex + match2[1].length;
    }
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode2;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var util = require_util();
    function readDocType(xmlData, i2) {
      const entities = {};
      if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
        i2 = i2 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i2)) {
              i2 += 7;
              [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i2))
              i2 += 8;
            else if (hasBody && isAttlist(xmlData, i2))
              i2 += 8;
            else if (hasBody && isNotation(xmlData, i2))
              i2 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i2] === ">") {
            if (comment) {
              if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i2] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i2];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i2 };
    }
    function readEntityExp(xmlData, i2) {
      let entityName2 = "";
      for (; i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
        entityName2 += xmlData[i2];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i2++];
      let val2 = "";
      for (; i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
        val2 += xmlData[i2];
      }
      return [entityName2, val2, i2];
    }
    function isComment(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module.exports = readDocType;
  }
});

// ../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../node_modules/strnum/strnum.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match2 = numRegex.exec(trimmedStr);
        if (match2) {
          const sign = match2[1];
          const leadingZeros = match2[2];
          let numTrimmedByZeros = trimZeros(match2[3]);
          const eNotation = match2[4] || match2[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i2 = 0; i2 < entKeys.length; i2++) {
        const ent = entKeys[i2];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i2 = 0; i2 < len; i2++) {
          const attrName = this.resolveNameSpace(matches[i2][1]);
          let oldVal = matches[i2][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        const ch2 = xmlData[i2];
        if (ch2 === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            let tagData = readTagExp(xmlData, i2, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i2 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i2 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i2 = endIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i2);
            this.docTypeEntities = result.entities;
            i2 = result.i;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i2 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i2 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i2 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i2 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i2 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i2 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i2];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i2; index < xmlData.length; index++) {
        let ch2 = xmlData[index];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i2, errMsg) {
      const closingIndex = xmlData.indexOf(str, i2);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i2) {
      const startIndex = i2;
      let openTagCount = 1;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i2),
                  i: closeIndex
                };
              }
            }
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
            i2 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i2, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i2 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          const atrrName = keys[i2];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser2;
  }
});

// ../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i2 = 0; i2 < options.entities.length; i2++) {
          const entity = options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// ../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j2 = 0; j2 < arrLen; j2++) {
            const item = jObj[key][j2];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j2 = 0; j2 < L2; j2++) {
              attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i2 = 0; i2 < this.options.entities.length; i2++) {
          const entity = this.options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// ../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var validator = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
var import_fast_xml_parser, parseXmlBody, parseXmlErrorBody, loadRestXmlErrorCode;
var init_parseXmlBody = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    import_fast_xml_parser = __toESM(require_fxp());
    init_common();
    parseXmlBody = (streamBody, context) => collectBodyString2(streamBody, context).then((encoded) => {
      if (encoded.length) {
        const parser = new import_fast_xml_parser.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: true,
          ignoreAttributes: false,
          ignoreDeclaration: true,
          parseTagValue: false,
          trimValues: false,
          tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        let parsedObj;
        try {
          parsedObj = parser.parse(encoded, true);
        } catch (e2) {
          if (e2 && typeof e2 === "object") {
            Object.defineProperty(e2, "$responseBodyText", {
              value: encoded
            });
          }
          throw e2;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    });
    parseXmlErrorBody = async (errorBody, context) => {
      const value = await parseXmlBody(errorBody, context);
      if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
      }
      return value;
    };
    loadRestXmlErrorCode = (output, data) => {
      if (data?.Error?.Code !== void 0) {
        return data.Error.Code;
      }
      if (data?.Code !== void 0) {
        return data.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// ../node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js
var init_protocols = __esm({
  "../node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_coercing_serializers();
    init_awsExpectUnion();
    init_parseJsonBody();
    init_parseXmlBody();
  }
});

// ../node_modules/@aws-sdk/core/dist-es/index.js
var init_dist_es38 = __esm({
  "../node_modules/@aws-sdk/core/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_client3();
    init_httpAuthSchemes2();
    init_protocols();
  }
});

// ../node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js
function escapeAttribute(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
var init_escape_attribute = __esm({
  "../node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js
function escapeElement(value) {
  return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
}
var init_escape_element = __esm({
  "../node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js
var XmlText;
var init_XmlText = __esm({
  "../node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_escape_element();
    XmlText = class {
      constructor(value) {
        this.value = value;
      }
      toString() {
        return escapeElement("" + this.value);
      }
    };
  }
});

// ../node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js
var XmlNode;
var init_XmlNode = __esm({
  "../node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_escape_attribute();
    init_XmlText();
    XmlNode = class {
      static of(name, childText, withName) {
        const node = new XmlNode(name);
        if (childText !== void 0) {
          node.addChildNode(new XmlText(childText));
        }
        if (withName !== void 0) {
          node.withName(withName);
        }
        return node;
      }
      constructor(name, children = []) {
        this.name = name;
        this.children = children;
        this.attributes = {};
      }
      withName(name) {
        this.name = name;
        return this;
      }
      addAttribute(name, value) {
        this.attributes[name] = value;
        return this;
      }
      addChildNode(child) {
        this.children.push(child);
        return this;
      }
      removeAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      n(name) {
        this.name = name;
        return this;
      }
      c(child) {
        this.children.push(child);
        return this;
      }
      a(name, value) {
        if (value != null) {
          this.attributes[name] = value;
        }
        return this;
      }
      cc(input, field, withName = field) {
        if (input[field] != null) {
          const node = XmlNode.of(field, input[field]).withName(withName);
          this.c(node);
        }
      }
      l(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          nodes.map((node) => {
            node.withName(memberName);
            this.c(node);
          });
        }
      }
      lc(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          const containerNode = new XmlNode(memberName);
          nodes.map((node) => {
            containerNode.c(node);
          });
          this.c(containerNode);
        }
      }
      toString() {
        const hasChildren = Boolean(this.children.length);
        let xmlText = `<${this.name}`;
        const attributes = this.attributes;
        for (const attributeName of Object.keys(attributes)) {
          const attribute = attributes[attributeName];
          if (attribute != null) {
            xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
          }
        }
        return xmlText += !hasChildren ? "/>" : `>${this.children.map((c2) => c2.toString()).join("")}</${this.name}>`;
      }
    };
  }
});

// ../node_modules/@aws-sdk/xml-builder/dist-es/index.js
var init_dist_es39 = __esm({
  "../node_modules/@aws-sdk/xml-builder/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_XmlNode();
    init_XmlText();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
var ObjectAlreadyInActiveTierError, SelectObjectContentEventStream, PutObjectOutputFilterSensitiveLog, PutObjectRequestFilterSensitiveLog, EncryptionFilterSensitiveLog, S3LocationFilterSensitiveLog, OutputLocationFilterSensitiveLog, RestoreRequestFilterSensitiveLog, RestoreObjectRequestFilterSensitiveLog, SelectObjectContentOutputFilterSensitiveLog, SelectObjectContentRequestFilterSensitiveLog, UploadPartOutputFilterSensitiveLog, UploadPartRequestFilterSensitiveLog, UploadPartCopyOutputFilterSensitiveLog, UploadPartCopyRequestFilterSensitiveLog, WriteGetObjectResponseRequestFilterSensitiveLog;
var init_models_1 = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    init_S3ServiceException();
    ObjectAlreadyInActiveTierError = class extends S3ServiceException {
      constructor(opts) {
        super({
          name: "ObjectAlreadyInActiveTierError",
          $fault: "client",
          ...opts
        });
        this.name = "ObjectAlreadyInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
      }
    };
    (function(SelectObjectContentEventStream2) {
      SelectObjectContentEventStream2.visit = (value, visitor) => {
        if (value.Records !== void 0)
          return visitor.Records(value.Records);
        if (value.Stats !== void 0)
          return visitor.Stats(value.Stats);
        if (value.Progress !== void 0)
          return visitor.Progress(value.Progress);
        if (value.Cont !== void 0)
          return visitor.Cont(value.Cont);
        if (value.End !== void 0)
          return visitor.End(value.End);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
    PutObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
    });
    PutObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
    });
    EncryptionFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KMSKeyId && { KMSKeyId: SENSITIVE_STRING }
    });
    S3LocationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Encryption && { Encryption: EncryptionFilterSensitiveLog(obj.Encryption) }
    });
    OutputLocationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.S3 && { S3: S3LocationFilterSensitiveLog(obj.S3) }
    });
    RestoreRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.OutputLocation && { OutputLocation: OutputLocationFilterSensitiveLog(obj.OutputLocation) }
    });
    RestoreObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.RestoreRequest && { RestoreRequest: RestoreRequestFilterSensitiveLog(obj.RestoreRequest) }
    });
    SelectObjectContentOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Payload && { Payload: "STREAMING_CONTENT" }
    });
    SelectObjectContentRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    UploadPartOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
    UploadPartRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
    });
    UploadPartCopyOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
    UploadPartCopyRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
      ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: SENSITIVE_STRING }
    });
    WriteGetObjectResponseRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
    });
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_AbortMultipartUploadCommand, se_CompleteMultipartUploadCommand, se_CopyObjectCommand, se_CreateBucketCommand, se_CreateMultipartUploadCommand, se_CreateSessionCommand, se_DeleteBucketCommand, se_DeleteBucketAnalyticsConfigurationCommand, se_DeleteBucketCorsCommand, se_DeleteBucketEncryptionCommand, se_DeleteBucketIntelligentTieringConfigurationCommand, se_DeleteBucketInventoryConfigurationCommand, se_DeleteBucketLifecycleCommand, se_DeleteBucketMetricsConfigurationCommand, se_DeleteBucketOwnershipControlsCommand, se_DeleteBucketPolicyCommand, se_DeleteBucketReplicationCommand, se_DeleteBucketTaggingCommand, se_DeleteBucketWebsiteCommand, se_DeleteObjectCommand, se_DeleteObjectsCommand, se_DeleteObjectTaggingCommand, se_DeletePublicAccessBlockCommand, se_GetBucketAccelerateConfigurationCommand, se_GetBucketAclCommand, se_GetBucketAnalyticsConfigurationCommand, se_GetBucketCorsCommand, se_GetBucketEncryptionCommand, se_GetBucketIntelligentTieringConfigurationCommand, se_GetBucketInventoryConfigurationCommand, se_GetBucketLifecycleConfigurationCommand, se_GetBucketLocationCommand, se_GetBucketLoggingCommand, se_GetBucketMetricsConfigurationCommand, se_GetBucketNotificationConfigurationCommand, se_GetBucketOwnershipControlsCommand, se_GetBucketPolicyCommand, se_GetBucketPolicyStatusCommand, se_GetBucketReplicationCommand, se_GetBucketRequestPaymentCommand, se_GetBucketTaggingCommand, se_GetBucketVersioningCommand, se_GetBucketWebsiteCommand, se_GetObjectCommand, se_GetObjectAclCommand, se_GetObjectAttributesCommand, se_GetObjectLegalHoldCommand, se_GetObjectLockConfigurationCommand, se_GetObjectRetentionCommand, se_GetObjectTaggingCommand, se_GetObjectTorrentCommand, se_GetPublicAccessBlockCommand, se_HeadBucketCommand, se_HeadObjectCommand, se_ListBucketAnalyticsConfigurationsCommand, se_ListBucketIntelligentTieringConfigurationsCommand, se_ListBucketInventoryConfigurationsCommand, se_ListBucketMetricsConfigurationsCommand, se_ListBucketsCommand, se_ListDirectoryBucketsCommand, se_ListMultipartUploadsCommand, se_ListObjectsCommand, se_ListObjectsV2Command, se_ListObjectVersionsCommand, se_ListPartsCommand, se_PutBucketAccelerateConfigurationCommand, se_PutBucketAclCommand, se_PutBucketAnalyticsConfigurationCommand, se_PutBucketCorsCommand, se_PutBucketEncryptionCommand, se_PutBucketIntelligentTieringConfigurationCommand, se_PutBucketInventoryConfigurationCommand, se_PutBucketLifecycleConfigurationCommand, se_PutBucketLoggingCommand, se_PutBucketMetricsConfigurationCommand, se_PutBucketNotificationConfigurationCommand, se_PutBucketOwnershipControlsCommand, se_PutBucketPolicyCommand, se_PutBucketReplicationCommand, se_PutBucketRequestPaymentCommand, se_PutBucketTaggingCommand, se_PutBucketVersioningCommand, se_PutBucketWebsiteCommand, se_PutObjectCommand, se_PutObjectAclCommand, se_PutObjectLegalHoldCommand, se_PutObjectLockConfigurationCommand, se_PutObjectRetentionCommand, se_PutObjectTaggingCommand, se_PutPublicAccessBlockCommand, se_RestoreObjectCommand, se_SelectObjectContentCommand, se_UploadPartCommand, se_UploadPartCopyCommand, se_WriteGetObjectResponseCommand, de_AbortMultipartUploadCommand, de_CompleteMultipartUploadCommand, de_CopyObjectCommand, de_CreateBucketCommand, de_CreateMultipartUploadCommand, de_CreateSessionCommand, de_DeleteBucketCommand, de_DeleteBucketAnalyticsConfigurationCommand, de_DeleteBucketCorsCommand, de_DeleteBucketEncryptionCommand, de_DeleteBucketIntelligentTieringConfigurationCommand, de_DeleteBucketInventoryConfigurationCommand, de_DeleteBucketLifecycleCommand, de_DeleteBucketMetricsConfigurationCommand, de_DeleteBucketOwnershipControlsCommand, de_DeleteBucketPolicyCommand, de_DeleteBucketReplicationCommand, de_DeleteBucketTaggingCommand, de_DeleteBucketWebsiteCommand, de_DeleteObjectCommand, de_DeleteObjectsCommand, de_DeleteObjectTaggingCommand, de_DeletePublicAccessBlockCommand, de_GetBucketAccelerateConfigurationCommand, de_GetBucketAclCommand, de_GetBucketAnalyticsConfigurationCommand, de_GetBucketCorsCommand, de_GetBucketEncryptionCommand, de_GetBucketIntelligentTieringConfigurationCommand, de_GetBucketInventoryConfigurationCommand, de_GetBucketLifecycleConfigurationCommand, de_GetBucketLocationCommand, de_GetBucketLoggingCommand, de_GetBucketMetricsConfigurationCommand, de_GetBucketNotificationConfigurationCommand, de_GetBucketOwnershipControlsCommand, de_GetBucketPolicyCommand, de_GetBucketPolicyStatusCommand, de_GetBucketReplicationCommand, de_GetBucketRequestPaymentCommand, de_GetBucketTaggingCommand, de_GetBucketVersioningCommand, de_GetBucketWebsiteCommand, de_GetObjectCommand, de_GetObjectAclCommand, de_GetObjectAttributesCommand, de_GetObjectLegalHoldCommand, de_GetObjectLockConfigurationCommand, de_GetObjectRetentionCommand, de_GetObjectTaggingCommand, de_GetObjectTorrentCommand, de_GetPublicAccessBlockCommand, de_HeadBucketCommand, de_HeadObjectCommand, de_ListBucketAnalyticsConfigurationsCommand, de_ListBucketIntelligentTieringConfigurationsCommand, de_ListBucketInventoryConfigurationsCommand, de_ListBucketMetricsConfigurationsCommand, de_ListBucketsCommand, de_ListDirectoryBucketsCommand, de_ListMultipartUploadsCommand, de_ListObjectsCommand, de_ListObjectsV2Command, de_ListObjectVersionsCommand, de_ListPartsCommand, de_PutBucketAccelerateConfigurationCommand, de_PutBucketAclCommand, de_PutBucketAnalyticsConfigurationCommand, de_PutBucketCorsCommand, de_PutBucketEncryptionCommand, de_PutBucketIntelligentTieringConfigurationCommand, de_PutBucketInventoryConfigurationCommand, de_PutBucketLifecycleConfigurationCommand, de_PutBucketLoggingCommand, de_PutBucketMetricsConfigurationCommand, de_PutBucketNotificationConfigurationCommand, de_PutBucketOwnershipControlsCommand, de_PutBucketPolicyCommand, de_PutBucketReplicationCommand, de_PutBucketRequestPaymentCommand, de_PutBucketTaggingCommand, de_PutBucketVersioningCommand, de_PutBucketWebsiteCommand, de_PutObjectCommand, de_PutObjectAclCommand, de_PutObjectLegalHoldCommand, de_PutObjectLockConfigurationCommand, de_PutObjectRetentionCommand, de_PutObjectTaggingCommand, de_PutPublicAccessBlockCommand, de_RestoreObjectCommand, de_SelectObjectContentCommand, de_UploadPartCommand, de_UploadPartCopyCommand, de_WriteGetObjectResponseCommand, de_CommandError, throwDefaultError2, de_BucketAlreadyExistsRes, de_BucketAlreadyOwnedByYouRes, de_InvalidObjectStateRes, de_NoSuchBucketRes, de_NoSuchKeyRes, de_NoSuchUploadRes, de_NotFoundRes, de_ObjectAlreadyInActiveTierErrorRes, de_ObjectNotInActiveTierErrorRes, de_SelectObjectContentEventStream, de_ContinuationEvent_event, de_EndEvent_event, de_ProgressEvent_event, de_RecordsEvent_event, de_StatsEvent_event, se_AbortIncompleteMultipartUpload, se_AccelerateConfiguration, se_AccessControlPolicy, se_AccessControlTranslation, se_AllowedHeaders, se_AllowedMethods, se_AllowedOrigins, se_AnalyticsAndOperator, se_AnalyticsConfiguration, se_AnalyticsExportDestination, se_AnalyticsFilter, se_AnalyticsS3BucketDestination, se_BucketInfo, se_BucketLifecycleConfiguration, se_BucketLoggingStatus, se_CompletedMultipartUpload, se_CompletedPart, se_CompletedPartList, se_Condition, se_CORSConfiguration, se_CORSRule, se_CORSRules, se_CreateBucketConfiguration, se_CSVInput, se_CSVOutput, se_DefaultRetention, se_Delete, se_DeleteMarkerReplication, se_Destination, se_Encryption, se_EncryptionConfiguration, se_ErrorDocument, se_EventBridgeConfiguration, se_EventList, se_ExistingObjectReplication, se_ExposeHeaders, se_FilterRule, se_FilterRuleList, se_GlacierJobParameters, se_Grant, se_Grantee, se_Grants, se_IndexDocument, se_InputSerialization, se_IntelligentTieringAndOperator, se_IntelligentTieringConfiguration, se_IntelligentTieringFilter, se_InventoryConfiguration, se_InventoryDestination, se_InventoryEncryption, se_InventoryFilter, se_InventoryOptionalFields, se_InventoryS3BucketDestination, se_InventorySchedule, se_JSONInput, se_JSONOutput, se_LambdaFunctionConfiguration, se_LambdaFunctionConfigurationList, se_LifecycleExpiration, se_LifecycleRule, se_LifecycleRuleAndOperator, se_LifecycleRuleFilter, se_LifecycleRules, se_LocationInfo, se_LoggingEnabled, se_MetadataEntry, se_Metrics, se_MetricsAndOperator, se_MetricsConfiguration, se_MetricsFilter, se_NoncurrentVersionExpiration, se_NoncurrentVersionTransition, se_NoncurrentVersionTransitionList, se_NotificationConfiguration, se_NotificationConfigurationFilter, se_ObjectIdentifier, se_ObjectIdentifierList, se_ObjectLockConfiguration, se_ObjectLockLegalHold, se_ObjectLockRetention, se_ObjectLockRule, se_OutputLocation, se_OutputSerialization, se_Owner, se_OwnershipControls, se_OwnershipControlsRule, se_OwnershipControlsRules, se_ParquetInput, se_PartitionedPrefix, se_PublicAccessBlockConfiguration, se_QueueConfiguration, se_QueueConfigurationList, se_Redirect, se_RedirectAllRequestsTo, se_ReplicaModifications, se_ReplicationConfiguration, se_ReplicationRule, se_ReplicationRuleAndOperator, se_ReplicationRuleFilter, se_ReplicationRules, se_ReplicationTime, se_ReplicationTimeValue, se_RequestPaymentConfiguration, se_RequestProgress, se_RestoreRequest, se_RoutingRule, se_RoutingRules, se_S3KeyFilter, se_S3Location, se_ScanRange, se_SelectParameters, se_ServerSideEncryptionByDefault, se_ServerSideEncryptionConfiguration, se_ServerSideEncryptionRule, se_ServerSideEncryptionRules, se_SimplePrefix, se_SourceSelectionCriteria, se_SSEKMS, se_SseKmsEncryptedObjects, se_SSES3, se_StorageClassAnalysis, se_StorageClassAnalysisDataExport, se_Tag, se_Tagging, se_TagSet, se_TargetGrant, se_TargetGrants, se_TargetObjectKeyFormat, se_Tiering, se_TieringList, se_TopicConfiguration, se_TopicConfigurationList, se_Transition, se_TransitionList, se_UserMetadata, se_VersioningConfiguration, se_WebsiteConfiguration, de_AbortIncompleteMultipartUpload, de_AccessControlTranslation, de_AllowedHeaders, de_AllowedMethods, de_AllowedOrigins, de_AnalyticsAndOperator, de_AnalyticsConfiguration, de_AnalyticsConfigurationList, de_AnalyticsExportDestination, de_AnalyticsFilter, de_AnalyticsS3BucketDestination, de_Bucket, de_Buckets, de_Checksum, de_ChecksumAlgorithmList, de_CommonPrefix, de_CommonPrefixList, de_Condition, de_ContinuationEvent, de_CopyObjectResult, de_CopyPartResult, de_CORSRule, de_CORSRules, de_DefaultRetention, de_DeletedObject, de_DeletedObjects, de_DeleteMarkerEntry, de_DeleteMarkerReplication, de_DeleteMarkers, de_Destination, de_EncryptionConfiguration, de_EndEvent, de__Error, de_ErrorDocument, de_Errors, de_EventBridgeConfiguration, de_EventList, de_ExistingObjectReplication, de_ExposeHeaders, de_FilterRule, de_FilterRuleList, de_GetObjectAttributesParts, de_Grant, de_Grantee, de_Grants, de_IndexDocument, de_Initiator, de_IntelligentTieringAndOperator, de_IntelligentTieringConfiguration, de_IntelligentTieringConfigurationList, de_IntelligentTieringFilter, de_InventoryConfiguration, de_InventoryConfigurationList, de_InventoryDestination, de_InventoryEncryption, de_InventoryFilter, de_InventoryOptionalFields, de_InventoryS3BucketDestination, de_InventorySchedule, de_LambdaFunctionConfiguration, de_LambdaFunctionConfigurationList, de_LifecycleExpiration, de_LifecycleRule, de_LifecycleRuleAndOperator, de_LifecycleRuleFilter, de_LifecycleRules, de_LoggingEnabled, de_Metrics, de_MetricsAndOperator, de_MetricsConfiguration, de_MetricsConfigurationList, de_MetricsFilter, de_MultipartUpload, de_MultipartUploadList, de_NoncurrentVersionExpiration, de_NoncurrentVersionTransition, de_NoncurrentVersionTransitionList, de_NotificationConfigurationFilter, de__Object, de_ObjectList, de_ObjectLockConfiguration, de_ObjectLockLegalHold, de_ObjectLockRetention, de_ObjectLockRule, de_ObjectPart, de_ObjectVersion, de_ObjectVersionList, de_Owner, de_OwnershipControls, de_OwnershipControlsRule, de_OwnershipControlsRules, de_Part, de_PartitionedPrefix, de_Parts, de_PartsList, de_PolicyStatus, de_Progress, de_PublicAccessBlockConfiguration, de_QueueConfiguration, de_QueueConfigurationList, de_Redirect, de_RedirectAllRequestsTo, de_ReplicaModifications, de_ReplicationConfiguration, de_ReplicationRule, de_ReplicationRuleAndOperator, de_ReplicationRuleFilter, de_ReplicationRules, de_ReplicationTime, de_ReplicationTimeValue, de_RestoreStatus, de_RoutingRule, de_RoutingRules, de_S3KeyFilter, de_ServerSideEncryptionByDefault, de_ServerSideEncryptionConfiguration, de_ServerSideEncryptionRule, de_ServerSideEncryptionRules, de_SessionCredentials, de_SimplePrefix, de_SourceSelectionCriteria, de_SSEKMS, de_SseKmsEncryptedObjects, de_SSES3, de_Stats, de_StorageClassAnalysis, de_StorageClassAnalysisDataExport, de_Tag, de_TagSet, de_TargetGrant, de_TargetGrants, de_TargetObjectKeyFormat, de_Tiering, de_TieringList, de_TopicConfiguration, de_TopicConfigurationList, de_Transition, de_TransitionList, deserializeMetadata2, collectBodyString3, isSerializableHeaderValue, _A, _AAO, _AC, _ACL, _ACLc, _ACLn, _ACP, _ACT, _ACc, _AD, _AED, _AF, _AH, _AHl, _AI, _AIMU, _AIc, _AKI, _AM, _AMl, _AO, _AOl, _APA, _APAc, _AQRD, _AR, _ARI, _AS, _ASBD, _ASEFF, _ASSEBD, _AT, _Ac, _B, _BAI, _BAS, _BGR, _BI, _BKE, _BLC, _BLCu, _BLN, _BLP, _BLS, _BLT, _BN, _BP, _BPA, _BPP, _BR, _BRy, _BS, _BT, _BVS, _Bu, _C, _CA, _CACL, _CBC, _CC, _CCRC, _CCRCC, _CD, _CDr, _CE, _CF, _CFC, _CL, _CLo, _CM, _CMD, _CMU, _CORSC, _CORSR, _CORSRu, _CP, _CPo, _CR, _CRSBA, _CS, _CSHA, _CSHAh, _CSIM, _CSIMS, _CSINM, _CSIUS, _CSR, _CSSSECA, _CSSSECK, _CSSSECKMD, _CSV, _CSVI, _CSVIn, _CSVO, _CT, _CTo, _CTom, _Ch, _Co, _Cod, _Com, _Con, _D, _DAI, _DE, _DM, _DMR, _DMRS, _DMVI, _DMe, _DN, _DR, _DRe, _Da, _Dat, _De, _Del, _Des, _Desc, _E, _EA, _EBC, _EBO, _EC, _ECn, _ED, _EH, _EHx, _EM, _EODM, _EOR, _EORS, _ERP, _ES, _ESBO, _ESx, _ET, _ETa, _ETn, _ETv, _ETx, _En, _Ena, _End, _Er, _Err, _Ev, _Eve, _Ex, _Exp, _F, _FD, _FHI, _FO, _FR, _FRN, _FRV, _FRi, _Fi, _Fo, _Fr, _G, _GFC, _GJP, _GR, _GRACP, _GW, _GWACP, _Gr, _Gra, _HECRE, _HN, _HRC, _I, _IC, _ICL, _ID, _ID_, _IDn, _IE, _IEn, _IF, _IFn, _IFnv, _II, _IIOV, _IL, _IM, _IMS, _INM, _IOF, _IOV, _IP, _IPA, _IRIP, _IS, _ISBD, _ISn, _IT, _ITAO, _ITAT, _ITC, _ITCL, _ITD, _ITF, _ITI, _ITS, _IUS, _In, _Ini, _JSON, _JSONI, _JSONO, _JSONT, _K, _KC, _KI, _KM, _KMSC, _KMSKI, _KMSMKID, _KPE, _L, _LC, _LE, _LEi, _LFA, _LFC, _LFCa, _LI, _LM, _LNAS, _LP, _LR, _LRAO, _LRF, _LT, _M, _MAO, _MAS, _MC, _MCL, _MD, _MDB, _MDf, _ME, _MF, _MFA, _MFAD, _MI, _MK, _MKe, _MM, _MP, _MS, _MU, _MV, _Me, _Mes, _Mi, _Mo, _N, _NC, _NCF, _NCT, _ND, _NI, _NKM, _NM, _NNV, _NPNM, _NUIM, _NVE, _NVIM, _NVT, _NVTo, _O, _OA, _OC, _OCACL, _OCR, _OF, _OI, _OK, _OL, _OLC, _OLE, _OLEFB, _OLLH, _OLLHS, _OLM, _OLR, _OLRM, _OLRUD, _OLRb, _OO, _OOA, _OOw, _OP, _OS, _OSGT, _OSGTB, _OSLT, _OSLTB, _OSV, _OSb, _OVI, _Ob, _P, _PABC, _PC, _PDS, _PI, _PN, _PNM, _PP, _Pa, _Par, _Parq, _Part, _Pe, _Pr, _Pri, _Q, _QA, _QC, _QCu, _QCuo, _QEC, _QF, _Qu, _R, _RART, _RC, _RCC, _RCD, _RCE, _RCL, _RCT, _RCe, _RD, _RE, _RED, _RKKID, _RKPW, _RKW, _RM, _RMS, _ROP, _RP, _RPB, _RPC, _RPe, _RR, _RRAO, _RRF, _RRS, _RRT, _RRe, _RRes, _RRo, _RRou, _RS, _RSe, _RT, _RTS, _RTV, _RTe, _RUD, _Re, _Red, _Ro, _Ru, _Rul, _S, _SA, _SAK, _SBD, _SC, _SCA, _SCADE, _SCASV, _SCt, _SDV, _SK, _SKEO, _SKEOS, _SKF, _SKe, _SL, _SM, _SOCR, _SP, _SPi, _SR, _SS, _SSC, _SSE, _SSEA, _SSEBD, _SSEC, _SSECA, _SSECK, _SSECKMD, _SSEKMS, _SSEKMSEC, _SSEKMSKI, _SSER, _SSES, _ST, _S_, _Sc, _Se, _Si, _St, _Su, _T, _TA, _TB, _TC, _TCo, _TCop, _TD2, _TG, _TGa, _TOKF, _TP, _TPC, _TS, _TSC, _Ta, _Tag, _Ti, _Tie, _Tier, _Tim, _To, _Top, _Tr, _Tra, _Ty, _U, _UI, _UIM, _UM, _URI, _Up, _V, _VC, _VCe, _VI, _VIM, _Va, _Ve, _WC, _WRL, _Y, _a, _ac, _acl, _ar, _at, _c, _cc, _cd, _ce, _cl, _cl_, _cm, _cr, _ct, _ct_, _d, _de, _e, _en, _et, _eta, _ex, _fo, _i, _im, _ims, _in, _inm, _it, _ius, _km, _l, _lh, _lm, _lo, _log, _lt, _m, _ma, _mdb, _me, _mk, _mp, _mu, _n, _oC, _ol, _p, _pAB, _pN, _pS, _pnm, _pr, _r, _rP, _ra, _rcc, _rcd, _rce, _rcl, _rct, _re, _res, _ret, _s, _sa, _se, _st, _t, _to, _u, _uI, _uim, _v, _vI, _ve, _ver, _vim, _w, _x, _xaa, _xaad, _xaapa, _xaari, _xaas, _xabgr, _xabln, _xablt, _xabole, _xabolt, _xabr, _xaca, _xacc, _xacc_, _xacm, _xacrsba, _xacs, _xacs_, _xacs__, _xacsim, _xacsims, _xacsinm, _xacsius, _xacsm, _xacsr, _xacssseca, _xacssseck, _xacssseckm, _xacsvi, _xadm, _xae, _xaebo, _xafec, _xafem, _xafhar, _xafhcc, _xafhcd, _xafhce, _xafhcl, _xafhcr, _xafhct, _xafhe, _xafhe_, _xafhlm, _xafhxacc, _xafhxacc_, _xafhxacs, _xafhxacs_, _xafhxadm, _xafhxae, _xafhxamm, _xafhxampc, _xafhxaollh, _xafhxaolm, _xafhxaolrud, _xafhxar, _xafhxarc, _xafhxars, _xafhxasc, _xafhxasse, _xafhxasseakki, _xafhxassebke, _xafhxasseca, _xafhxasseckm, _xafhxatc, _xafhxavi, _xafs, _xagfc, _xagr, _xagra, _xagw, _xagwa, _xam, _xamd, _xamm, _xamp, _xampc, _xaoa, _xaollh, _xaolm, _xaolrud, _xaoo, _xaooa, _xapnm, _xar, _xarc, _xarop, _xarp, _xarr, _xars, _xart, _xasc, _xasca, _xasdv, _xasebo, _xasse, _xasseakki, _xassebke, _xassec, _xasseca, _xasseck, _xasseckm, _xat, _xatc, _xatd, _xavi, _xawrl, _xi;
var init_Aws_restXml = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es38();
    init_dist_es39();
    init_dist_es37();
    init_dist_es2();
    init_dist_es15();
    init_models_0();
    init_models_1();
    init_S3ServiceException();
    se_AbortMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "AbortMultipartUpload"],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CompleteMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      let contents;
      if (input.MultipartUpload !== void 0) {
        contents = se_CompletedMultipartUpload(input.MultipartUpload, context);
        contents = contents.n("CompleteMultipartUpload");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CopyObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_xaca]: input[_CA],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CT],
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => dateToUtcString(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => dateToUtcString(input[_CSIUS]).toString()],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xamd]: input[_MD],
        [_xatd]: input[_TD2],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
          () => isSerializableHeaderValue(input[_OLRUD]),
          () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString()
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO],
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {})
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "CopyObject"]
      });
      let body;
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xabole]: [() => isSerializableHeaderValue(input[_OLEFB]), () => input[_OLEFB].toString()],
        [_xaoo]: input[_OO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      let contents;
      if (input.CreateBucketConfiguration !== void 0) {
        contents = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).b(body);
      return b2.build();
    };
    se_CreateMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CT],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
          () => isSerializableHeaderValue(input[_OLRUD]),
          () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString()
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xaca]: input[_CA],
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {})
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_u]: [, ""]
      });
      let body;
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateSessionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xacsm]: input[_SM]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_s]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      b2.m("DELETE").h(headers).b(body);
      return b2.build();
    };
    se_DeleteBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketLifecycleCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "DeleteObject"],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_d]: [, ""]
      });
      let body;
      let contents;
      if (input.Delete !== void 0) {
        contents = se_Delete(input.Delete, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeletePublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAccelerateConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ac]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_acl]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_xi]: [, "GetBucketAnalyticsConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_xi]: [, "GetBucketIntelligentTieringConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_xi]: [, "GetBucketInventoryConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLifecycleConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLocationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_lo]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLoggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_log]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_xi]: [, "GetBucketMetricsConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketNotificationConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_n]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketPolicyStatusCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pS]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketRequestPaymentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_rP]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketVersioningCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_v]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => dateToUtcString(input[_IMS]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "GetObject"],
        [_rcc]: [, input[_RCC]],
        [_rcd]: [, input[_RCD]],
        [_rce]: [, input[_RCE]],
        [_rcl]: [, input[_RCL]],
        [_rct]: [, input[_RCT]],
        [_re]: [() => input.ResponseExpires !== void 0, () => dateToUtcString(input[_RE]).toString()],
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectAttributesCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xamp]: [() => isSerializableHeaderValue(input[_MP]), () => input[_MP].toString()],
        [_xapnm]: input[_PNM],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaoa]: [
          () => isSerializableHeaderValue(input[_OA]),
          () => (input[_OA] || []).map((_entry) => _entry).join(", ")
        ]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_at]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectLegalHoldCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectLockConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ol]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectRetentionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectTorrentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_to]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetPublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_HeadBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      b2.m("HEAD").h(headers).b(body);
      return b2.build();
    };
    se_HeadObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => dateToUtcString(input[_IMS]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
      });
      let body;
      b2.m("HEAD").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketAnalyticsConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_xi]: [, "ListBucketAnalyticsConfigurations"],
        [_ct_]: [, input[_CTo]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketIntelligentTieringConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_xi]: [, "ListBucketIntelligentTieringConfigurations"],
        [_ct_]: [, input[_CTo]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketInventoryConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_xi]: [, "ListBucketInventoryConfigurations"],
        [_ct_]: [, input[_CTo]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketMetricsConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_xi]: [, "ListBucketMetricsConfigurations"],
        [_ct_]: [, input[_CTo]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {
        "content-type": "application/xml"
      };
      b2.bp("/");
      const query = map({
        [_xi]: [, "ListBuckets"]
      });
      let body;
      body = "";
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListDirectoryBucketsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      const query = map({
        [_xi]: [, "ListDirectoryBuckets"],
        [_ct_]: [, input[_CTo]],
        [_mdb]: [() => input.MaxDirectoryBuckets !== void 0, () => input[_MDB].toString()]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListMultipartUploadsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_u]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mu]: [() => input.MaxUploads !== void 0, () => input[_MU].toString()],
        [_pr]: [, input[_P]],
        [_uim]: [, input[_UIM]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [
          () => isSerializableHeaderValue(input[_OOA]),
          () => (input[_OOA] || []).map((_entry) => _entry).join(", ")
        ]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_ma]: [, input[_M]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectsV2Command = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [
          () => isSerializableHeaderValue(input[_OOA]),
          () => (input[_OOA] || []).map((_entry) => _entry).join(", ")
        ]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_lt]: [, "2"],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_ct_]: [, input[_CTo]],
        [_fo]: [() => input.FetchOwner !== void 0, () => input[_FO].toString()],
        [_sa]: [, input[_SA]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectVersionsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
        [_xaooa]: [
          () => isSerializableHeaderValue(input[_OOA]),
          () => (input[_OOA] || []).map((_entry) => _entry).join(", ")
        ]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ver]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_vim]: [, input[_VIM]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListPartsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "ListParts"],
        [_mp]: [() => input.MaxParts !== void 0, () => input[_MP].toString()],
        [_pnm]: [, input[_PNM]],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAccelerateConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ac]: [, ""]
      });
      let body;
      let contents;
      if (input.AccelerateConfiguration !== void 0) {
        contents = se_AccelerateConfiguration(input.AccelerateConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_acl]: [, ""]
      });
      let body;
      let contents;
      if (input.AccessControlPolicy !== void 0) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.AnalyticsConfiguration !== void 0) {
        contents = se_AnalyticsConfiguration(input.AnalyticsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      let contents;
      if (input.CORSConfiguration !== void 0) {
        contents = se_CORSConfiguration(input.CORSConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      let contents;
      if (input.ServerSideEncryptionConfiguration !== void 0) {
        contents = se_ServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {
        "content-type": "application/xml"
      };
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.IntelligentTieringConfiguration !== void 0) {
        contents = se_IntelligentTieringConfiguration(input.IntelligentTieringConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.InventoryConfiguration !== void 0) {
        contents = se_InventoryConfiguration(input.InventoryConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketLifecycleConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      let contents;
      if (input.LifecycleConfiguration !== void 0) {
        contents = se_BucketLifecycleConfiguration(input.LifecycleConfiguration, context);
        contents = contents.n("LifecycleConfiguration");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketLoggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_log]: [, ""]
      });
      let body;
      let contents;
      if (input.BucketLoggingStatus !== void 0) {
        contents = se_BucketLoggingStatus(input.BucketLoggingStatus, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.MetricsConfiguration !== void 0) {
        contents = se_MetricsConfiguration(input.MetricsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketNotificationConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasdv]: [() => isSerializableHeaderValue(input[_SDV]), () => input[_SDV].toString()]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_n]: [, ""]
      });
      let body;
      let contents;
      if (input.NotificationConfiguration !== void 0) {
        contents = se_NotificationConfiguration(input.NotificationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      let contents;
      if (input.OwnershipControls !== void 0) {
        contents = se_OwnershipControls(input.OwnershipControls, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "text/plain",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacrsba]: [() => isSerializableHeaderValue(input[_CRSBA]), () => input[_CRSBA].toString()],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      let contents;
      if (input.Policy !== void 0) {
        contents = input.Policy;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xabolt]: input[_To],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      let contents;
      if (input.ReplicationConfiguration !== void 0) {
        contents = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketRequestPaymentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_rP]: [, ""]
      });
      let body;
      let contents;
      if (input.RequestPaymentConfiguration !== void 0) {
        contents = se_RequestPaymentConfiguration(input.RequestPaymentConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      let contents;
      if (input.Tagging !== void 0) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketVersioningCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xam]: input[_MFA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_v]: [, ""]
      });
      let body;
      let contents;
      if (input.VersioningConfiguration !== void 0) {
        contents = se_VersioningConfiguration(input.VersioningConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      let contents;
      if (input.WebsiteConfiguration !== void 0) {
        contents = se_WebsiteConfiguration(input.WebsiteConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_ct]: input[_CT] || "application/octet-stream",
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
          () => isSerializableHeaderValue(input[_OLRUD]),
          () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString()
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {})
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "PutObject"]
      });
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.AccessControlPolicy !== void 0) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectLegalHoldCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.LegalHold !== void 0) {
        contents = se_ObjectLockLegalHold(input.LegalHold, context);
        contents = contents.n("LegalHold");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectLockConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabolt]: input[_To],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ol]: [, ""]
      });
      let body;
      let contents;
      if (input.ObjectLockConfiguration !== void 0) {
        contents = se_ObjectLockConfiguration(input.ObjectLockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectRetentionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.Retention !== void 0) {
        contents = se_ObjectLockRetention(input.Retention, context);
        contents = contents.n("Retention");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.Tagging !== void 0) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutPublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      let contents;
      if (input.PublicAccessBlockConfiguration !== void 0) {
        contents = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_RestoreObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_res]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.RestoreRequest !== void 0) {
        contents = se_RestoreRequest(input.RestoreRequest, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_SelectObjectContentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_se]: [, ""],
        [_st]: [, "2"]
      });
      let body;
      body = _ve;
      const bn2 = new XmlNode(_SOCR);
      bn2.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      bn2.cc(input, _Ex);
      bn2.cc(input, _ETx);
      if (input[_IS] != null) {
        bn2.c(se_InputSerialization(input[_IS], context).n(_IS));
      }
      if (input[_OS] != null) {
        bn2.c(se_OutputSerialization(input[_OS], context).n(_OS));
      }
      if (input[_RPe] != null) {
        bn2.c(se_RequestProgress(input[_RPe], context).n(_RPe));
      }
      if (input[_SR] != null) {
        bn2.c(se_ScanRange(input[_SR], context).n(_SR));
      }
      body += bn2.toString();
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UploadPartCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "UploadPart"],
        [_pN]: [expectNonNull(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UploadPartCopyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => dateToUtcString(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => dateToUtcString(input[_CSIUS]).toString()],
        [_xacsr]: input[_CSR],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "UploadPartCopy"],
        [_pN]: [expectNonNull(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_WriteGetObjectResponseCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        "content-type": "application/octet-stream",
        [_xarr]: input[_RR],
        [_xart]: input[_RT],
        [_xafs]: [() => isSerializableHeaderValue(input[_SCt]), () => input[_SCt].toString()],
        [_xafec]: input[_EC],
        [_xafem]: input[_EM],
        [_xafhar]: input[_AR],
        [_xafhcc]: input[_CC],
        [_xafhcd]: input[_CD],
        [_xafhce]: input[_CE],
        [_xafhcl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_xafhcr]: input[_CR],
        [_xafhct]: input[_CT],
        [_xafhxacc]: input[_CCRC],
        [_xafhxacc_]: input[_CCRCC],
        [_xafhxacs]: input[_CSHA],
        [_xafhxacs_]: input[_CSHAh],
        [_xafhxadm]: [() => isSerializableHeaderValue(input[_DM]), () => input[_DM].toString()],
        [_xafhe]: input[_ETa],
        [_xafhe_]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xafhxae]: input[_Exp],
        [_xafhlm]: [() => isSerializableHeaderValue(input[_LM]), () => dateToUtcString(input[_LM]).toString()],
        [_xafhxamm]: [() => isSerializableHeaderValue(input[_MM]), () => input[_MM].toString()],
        [_xafhxaolm]: input[_OLM],
        [_xafhxaollh]: input[_OLLHS],
        [_xafhxaolrud]: [
          () => isSerializableHeaderValue(input[_OLRUD]),
          () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString()
        ],
        [_xafhxampc]: [() => isSerializableHeaderValue(input[_PC]), () => input[_PC].toString()],
        [_xafhxars]: input[_RS],
        [_xafhxarc]: input[_RC],
        [_xafhxar]: input[_Re],
        [_xafhxasse]: input[_SSE],
        [_xafhxasseca]: input[_SSECA],
        [_xafhxasseakki]: input[_SSEKMSKI],
        [_xafhxasseckm]: input[_SSECKMD],
        [_xafhxasc]: input[_SC],
        [_xafhxatc]: [() => isSerializableHeaderValue(input[_TC]), () => input[_TC].toString()],
        [_xafhxavi]: input[_VI],
        [_xafhxassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {})
      });
      b2.bp("/WriteGetObjectResponse");
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      let { hostname: resolvedHostname } = await context.endpoint();
      if (context.disableHostPrefix !== true) {
        resolvedHostname = "{RequestRoute}." + resolvedHostname;
        if (input.RequestRoute === void 0) {
          throw new Error("Empty value provided for input host prefix: RequestRoute.");
        }
        resolvedHostname = resolvedHostname.replace("{RequestRoute}", input.RequestRoute);
        if (!isValidHostname(resolvedHostname)) {
          throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
      }
      b2.hn(resolvedHostname);
      b2.m("POST").h(headers).b(body);
      return b2.build();
    };
    de_AbortMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CompleteMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_CCRC] != null) {
        contents[_CCRC] = expectString(data[_CCRC]);
      }
      if (data[_CCRCC] != null) {
        contents[_CCRCC] = expectString(data[_CCRCC]);
      }
      if (data[_CSHA] != null) {
        contents[_CSHA] = expectString(data[_CSHA]);
      }
      if (data[_CSHAh] != null) {
        contents[_CSHAh] = expectString(data[_CSHAh]);
      }
      if (data[_ETa] != null) {
        contents[_ETa] = expectString(data[_ETa]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_L] != null) {
        contents[_L] = expectString(data[_L]);
      }
      return contents;
    };
    de_CopyObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_CSVI]: [, output.headers[_xacsvi]],
        [_VI]: [, output.headers[_xavi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.CopyObjectResult = de_CopyObjectResult(data, context);
      return contents;
    };
    de_CreateBucketCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_L]: [, output.headers[_lo]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CreateMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_AD]: [
          () => void 0 !== output.headers[_xaad],
          () => expectNonNull(parseRfc7231DateTime(output.headers[_xaad]))
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
        [_CA]: [, output.headers[_xaca]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_UI] != null) {
        contents[_UI] = expectString(data[_UI]);
      }
      return contents;
    };
    de_CreateSessionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_C] != null) {
        contents[_C] = de_SessionCredentials(data[_C], context);
      }
      return contents;
    };
    de_DeleteBucketCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketLifecycleCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteObjectCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteObjectsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.Deleted === "") {
        contents[_De] = [];
      } else if (data[_De] != null) {
        contents[_De] = de_DeletedObjects(getArrayIfSingleItem(data[_De]), context);
      }
      if (data.Error === "") {
        contents[_Err] = [];
      } else if (data[_Er] != null) {
        contents[_Err] = de_Errors(getArrayIfSingleItem(data[_Er]), context);
      }
      return contents;
    };
    de_DeleteObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeletePublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_GetBucketAccelerateConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_S] != null) {
        contents[_S] = expectString(data[_S]);
      }
      return contents;
    };
    de_GetBucketAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.AccessControlList === "") {
        contents[_Gr] = [];
      } else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants(getArrayIfSingleItem(data[_ACLc][_G]), context);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      return contents;
    };
    de_GetBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.AnalyticsConfiguration = de_AnalyticsConfiguration(data, context);
      return contents;
    };
    de_GetBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.CORSRule === "") {
        contents[_CORSRu] = [];
      } else if (data[_CORSR] != null) {
        contents[_CORSRu] = de_CORSRules(getArrayIfSingleItem(data[_CORSR]), context);
      }
      return contents;
    };
    de_GetBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ServerSideEncryptionConfiguration = de_ServerSideEncryptionConfiguration(data, context);
      return contents;
    };
    de_GetBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.IntelligentTieringConfiguration = de_IntelligentTieringConfiguration(data, context);
      return contents;
    };
    de_GetBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.InventoryConfiguration = de_InventoryConfiguration(data, context);
      return contents;
    };
    de_GetBucketLifecycleConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.Rule === "") {
        contents[_Rul] = [];
      } else if (data[_Ru] != null) {
        contents[_Rul] = de_LifecycleRules(getArrayIfSingleItem(data[_Ru]), context);
      }
      return contents;
    };
    de_GetBucketLocationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_LC] != null) {
        contents[_LC] = expectString(data[_LC]);
      }
      return contents;
    };
    de_GetBucketLoggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_LE] != null) {
        contents[_LE] = de_LoggingEnabled(data[_LE], context);
      }
      return contents;
    };
    de_GetBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.MetricsConfiguration = de_MetricsConfiguration(data, context);
      return contents;
    };
    de_GetBucketNotificationConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_EBC] != null) {
        contents[_EBC] = de_EventBridgeConfiguration(data[_EBC], context);
      }
      if (data.CloudFunctionConfiguration === "") {
        contents[_LFC] = [];
      } else if (data[_CFC] != null) {
        contents[_LFC] = de_LambdaFunctionConfigurationList(getArrayIfSingleItem(data[_CFC]), context);
      }
      if (data.QueueConfiguration === "") {
        contents[_QCu] = [];
      } else if (data[_QC] != null) {
        contents[_QCu] = de_QueueConfigurationList(getArrayIfSingleItem(data[_QC]), context);
      }
      if (data.TopicConfiguration === "") {
        contents[_TCop] = [];
      } else if (data[_TCo] != null) {
        contents[_TCop] = de_TopicConfigurationList(getArrayIfSingleItem(data[_TCo]), context);
      }
      return contents;
    };
    de_GetBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.OwnershipControls = de_OwnershipControls(data, context);
      return contents;
    };
    de_GetBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = await collectBodyString3(output.body, context);
      contents.Policy = expectString(data);
      return contents;
    };
    de_GetBucketPolicyStatusCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.PolicyStatus = de_PolicyStatus(data, context);
      return contents;
    };
    de_GetBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ReplicationConfiguration = de_ReplicationConfiguration(data, context);
      return contents;
    };
    de_GetBucketRequestPaymentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_Pa] != null) {
        contents[_Pa] = expectString(data[_Pa]);
      }
      return contents;
    };
    de_GetBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.TagSet === "") {
        contents[_TS] = [];
      } else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet(getArrayIfSingleItem(data[_TS][_Ta]), context);
      }
      return contents;
    };
    de_GetBucketVersioningCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_MDf] != null) {
        contents[_MFAD] = expectString(data[_MDf]);
      }
      if (data[_S] != null) {
        contents[_S] = expectString(data[_S]);
      }
      return contents;
    };
    de_GetBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_ED] != null) {
        contents[_ED] = de_ErrorDocument(data[_ED], context);
      }
      if (data[_ID] != null) {
        contents[_ID] = de_IndexDocument(data[_ID], context);
      }
      if (data[_RART] != null) {
        contents[_RART] = de_RedirectAllRequestsTo(data[_RART], context);
      }
      if (data.RoutingRules === "") {
        contents[_RRo] = [];
      } else if (data[_RRo] != null && data[_RRo][_RRou] != null) {
        contents[_RRo] = de_RoutingRules(getArrayIfSingleItem(data[_RRo][_RRou]), context);
      }
      return contents;
    };
    de_GetObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CR]: [, output.headers[_cr]],
        [_CT]: [, output.headers[_ct]],
        [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
        [_ES]: [, output.headers[_ex]],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RS]: [, output.headers[_xars]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
        [_TC]: [() => void 0 !== output.headers[_xatc], () => strictParseInt32(output.headers[_xatc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
          () => void 0 !== output.headers[_xaolrud],
          () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
          ,
          Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
            acc[header.substring(11)] = output.headers[header];
            return acc;
          }, {})
        ]
      });
      const data = output.body;
      context.sdkStreamMixin(data);
      contents.Body = data;
      return contents;
    };
    de_GetObjectAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.AccessControlList === "") {
        contents[_Gr] = [];
      } else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants(getArrayIfSingleItem(data[_ACLc][_G]), context);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      return contents;
    };
    de_GetObjectAttributesCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_Ch] != null) {
        contents[_Ch] = de_Checksum(data[_Ch], context);
      }
      if (data[_ETa] != null) {
        contents[_ETa] = expectString(data[_ETa]);
      }
      if (data[_OP] != null) {
        contents[_OP] = de_GetObjectAttributesParts(data[_OP], context);
      }
      if (data[_OSb] != null) {
        contents[_OSb] = strictParseLong(data[_OSb]);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      return contents;
    };
    de_GetObjectLegalHoldCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.LegalHold = de_ObjectLockLegalHold(data, context);
      return contents;
    };
    de_GetObjectLockConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ObjectLockConfiguration = de_ObjectLockConfiguration(data, context);
      return contents;
    };
    de_GetObjectRetentionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.Retention = de_ObjectLockRetention(data, context);
      return contents;
    };
    de_GetObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.TagSet === "") {
        contents[_TS] = [];
      } else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet(getArrayIfSingleItem(data[_TS][_Ta]), context);
      }
      return contents;
    };
    de_GetObjectTorrentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = output.body;
      context.sdkStreamMixin(data);
      contents.Body = data;
      return contents;
    };
    de_GetPublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data, context);
      return contents;
    };
    de_HeadBucketCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_BLT]: [, output.headers[_xablt]],
        [_BLN]: [, output.headers[_xabln]],
        [_BR]: [, output.headers[_xabr]],
        [_APA]: [() => void 0 !== output.headers[_xaapa], () => parseBoolean(output.headers[_xaapa])]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_HeadObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_AS]: [, output.headers[_xaas]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_ETa]: [, output.headers[_eta]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CT]: [, output.headers[_ct]],
        [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
        [_ES]: [, output.headers[_ex]],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RS]: [, output.headers[_xars]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
          () => void 0 !== output.headers[_xaolrud],
          () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
          ,
          Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
            acc[header.substring(11)] = output.headers[header];
            return acc;
          }, {})
        ]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_ListBucketAnalyticsConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.AnalyticsConfiguration === "") {
        contents[_ACLn] = [];
      } else if (data[_AC] != null) {
        contents[_ACLn] = de_AnalyticsConfigurationList(getArrayIfSingleItem(data[_AC]), context);
      }
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketIntelligentTieringConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      if (data.IntelligentTieringConfiguration === "") {
        contents[_ITCL] = [];
      } else if (data[_ITC] != null) {
        contents[_ITCL] = de_IntelligentTieringConfigurationList(getArrayIfSingleItem(data[_ITC]), context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketInventoryConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      if (data.InventoryConfiguration === "") {
        contents[_ICL] = [];
      } else if (data[_IC] != null) {
        contents[_ICL] = de_InventoryConfigurationList(getArrayIfSingleItem(data[_IC]), context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketMetricsConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data.MetricsConfiguration === "") {
        contents[_MCL] = [];
      } else if (data[_MC] != null) {
        contents[_MCL] = de_MetricsConfigurationList(getArrayIfSingleItem(data[_MC]), context);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.Buckets === "") {
        contents[_Bu] = [];
      } else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets(getArrayIfSingleItem(data[_Bu][_B]), context);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      return contents;
    };
    de_ListDirectoryBucketsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.Buckets === "") {
        contents[_Bu] = [];
      } else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets(getArrayIfSingleItem(data[_Bu][_B]), context);
      }
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      return contents;
    };
    de_ListMultipartUploadsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data.CommonPrefixes === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KM] != null) {
        contents[_KM] = expectString(data[_KM]);
      }
      if (data[_MU] != null) {
        contents[_MU] = strictParseInt32(data[_MU]);
      }
      if (data[_NKM] != null) {
        contents[_NKM] = expectString(data[_NKM]);
      }
      if (data[_NUIM] != null) {
        contents[_NUIM] = expectString(data[_NUIM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_UIM] != null) {
        contents[_UIM] = expectString(data[_UIM]);
      }
      if (data.Upload === "") {
        contents[_Up] = [];
      } else if (data[_U] != null) {
        contents[_Up] = de_MultipartUploadList(getArrayIfSingleItem(data[_U]), context);
      }
      return contents;
    };
    de_ListObjectsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.CommonPrefixes === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (data.Contents === "") {
        contents[_Co] = [];
      } else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList(getArrayIfSingleItem(data[_Co]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_M] != null) {
        contents[_M] = expectString(data[_M]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NM] != null) {
        contents[_NM] = expectString(data[_NM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      return contents;
    };
    de_ListObjectsV2Command = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.CommonPrefixes === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (data.Contents === "") {
        contents[_Co] = [];
      } else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList(getArrayIfSingleItem(data[_Co]), context);
      }
      if (data[_CTo] != null) {
        contents[_CTo] = expectString(data[_CTo]);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KC] != null) {
        contents[_KC] = strictParseInt32(data[_KC]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_SA] != null) {
        contents[_SA] = expectString(data[_SA]);
      }
      return contents;
    };
    de_ListObjectVersionsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data.CommonPrefixes === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (data.DeleteMarker === "") {
        contents[_DMe] = [];
      } else if (data[_DM] != null) {
        contents[_DMe] = de_DeleteMarkers(getArrayIfSingleItem(data[_DM]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KM] != null) {
        contents[_KM] = expectString(data[_KM]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NKM] != null) {
        contents[_NKM] = expectString(data[_NKM]);
      }
      if (data[_NVIM] != null) {
        contents[_NVIM] = expectString(data[_NVIM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_VIM] != null) {
        contents[_VIM] = expectString(data[_VIM]);
      }
      if (data.Version === "") {
        contents[_Ve] = [];
      } else if (data[_V] != null) {
        contents[_Ve] = de_ObjectVersionList(getArrayIfSingleItem(data[_V]), context);
      }
      return contents;
    };
    de_ListPartsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_AD]: [
          () => void 0 !== output.headers[_xaad],
          () => expectNonNull(parseRfc7231DateTime(output.headers[_xaad]))
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_CA] != null) {
        contents[_CA] = expectString(data[_CA]);
      }
      if (data[_In] != null) {
        contents[_In] = de_Initiator(data[_In], context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_MP] != null) {
        contents[_MP] = strictParseInt32(data[_MP]);
      }
      if (data[_NPNM] != null) {
        contents[_NPNM] = expectString(data[_NPNM]);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      if (data[_PNM] != null) {
        contents[_PNM] = expectString(data[_PNM]);
      }
      if (data.Part === "") {
        contents[_Part] = [];
      } else if (data[_Par] != null) {
        contents[_Part] = de_Parts(getArrayIfSingleItem(data[_Par]), context);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      if (data[_UI] != null) {
        contents[_UI] = expectString(data[_UI]);
      }
      return contents;
    };
    de_PutBucketAccelerateConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketLifecycleConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketLoggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketNotificationConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketRequestPaymentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketVersioningCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectLegalHoldCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectLockConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectRetentionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutPublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_RestoreObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]],
        [_ROP]: [, output.headers[_xarop]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_SelectObjectContentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = output.body;
      contents.Payload = de_SelectObjectContentEventStream(data, context);
      return contents;
    };
    de_UploadPartCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_SSE]: [, output.headers[_xasse]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_UploadPartCopyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_CSVI]: [, output.headers[_xacsvi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.CopyPartResult = de_CopyPartResult(data, context);
      return contents;
    };
    de_WriteGetObjectResponseCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseXmlErrorBody(output.body, context)
      };
      const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "NoSuchUpload":
        case "com.amazonaws.s3#NoSuchUpload":
          throw await de_NoSuchUploadRes(parsedOutput, context);
        case "ObjectNotInActiveTierError":
        case "com.amazonaws.s3#ObjectNotInActiveTierError":
          throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
        case "BucketAlreadyExists":
        case "com.amazonaws.s3#BucketAlreadyExists":
          throw await de_BucketAlreadyExistsRes(parsedOutput, context);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
          throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
          throw await de_NoSuchBucketRes(parsedOutput, context);
        case "InvalidObjectState":
        case "com.amazonaws.s3#InvalidObjectState":
          throw await de_InvalidObjectStateRes(parsedOutput, context);
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
          throw await de_NoSuchKeyRes(parsedOutput, context);
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
          throw await de_NotFoundRes(parsedOutput, context);
        case "ObjectAlreadyInActiveTierError":
        case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
          throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError2({
            output,
            parsedBody,
            errorCode
          });
      }
    };
    throwDefaultError2 = withBaseException(S3ServiceException);
    de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new BucketAlreadyExists({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new BucketAlreadyOwnedByYou({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_InvalidObjectStateRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      if (data[_AT] != null) {
        contents[_AT] = expectString(data[_AT]);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      const exception = new InvalidObjectState({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchBucketRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchBucket({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchKeyRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchKey({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchUploadRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchUpload({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NotFoundRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NotFound({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new ObjectAlreadyInActiveTierError({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new ObjectNotInActiveTierError({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_SelectObjectContentEventStream = (output, context) => {
      return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["Records"] != null) {
          return {
            Records: await de_RecordsEvent_event(event["Records"], context)
          };
        }
        if (event["Stats"] != null) {
          return {
            Stats: await de_StatsEvent_event(event["Stats"], context)
          };
        }
        if (event["Progress"] != null) {
          return {
            Progress: await de_ProgressEvent_event(event["Progress"], context)
          };
        }
        if (event["Cont"] != null) {
          return {
            Cont: await de_ContinuationEvent_event(event["Cont"], context)
          };
        }
        if (event["End"] != null) {
          return {
            End: await de_EndEvent_event(event["End"], context)
          };
        }
        return { $unknown: output };
      });
    };
    de_ContinuationEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      Object.assign(contents, de_ContinuationEvent(data, context));
      return contents;
    };
    de_EndEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      Object.assign(contents, de_EndEvent(data, context));
      return contents;
    };
    de_ProgressEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      contents.Details = de_Progress(data, context);
      return contents;
    };
    de_RecordsEvent_event = async (output, context) => {
      const contents = {};
      contents.Payload = output.body;
      return contents;
    };
    de_StatsEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      contents.Details = de_Stats(data, context);
      return contents;
    };
    se_AbortIncompleteMultipartUpload = (input, context) => {
      const bn2 = new XmlNode(_AIMU);
      if (input[_DAI] != null) {
        bn2.c(XmlNode.of(_DAI, String(input[_DAI])).n(_DAI));
      }
      return bn2;
    };
    se_AccelerateConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ACc);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_BAS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_AccessControlPolicy = (input, context) => {
      const bn2 = new XmlNode(_ACP);
      bn2.lc(input, "Grants", "AccessControlList", () => se_Grants(input[_Gr], context));
      if (input[_O] != null) {
        bn2.c(se_Owner(input[_O], context).n(_O));
      }
      return bn2;
    };
    se_AccessControlTranslation = (input, context) => {
      const bn2 = new XmlNode(_ACT);
      if (input[_O] != null) {
        bn2.c(XmlNode.of(_OOw, input[_O]).n(_O));
      }
      return bn2;
    };
    se_AllowedHeaders = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AH, entry);
        return n2.n(_me);
      });
    };
    se_AllowedMethods = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AM, entry);
        return n2.n(_me);
      });
    };
    se_AllowedOrigins = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AO, entry);
        return n2.n(_me);
      });
    };
    se_AnalyticsAndOperator = (input, context) => {
      const bn2 = new XmlNode(_AAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_AnalyticsConfiguration = (input, context) => {
      const bn2 = new XmlNode(_AC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_AI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_AnalyticsFilter(input[_F], context).n(_F));
      }
      if (input[_SCA] != null) {
        bn2.c(se_StorageClassAnalysis(input[_SCA], context).n(_SCA));
      }
      return bn2;
    };
    se_AnalyticsExportDestination = (input, context) => {
      const bn2 = new XmlNode(_AED);
      if (input[_SBD] != null) {
        bn2.c(se_AnalyticsS3BucketDestination(input[_SBD], context).n(_SBD));
      }
      return bn2;
    };
    se_AnalyticsFilter = (input, context) => {
      const bn2 = new XmlNode(_AF);
      AnalyticsFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_AnalyticsAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_AnalyticsS3BucketDestination = (input, context) => {
      const bn2 = new XmlNode(_ASBD);
      if (input[_Fo] != null) {
        bn2.c(XmlNode.of(_ASEFF, input[_Fo]).n(_Fo));
      }
      if (input[_BAI] != null) {
        bn2.c(XmlNode.of(_AIc, input[_BAI]).n(_BAI));
      }
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      bn2.cc(input, _P);
      return bn2;
    };
    se_BucketInfo = (input, context) => {
      const bn2 = new XmlNode(_BI);
      bn2.cc(input, _DR);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_BT, input[_Ty]).n(_Ty));
      }
      return bn2;
    };
    se_BucketLifecycleConfiguration = (input, context) => {
      const bn2 = new XmlNode(_BLC);
      bn2.l(input, "Rules", "Rule", () => se_LifecycleRules(input[_Rul], context));
      return bn2;
    };
    se_BucketLoggingStatus = (input, context) => {
      const bn2 = new XmlNode(_BLS);
      if (input[_LE] != null) {
        bn2.c(se_LoggingEnabled(input[_LE], context).n(_LE));
      }
      return bn2;
    };
    se_CompletedMultipartUpload = (input, context) => {
      const bn2 = new XmlNode(_CMU);
      bn2.l(input, "Parts", "Part", () => se_CompletedPartList(input[_Part], context));
      return bn2;
    };
    se_CompletedPart = (input, context) => {
      const bn2 = new XmlNode(_CPo);
      bn2.cc(input, _ETa);
      bn2.cc(input, _CCRC);
      bn2.cc(input, _CCRCC);
      bn2.cc(input, _CSHA);
      bn2.cc(input, _CSHAh);
      if (input[_PN] != null) {
        bn2.c(XmlNode.of(_PN, String(input[_PN])).n(_PN));
      }
      return bn2;
    };
    se_CompletedPartList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_CompletedPart(entry, context);
        return n2.n(_me);
      });
    };
    se_Condition = (input, context) => {
      const bn2 = new XmlNode(_Con);
      bn2.cc(input, _HECRE);
      bn2.cc(input, _KPE);
      return bn2;
    };
    se_CORSConfiguration = (input, context) => {
      const bn2 = new XmlNode(_CORSC);
      bn2.l(input, "CORSRules", "CORSRule", () => se_CORSRules(input[_CORSRu], context));
      return bn2;
    };
    se_CORSRule = (input, context) => {
      const bn2 = new XmlNode(_CORSR);
      bn2.cc(input, _ID_);
      bn2.l(input, "AllowedHeaders", "AllowedHeader", () => se_AllowedHeaders(input[_AHl], context));
      bn2.l(input, "AllowedMethods", "AllowedMethod", () => se_AllowedMethods(input[_AMl], context));
      bn2.l(input, "AllowedOrigins", "AllowedOrigin", () => se_AllowedOrigins(input[_AOl], context));
      bn2.l(input, "ExposeHeaders", "ExposeHeader", () => se_ExposeHeaders(input[_EH], context));
      if (input[_MAS] != null) {
        bn2.c(XmlNode.of(_MAS, String(input[_MAS])).n(_MAS));
      }
      return bn2;
    };
    se_CORSRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_CORSRule(entry, context);
        return n2.n(_me);
      });
    };
    se_CreateBucketConfiguration = (input, context) => {
      const bn2 = new XmlNode(_CBC);
      if (input[_LC] != null) {
        bn2.c(XmlNode.of(_BLCu, input[_LC]).n(_LC));
      }
      if (input[_L] != null) {
        bn2.c(se_LocationInfo(input[_L], context).n(_L));
      }
      if (input[_B] != null) {
        bn2.c(se_BucketInfo(input[_B], context).n(_B));
      }
      return bn2;
    };
    se_CSVInput = (input, context) => {
      const bn2 = new XmlNode(_CSVIn);
      bn2.cc(input, _FHI);
      bn2.cc(input, _Com);
      bn2.cc(input, _QEC);
      bn2.cc(input, _RD);
      bn2.cc(input, _FD);
      bn2.cc(input, _QCuo);
      if (input[_AQRD] != null) {
        bn2.c(XmlNode.of(_AQRD, String(input[_AQRD])).n(_AQRD));
      }
      return bn2;
    };
    se_CSVOutput = (input, context) => {
      const bn2 = new XmlNode(_CSVO);
      bn2.cc(input, _QF);
      bn2.cc(input, _QEC);
      bn2.cc(input, _RD);
      bn2.cc(input, _FD);
      bn2.cc(input, _QCuo);
      return bn2;
    };
    se_DefaultRetention = (input, context) => {
      const bn2 = new XmlNode(_DRe);
      if (input[_Mo] != null) {
        bn2.c(XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_Y] != null) {
        bn2.c(XmlNode.of(_Y, String(input[_Y])).n(_Y));
      }
      return bn2;
    };
    se_Delete = (input, context) => {
      const bn2 = new XmlNode(_Del);
      bn2.l(input, "Objects", "Object", () => se_ObjectIdentifierList(input[_Ob], context));
      if (input[_Q] != null) {
        bn2.c(XmlNode.of(_Q, String(input[_Q])).n(_Q));
      }
      return bn2;
    };
    se_DeleteMarkerReplication = (input, context) => {
      const bn2 = new XmlNode(_DMR);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_DMRS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_Destination = (input, context) => {
      const bn2 = new XmlNode(_Des);
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      if (input[_Ac] != null) {
        bn2.c(XmlNode.of(_AIc, input[_Ac]).n(_Ac));
      }
      bn2.cc(input, _SC);
      if (input[_ACT] != null) {
        bn2.c(se_AccessControlTranslation(input[_ACT], context).n(_ACT));
      }
      if (input[_ECn] != null) {
        bn2.c(se_EncryptionConfiguration(input[_ECn], context).n(_ECn));
      }
      if (input[_RTe] != null) {
        bn2.c(se_ReplicationTime(input[_RTe], context).n(_RTe));
      }
      if (input[_Me] != null) {
        bn2.c(se_Metrics(input[_Me], context).n(_Me));
      }
      return bn2;
    };
    se_Encryption = (input, context) => {
      const bn2 = new XmlNode(_En);
      if (input[_ETn] != null) {
        bn2.c(XmlNode.of(_SSE, input[_ETn]).n(_ETn));
      }
      if (input[_KMSKI] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KMSKI]).n(_KMSKI));
      }
      bn2.cc(input, _KMSC);
      return bn2;
    };
    se_EncryptionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ECn);
      bn2.cc(input, _RKKID);
      return bn2;
    };
    se_ErrorDocument = (input, context) => {
      const bn2 = new XmlNode(_ED);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      return bn2;
    };
    se_EventBridgeConfiguration = (input, context) => {
      const bn2 = new XmlNode(_EBC);
      return bn2;
    };
    se_EventList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_Ev, entry);
        return n2.n(_me);
      });
    };
    se_ExistingObjectReplication = (input, context) => {
      const bn2 = new XmlNode(_EOR);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_EORS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ExposeHeaders = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_EHx, entry);
        return n2.n(_me);
      });
    };
    se_FilterRule = (input, context) => {
      const bn2 = new XmlNode(_FR);
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_FRN, input[_N]).n(_N));
      }
      if (input[_Va] != null) {
        bn2.c(XmlNode.of(_FRV, input[_Va]).n(_Va));
      }
      return bn2;
    };
    se_FilterRuleList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_FilterRule(entry, context);
        return n2.n(_me);
      });
    };
    se_GlacierJobParameters = (input, context) => {
      const bn2 = new XmlNode(_GJP);
      bn2.cc(input, _Ti);
      return bn2;
    };
    se_Grant = (input, context) => {
      const bn2 = new XmlNode(_G);
      if (input[_Gra] != null) {
        const n2 = se_Grantee(input[_Gra], context).n(_Gra);
        n2.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn2.c(n2);
      }
      bn2.cc(input, _Pe);
      return bn2;
    };
    se_Grantee = (input, context) => {
      const bn2 = new XmlNode(_Gra);
      bn2.cc(input, _DN);
      bn2.cc(input, _EA);
      bn2.cc(input, _ID_);
      bn2.cc(input, _URI);
      bn2.a("xsi:type", input[_Ty]);
      return bn2;
    };
    se_Grants = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Grant(entry, context);
        return n2.n(_G);
      });
    };
    se_IndexDocument = (input, context) => {
      const bn2 = new XmlNode(_ID);
      bn2.cc(input, _Su);
      return bn2;
    };
    se_InputSerialization = (input, context) => {
      const bn2 = new XmlNode(_IS);
      if (input[_CSV] != null) {
        bn2.c(se_CSVInput(input[_CSV], context).n(_CSV));
      }
      bn2.cc(input, _CTom);
      if (input[_JSON] != null) {
        bn2.c(se_JSONInput(input[_JSON], context).n(_JSON));
      }
      if (input[_Parq] != null) {
        bn2.c(se_ParquetInput(input[_Parq], context).n(_Parq));
      }
      return bn2;
    };
    se_IntelligentTieringAndOperator = (input, context) => {
      const bn2 = new XmlNode(_ITAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_IntelligentTieringConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ITC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_ITI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_IntelligentTieringFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_ITS, input[_S]).n(_S));
      }
      bn2.l(input, "Tierings", "Tiering", () => se_TieringList(input[_Tie], context));
      return bn2;
    };
    se_IntelligentTieringFilter = (input, context) => {
      const bn2 = new XmlNode(_ITF);
      bn2.cc(input, _P);
      if (input[_Ta] != null) {
        bn2.c(se_Tag(input[_Ta], context).n(_Ta));
      }
      if (input[_A] != null) {
        bn2.c(se_IntelligentTieringAndOperator(input[_A], context).n(_A));
      }
      return bn2;
    };
    se_InventoryConfiguration = (input, context) => {
      const bn2 = new XmlNode(_IC);
      if (input[_Des] != null) {
        bn2.c(se_InventoryDestination(input[_Des], context).n(_Des));
      }
      if (input[_IE] != null) {
        bn2.c(XmlNode.of(_IE, String(input[_IE])).n(_IE));
      }
      if (input[_F] != null) {
        bn2.c(se_InventoryFilter(input[_F], context).n(_F));
      }
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_II, input[_I]).n(_I));
      }
      if (input[_IOV] != null) {
        bn2.c(XmlNode.of(_IIOV, input[_IOV]).n(_IOV));
      }
      bn2.lc(input, "OptionalFields", "OptionalFields", () => se_InventoryOptionalFields(input[_OF], context));
      if (input[_Sc] != null) {
        bn2.c(se_InventorySchedule(input[_Sc], context).n(_Sc));
      }
      return bn2;
    };
    se_InventoryDestination = (input, context) => {
      const bn2 = new XmlNode(_IDn);
      if (input[_SBD] != null) {
        bn2.c(se_InventoryS3BucketDestination(input[_SBD], context).n(_SBD));
      }
      return bn2;
    };
    se_InventoryEncryption = (input, context) => {
      const bn2 = new XmlNode(_IEn);
      if (input[_SSES] != null) {
        bn2.c(se_SSES3(input[_SSES], context).n(_SS));
      }
      if (input[_SSEKMS] != null) {
        bn2.c(se_SSEKMS(input[_SSEKMS], context).n(_SK));
      }
      return bn2;
    };
    se_InventoryFilter = (input, context) => {
      const bn2 = new XmlNode(_IF);
      bn2.cc(input, _P);
      return bn2;
    };
    se_InventoryOptionalFields = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_IOF, entry);
        return n2.n(_Fi);
      });
    };
    se_InventoryS3BucketDestination = (input, context) => {
      const bn2 = new XmlNode(_ISBD);
      bn2.cc(input, _AIc);
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      if (input[_Fo] != null) {
        bn2.c(XmlNode.of(_IFn, input[_Fo]).n(_Fo));
      }
      bn2.cc(input, _P);
      if (input[_En] != null) {
        bn2.c(se_InventoryEncryption(input[_En], context).n(_En));
      }
      return bn2;
    };
    se_InventorySchedule = (input, context) => {
      const bn2 = new XmlNode(_ISn);
      if (input[_Fr] != null) {
        bn2.c(XmlNode.of(_IFnv, input[_Fr]).n(_Fr));
      }
      return bn2;
    };
    se_JSONInput = (input, context) => {
      const bn2 = new XmlNode(_JSONI);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_JSONT, input[_Ty]).n(_Ty));
      }
      return bn2;
    };
    se_JSONOutput = (input, context) => {
      const bn2 = new XmlNode(_JSONO);
      bn2.cc(input, _RD);
      return bn2;
    };
    se_LambdaFunctionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_LFCa);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_LFA] != null) {
        bn2.c(XmlNode.of(_LFA, input[_LFA]).n(_CF));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_LambdaFunctionConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_LambdaFunctionConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_LifecycleExpiration = (input, context) => {
      const bn2 = new XmlNode(_LEi);
      if (input[_Dat] != null) {
        bn2.c(XmlNode.of(_Dat, (input[_Dat].toISOString().split(".")[0] + "Z").toString()).n(_Dat));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_EODM] != null) {
        bn2.c(XmlNode.of(_EODM, String(input[_EODM])).n(_EODM));
      }
      return bn2;
    };
    se_LifecycleRule = (input, context) => {
      const bn2 = new XmlNode(_LR);
      if (input[_Exp] != null) {
        bn2.c(se_LifecycleExpiration(input[_Exp], context).n(_Exp));
      }
      bn2.cc(input, _ID_);
      bn2.cc(input, _P);
      if (input[_F] != null) {
        bn2.c(se_LifecycleRuleFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_ESx, input[_S]).n(_S));
      }
      bn2.l(input, "Transitions", "Transition", () => se_TransitionList(input[_Tr], context));
      bn2.l(input, "NoncurrentVersionTransitions", "NoncurrentVersionTransition", () => se_NoncurrentVersionTransitionList(input[_NVT], context));
      if (input[_NVE] != null) {
        bn2.c(se_NoncurrentVersionExpiration(input[_NVE], context).n(_NVE));
      }
      if (input[_AIMU] != null) {
        bn2.c(se_AbortIncompleteMultipartUpload(input[_AIMU], context).n(_AIMU));
      }
      return bn2;
    };
    se_LifecycleRuleAndOperator = (input, context) => {
      const bn2 = new XmlNode(_LRAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      if (input[_OSGT] != null) {
        bn2.c(XmlNode.of(_OSGTB, String(input[_OSGT])).n(_OSGT));
      }
      if (input[_OSLT] != null) {
        bn2.c(XmlNode.of(_OSLTB, String(input[_OSLT])).n(_OSLT));
      }
      return bn2;
    };
    se_LifecycleRuleFilter = (input, context) => {
      const bn2 = new XmlNode(_LRF);
      LifecycleRuleFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        ObjectSizeGreaterThan: (value) => {
          if (input[_OSGT] != null) {
            bn2.c(XmlNode.of(_OSGTB, String(value)).n(_OSGT));
          }
        },
        ObjectSizeLessThan: (value) => {
          if (input[_OSLT] != null) {
            bn2.c(XmlNode.of(_OSLTB, String(value)).n(_OSLT));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_LifecycleRuleAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_LifecycleRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_LifecycleRule(entry, context);
        return n2.n(_me);
      });
    };
    se_LocationInfo = (input, context) => {
      const bn2 = new XmlNode(_LI);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_LT, input[_Ty]).n(_Ty));
      }
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_LNAS, input[_N]).n(_N));
      }
      return bn2;
    };
    se_LoggingEnabled = (input, context) => {
      const bn2 = new XmlNode(_LE);
      bn2.cc(input, _TB);
      bn2.lc(input, "TargetGrants", "TargetGrants", () => se_TargetGrants(input[_TG], context));
      bn2.cc(input, _TP);
      if (input[_TOKF] != null) {
        bn2.c(se_TargetObjectKeyFormat(input[_TOKF], context).n(_TOKF));
      }
      return bn2;
    };
    se_MetadataEntry = (input, context) => {
      const bn2 = new XmlNode(_ME);
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_MKe, input[_N]).n(_N));
      }
      if (input[_Va] != null) {
        bn2.c(XmlNode.of(_MV, input[_Va]).n(_Va));
      }
      return bn2;
    };
    se_Metrics = (input, context) => {
      const bn2 = new XmlNode(_Me);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_MS, input[_S]).n(_S));
      }
      if (input[_ETv] != null) {
        bn2.c(se_ReplicationTimeValue(input[_ETv], context).n(_ETv));
      }
      return bn2;
    };
    se_MetricsAndOperator = (input, context) => {
      const bn2 = new XmlNode(_MAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      bn2.cc(input, _APAc);
      return bn2;
    };
    se_MetricsConfiguration = (input, context) => {
      const bn2 = new XmlNode(_MC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_MI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_MetricsFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_MetricsFilter = (input, context) => {
      const bn2 = new XmlNode(_MF);
      MetricsFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        AccessPointArn: (value) => {
          if (input[_APAc] != null) {
            bn2.c(XmlNode.of(_APAc, value).n(_APAc));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_MetricsAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_NoncurrentVersionExpiration = (input, context) => {
      const bn2 = new XmlNode(_NVE);
      if (input[_ND] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_ND])).n(_ND));
      }
      if (input[_NNV] != null) {
        bn2.c(XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
      }
      return bn2;
    };
    se_NoncurrentVersionTransition = (input, context) => {
      const bn2 = new XmlNode(_NVTo);
      if (input[_ND] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_ND])).n(_ND));
      }
      if (input[_SC] != null) {
        bn2.c(XmlNode.of(_TSC, input[_SC]).n(_SC));
      }
      if (input[_NNV] != null) {
        bn2.c(XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
      }
      return bn2;
    };
    se_NoncurrentVersionTransitionList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_NoncurrentVersionTransition(entry, context);
        return n2.n(_me);
      });
    };
    se_NotificationConfiguration = (input, context) => {
      const bn2 = new XmlNode(_NC);
      bn2.l(input, "TopicConfigurations", "TopicConfiguration", () => se_TopicConfigurationList(input[_TCop], context));
      bn2.l(input, "QueueConfigurations", "QueueConfiguration", () => se_QueueConfigurationList(input[_QCu], context));
      bn2.l(input, "LambdaFunctionConfigurations", "CloudFunctionConfiguration", () => se_LambdaFunctionConfigurationList(input[_LFC], context));
      if (input[_EBC] != null) {
        bn2.c(se_EventBridgeConfiguration(input[_EBC], context).n(_EBC));
      }
      return bn2;
    };
    se_NotificationConfigurationFilter = (input, context) => {
      const bn2 = new XmlNode(_NCF);
      if (input[_K] != null) {
        bn2.c(se_S3KeyFilter(input[_K], context).n(_SKe));
      }
      return bn2;
    };
    se_ObjectIdentifier = (input, context) => {
      const bn2 = new XmlNode(_OI);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      if (input[_VI] != null) {
        bn2.c(XmlNode.of(_OVI, input[_VI]).n(_VI));
      }
      return bn2;
    };
    se_ObjectIdentifierList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ObjectIdentifier(entry, context);
        return n2.n(_me);
      });
    };
    se_ObjectLockConfiguration = (input, context) => {
      const bn2 = new XmlNode(_OLC);
      bn2.cc(input, _OLE);
      if (input[_Ru] != null) {
        bn2.c(se_ObjectLockRule(input[_Ru], context).n(_Ru));
      }
      return bn2;
    };
    se_ObjectLockLegalHold = (input, context) => {
      const bn2 = new XmlNode(_OLLH);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_OLLHS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ObjectLockRetention = (input, context) => {
      const bn2 = new XmlNode(_OLR);
      if (input[_Mo] != null) {
        bn2.c(XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
      }
      if (input[_RUD] != null) {
        bn2.c(XmlNode.of(_Dat, (input[_RUD].toISOString().split(".")[0] + "Z").toString()).n(_RUD));
      }
      return bn2;
    };
    se_ObjectLockRule = (input, context) => {
      const bn2 = new XmlNode(_OLRb);
      if (input[_DRe] != null) {
        bn2.c(se_DefaultRetention(input[_DRe], context).n(_DRe));
      }
      return bn2;
    };
    se_OutputLocation = (input, context) => {
      const bn2 = new XmlNode(_OL);
      if (input[_S_] != null) {
        bn2.c(se_S3Location(input[_S_], context).n(_S_));
      }
      return bn2;
    };
    se_OutputSerialization = (input, context) => {
      const bn2 = new XmlNode(_OS);
      if (input[_CSV] != null) {
        bn2.c(se_CSVOutput(input[_CSV], context).n(_CSV));
      }
      if (input[_JSON] != null) {
        bn2.c(se_JSONOutput(input[_JSON], context).n(_JSON));
      }
      return bn2;
    };
    se_Owner = (input, context) => {
      const bn2 = new XmlNode(_O);
      bn2.cc(input, _DN);
      bn2.cc(input, _ID_);
      return bn2;
    };
    se_OwnershipControls = (input, context) => {
      const bn2 = new XmlNode(_OC);
      bn2.l(input, "Rules", "Rule", () => se_OwnershipControlsRules(input[_Rul], context));
      return bn2;
    };
    se_OwnershipControlsRule = (input, context) => {
      const bn2 = new XmlNode(_OCR);
      bn2.cc(input, _OO);
      return bn2;
    };
    se_OwnershipControlsRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_OwnershipControlsRule(entry, context);
        return n2.n(_me);
      });
    };
    se_ParquetInput = (input, context) => {
      const bn2 = new XmlNode(_PI);
      return bn2;
    };
    se_PartitionedPrefix = (input, context) => {
      const bn2 = new XmlNode(_PP);
      bn2.cc(input, _PDS);
      return bn2;
    };
    se_PublicAccessBlockConfiguration = (input, context) => {
      const bn2 = new XmlNode(_PABC);
      if (input[_BPA] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_BPA])).n(_BPA));
      }
      if (input[_IPA] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_IPA])).n(_IPA));
      }
      if (input[_BPP] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_BPP])).n(_BPP));
      }
      if (input[_RPB] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_RPB])).n(_RPB));
      }
      return bn2;
    };
    se_QueueConfiguration = (input, context) => {
      const bn2 = new XmlNode(_QC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_QA] != null) {
        bn2.c(XmlNode.of(_QA, input[_QA]).n(_Qu));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_QueueConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_QueueConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_Redirect = (input, context) => {
      const bn2 = new XmlNode(_Red);
      bn2.cc(input, _HN);
      bn2.cc(input, _HRC);
      bn2.cc(input, _Pr);
      bn2.cc(input, _RKPW);
      bn2.cc(input, _RKW);
      return bn2;
    };
    se_RedirectAllRequestsTo = (input, context) => {
      const bn2 = new XmlNode(_RART);
      bn2.cc(input, _HN);
      bn2.cc(input, _Pr);
      return bn2;
    };
    se_ReplicaModifications = (input, context) => {
      const bn2 = new XmlNode(_RM);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RMS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ReplicationConfiguration = (input, context) => {
      const bn2 = new XmlNode(_RCe);
      bn2.cc(input, _Ro);
      bn2.l(input, "Rules", "Rule", () => se_ReplicationRules(input[_Rul], context));
      return bn2;
    };
    se_ReplicationRule = (input, context) => {
      const bn2 = new XmlNode(_RRe);
      bn2.cc(input, _ID_);
      if (input[_Pri] != null) {
        bn2.c(XmlNode.of(_Pri, String(input[_Pri])).n(_Pri));
      }
      bn2.cc(input, _P);
      if (input[_F] != null) {
        bn2.c(se_ReplicationRuleFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RRS, input[_S]).n(_S));
      }
      if (input[_SSC] != null) {
        bn2.c(se_SourceSelectionCriteria(input[_SSC], context).n(_SSC));
      }
      if (input[_EOR] != null) {
        bn2.c(se_ExistingObjectReplication(input[_EOR], context).n(_EOR));
      }
      if (input[_Des] != null) {
        bn2.c(se_Destination(input[_Des], context).n(_Des));
      }
      if (input[_DMR] != null) {
        bn2.c(se_DeleteMarkerReplication(input[_DMR], context).n(_DMR));
      }
      return bn2;
    };
    se_ReplicationRuleAndOperator = (input, context) => {
      const bn2 = new XmlNode(_RRAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_ReplicationRuleFilter = (input, context) => {
      const bn2 = new XmlNode(_RRF);
      ReplicationRuleFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_ReplicationRuleAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_ReplicationRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ReplicationRule(entry, context);
        return n2.n(_me);
      });
    };
    se_ReplicationTime = (input, context) => {
      const bn2 = new XmlNode(_RTe);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RTS, input[_S]).n(_S));
      }
      if (input[_Tim] != null) {
        bn2.c(se_ReplicationTimeValue(input[_Tim], context).n(_Tim));
      }
      return bn2;
    };
    se_ReplicationTimeValue = (input, context) => {
      const bn2 = new XmlNode(_RTV);
      if (input[_Mi] != null) {
        bn2.c(XmlNode.of(_Mi, String(input[_Mi])).n(_Mi));
      }
      return bn2;
    };
    se_RequestPaymentConfiguration = (input, context) => {
      const bn2 = new XmlNode(_RPC);
      bn2.cc(input, _Pa);
      return bn2;
    };
    se_RequestProgress = (input, context) => {
      const bn2 = new XmlNode(_RPe);
      if (input[_Ena] != null) {
        bn2.c(XmlNode.of(_ERP, String(input[_Ena])).n(_Ena));
      }
      return bn2;
    };
    se_RestoreRequest = (input, context) => {
      const bn2 = new XmlNode(_RRes);
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_GJP] != null) {
        bn2.c(se_GlacierJobParameters(input[_GJP], context).n(_GJP));
      }
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_RRT, input[_Ty]).n(_Ty));
      }
      bn2.cc(input, _Ti);
      bn2.cc(input, _Desc);
      if (input[_SP] != null) {
        bn2.c(se_SelectParameters(input[_SP], context).n(_SP));
      }
      if (input[_OL] != null) {
        bn2.c(se_OutputLocation(input[_OL], context).n(_OL));
      }
      return bn2;
    };
    se_RoutingRule = (input, context) => {
      const bn2 = new XmlNode(_RRou);
      if (input[_Con] != null) {
        bn2.c(se_Condition(input[_Con], context).n(_Con));
      }
      if (input[_Red] != null) {
        bn2.c(se_Redirect(input[_Red], context).n(_Red));
      }
      return bn2;
    };
    se_RoutingRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_RoutingRule(entry, context);
        return n2.n(_RRou);
      });
    };
    se_S3KeyFilter = (input, context) => {
      const bn2 = new XmlNode(_SKF);
      bn2.l(input, "FilterRules", "FilterRule", () => se_FilterRuleList(input[_FRi], context));
      return bn2;
    };
    se_S3Location = (input, context) => {
      const bn2 = new XmlNode(_SL);
      bn2.cc(input, _BN);
      if (input[_P] != null) {
        bn2.c(XmlNode.of(_LP, input[_P]).n(_P));
      }
      if (input[_En] != null) {
        bn2.c(se_Encryption(input[_En], context).n(_En));
      }
      if (input[_CACL] != null) {
        bn2.c(XmlNode.of(_OCACL, input[_CACL]).n(_CACL));
      }
      bn2.lc(input, "AccessControlList", "AccessControlList", () => se_Grants(input[_ACLc], context));
      if (input[_T] != null) {
        bn2.c(se_Tagging(input[_T], context).n(_T));
      }
      bn2.lc(input, "UserMetadata", "UserMetadata", () => se_UserMetadata(input[_UM], context));
      bn2.cc(input, _SC);
      return bn2;
    };
    se_ScanRange = (input, context) => {
      const bn2 = new XmlNode(_SR);
      if (input[_St] != null) {
        bn2.c(XmlNode.of(_St, String(input[_St])).n(_St));
      }
      if (input[_End] != null) {
        bn2.c(XmlNode.of(_End, String(input[_End])).n(_End));
      }
      return bn2;
    };
    se_SelectParameters = (input, context) => {
      const bn2 = new XmlNode(_SP);
      if (input[_IS] != null) {
        bn2.c(se_InputSerialization(input[_IS], context).n(_IS));
      }
      bn2.cc(input, _ETx);
      bn2.cc(input, _Ex);
      if (input[_OS] != null) {
        bn2.c(se_OutputSerialization(input[_OS], context).n(_OS));
      }
      return bn2;
    };
    se_ServerSideEncryptionByDefault = (input, context) => {
      const bn2 = new XmlNode(_SSEBD);
      if (input[_SSEA] != null) {
        bn2.c(XmlNode.of(_SSE, input[_SSEA]).n(_SSEA));
      }
      if (input[_KMSMKID] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KMSMKID]).n(_KMSMKID));
      }
      return bn2;
    };
    se_ServerSideEncryptionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_SSEC);
      bn2.l(input, "Rules", "Rule", () => se_ServerSideEncryptionRules(input[_Rul], context));
      return bn2;
    };
    se_ServerSideEncryptionRule = (input, context) => {
      const bn2 = new XmlNode(_SSER);
      if (input[_ASSEBD] != null) {
        bn2.c(se_ServerSideEncryptionByDefault(input[_ASSEBD], context).n(_ASSEBD));
      }
      if (input[_BKE] != null) {
        bn2.c(XmlNode.of(_BKE, String(input[_BKE])).n(_BKE));
      }
      return bn2;
    };
    se_ServerSideEncryptionRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ServerSideEncryptionRule(entry, context);
        return n2.n(_me);
      });
    };
    se_SimplePrefix = (input, context) => {
      const bn2 = new XmlNode(_SPi);
      return bn2;
    };
    se_SourceSelectionCriteria = (input, context) => {
      const bn2 = new XmlNode(_SSC);
      if (input[_SKEO] != null) {
        bn2.c(se_SseKmsEncryptedObjects(input[_SKEO], context).n(_SKEO));
      }
      if (input[_RM] != null) {
        bn2.c(se_ReplicaModifications(input[_RM], context).n(_RM));
      }
      return bn2;
    };
    se_SSEKMS = (input, context) => {
      const bn2 = new XmlNode(_SK);
      if (input[_KI] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KI]).n(_KI));
      }
      return bn2;
    };
    se_SseKmsEncryptedObjects = (input, context) => {
      const bn2 = new XmlNode(_SKEO);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_SKEOS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_SSES3 = (input, context) => {
      const bn2 = new XmlNode(_SS);
      return bn2;
    };
    se_StorageClassAnalysis = (input, context) => {
      const bn2 = new XmlNode(_SCA);
      if (input[_DE] != null) {
        bn2.c(se_StorageClassAnalysisDataExport(input[_DE], context).n(_DE));
      }
      return bn2;
    };
    se_StorageClassAnalysisDataExport = (input, context) => {
      const bn2 = new XmlNode(_SCADE);
      if (input[_OSV] != null) {
        bn2.c(XmlNode.of(_SCASV, input[_OSV]).n(_OSV));
      }
      if (input[_Des] != null) {
        bn2.c(se_AnalyticsExportDestination(input[_Des], context).n(_Des));
      }
      return bn2;
    };
    se_Tag = (input, context) => {
      const bn2 = new XmlNode(_Ta);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      bn2.cc(input, _Va);
      return bn2;
    };
    se_Tagging = (input, context) => {
      const bn2 = new XmlNode(_T);
      bn2.lc(input, "TagSet", "TagSet", () => se_TagSet(input[_TS], context));
      return bn2;
    };
    se_TagSet = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Tag(entry, context);
        return n2.n(_Ta);
      });
    };
    se_TargetGrant = (input, context) => {
      const bn2 = new XmlNode(_TGa);
      if (input[_Gra] != null) {
        const n2 = se_Grantee(input[_Gra], context).n(_Gra);
        n2.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn2.c(n2);
      }
      if (input[_Pe] != null) {
        bn2.c(XmlNode.of(_BLP, input[_Pe]).n(_Pe));
      }
      return bn2;
    };
    se_TargetGrants = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_TargetGrant(entry, context);
        return n2.n(_G);
      });
    };
    se_TargetObjectKeyFormat = (input, context) => {
      const bn2 = new XmlNode(_TOKF);
      if (input[_SPi] != null) {
        bn2.c(se_SimplePrefix(input[_SPi], context).n(_SPi));
      }
      if (input[_PP] != null) {
        bn2.c(se_PartitionedPrefix(input[_PP], context).n(_PP));
      }
      return bn2;
    };
    se_Tiering = (input, context) => {
      const bn2 = new XmlNode(_Tier);
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_ITD, String(input[_Da])).n(_Da));
      }
      if (input[_AT] != null) {
        bn2.c(XmlNode.of(_ITAT, input[_AT]).n(_AT));
      }
      return bn2;
    };
    se_TieringList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Tiering(entry, context);
        return n2.n(_me);
      });
    };
    se_TopicConfiguration = (input, context) => {
      const bn2 = new XmlNode(_TCo);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_TA] != null) {
        bn2.c(XmlNode.of(_TA, input[_TA]).n(_Top));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_TopicConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_TopicConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_Transition = (input, context) => {
      const bn2 = new XmlNode(_Tra);
      if (input[_Dat] != null) {
        bn2.c(XmlNode.of(_Dat, (input[_Dat].toISOString().split(".")[0] + "Z").toString()).n(_Dat));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_SC] != null) {
        bn2.c(XmlNode.of(_TSC, input[_SC]).n(_SC));
      }
      return bn2;
    };
    se_TransitionList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Transition(entry, context);
        return n2.n(_me);
      });
    };
    se_UserMetadata = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_MetadataEntry(entry, context);
        return n2.n(_ME);
      });
    };
    se_VersioningConfiguration = (input, context) => {
      const bn2 = new XmlNode(_VCe);
      if (input[_MFAD] != null) {
        bn2.c(XmlNode.of(_MFAD, input[_MFAD]).n(_MDf));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_BVS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_WebsiteConfiguration = (input, context) => {
      const bn2 = new XmlNode(_WC);
      if (input[_ED] != null) {
        bn2.c(se_ErrorDocument(input[_ED], context).n(_ED));
      }
      if (input[_ID] != null) {
        bn2.c(se_IndexDocument(input[_ID], context).n(_ID));
      }
      if (input[_RART] != null) {
        bn2.c(se_RedirectAllRequestsTo(input[_RART], context).n(_RART));
      }
      bn2.lc(input, "RoutingRules", "RoutingRules", () => se_RoutingRules(input[_RRo], context));
      return bn2;
    };
    de_AbortIncompleteMultipartUpload = (output, context) => {
      const contents = {};
      if (output[_DAI] != null) {
        contents[_DAI] = strictParseInt32(output[_DAI]);
      }
      return contents;
    };
    de_AccessControlTranslation = (output, context) => {
      const contents = {};
      if (output[_O] != null) {
        contents[_O] = expectString(output[_O]);
      }
      return contents;
    };
    de_AllowedHeaders = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AllowedMethods = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AllowedOrigins = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AnalyticsAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Tag === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_AnalyticsConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output.Filter === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_AnalyticsFilter(expectUnion(output[_F]), context);
      }
      if (output[_SCA] != null) {
        contents[_SCA] = de_StorageClassAnalysis(output[_SCA], context);
      }
      return contents;
    };
    de_AnalyticsConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_AnalyticsConfiguration(entry, context);
      });
    };
    de_AnalyticsExportDestination = (output, context) => {
      const contents = {};
      if (output[_SBD] != null) {
        contents[_SBD] = de_AnalyticsS3BucketDestination(output[_SBD], context);
      }
      return contents;
    };
    de_AnalyticsFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_A] != null) {
        return {
          And: de_AnalyticsAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_AnalyticsS3BucketDestination = (output, context) => {
      const contents = {};
      if (output[_Fo] != null) {
        contents[_Fo] = expectString(output[_Fo]);
      }
      if (output[_BAI] != null) {
        contents[_BAI] = expectString(output[_BAI]);
      }
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_Bucket = (output, context) => {
      const contents = {};
      if (output[_N] != null) {
        contents[_N] = expectString(output[_N]);
      }
      if (output[_CDr] != null) {
        contents[_CDr] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_CDr]));
      }
      return contents;
    };
    de_Buckets = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Bucket(entry, context);
      });
    };
    de_Checksum = (output, context) => {
      const contents = {};
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_ChecksumAlgorithmList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_CommonPrefix = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_CommonPrefixList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_CommonPrefix(entry, context);
      });
    };
    de_Condition = (output, context) => {
      const contents = {};
      if (output[_HECRE] != null) {
        contents[_HECRE] = expectString(output[_HECRE]);
      }
      if (output[_KPE] != null) {
        contents[_KPE] = expectString(output[_KPE]);
      }
      return contents;
    };
    de_ContinuationEvent = (output, context) => {
      const contents = {};
      return contents;
    };
    de_CopyObjectResult = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_CopyPartResult = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_CORSRule = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output.AllowedHeader === "") {
        contents[_AHl] = [];
      } else if (output[_AH] != null) {
        contents[_AHl] = de_AllowedHeaders(getArrayIfSingleItem(output[_AH]), context);
      }
      if (output.AllowedMethod === "") {
        contents[_AMl] = [];
      } else if (output[_AM] != null) {
        contents[_AMl] = de_AllowedMethods(getArrayIfSingleItem(output[_AM]), context);
      }
      if (output.AllowedOrigin === "") {
        contents[_AOl] = [];
      } else if (output[_AO] != null) {
        contents[_AOl] = de_AllowedOrigins(getArrayIfSingleItem(output[_AO]), context);
      }
      if (output.ExposeHeader === "") {
        contents[_EH] = [];
      } else if (output[_EHx] != null) {
        contents[_EH] = de_ExposeHeaders(getArrayIfSingleItem(output[_EHx]), context);
      }
      if (output[_MAS] != null) {
        contents[_MAS] = strictParseInt32(output[_MAS]);
      }
      return contents;
    };
    de_CORSRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_CORSRule(entry, context);
      });
    };
    de_DefaultRetention = (output, context) => {
      const contents = {};
      if (output[_Mo] != null) {
        contents[_Mo] = expectString(output[_Mo]);
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_Y] != null) {
        contents[_Y] = strictParseInt32(output[_Y]);
      }
      return contents;
    };
    de_DeletedObject = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_DM] != null) {
        contents[_DM] = parseBoolean(output[_DM]);
      }
      if (output[_DMVI] != null) {
        contents[_DMVI] = expectString(output[_DMVI]);
      }
      return contents;
    };
    de_DeletedObjects = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_DeletedObject(entry, context);
      });
    };
    de_DeleteMarkerEntry = (output, context) => {
      const contents = {};
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_IL] != null) {
        contents[_IL] = parseBoolean(output[_IL]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      return contents;
    };
    de_DeleteMarkerReplication = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_DeleteMarkers = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_DeleteMarkerEntry(entry, context);
      });
    };
    de_Destination = (output, context) => {
      const contents = {};
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_Ac] != null) {
        contents[_Ac] = expectString(output[_Ac]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_ACT] != null) {
        contents[_ACT] = de_AccessControlTranslation(output[_ACT], context);
      }
      if (output[_ECn] != null) {
        contents[_ECn] = de_EncryptionConfiguration(output[_ECn], context);
      }
      if (output[_RTe] != null) {
        contents[_RTe] = de_ReplicationTime(output[_RTe], context);
      }
      if (output[_Me] != null) {
        contents[_Me] = de_Metrics(output[_Me], context);
      }
      return contents;
    };
    de_EncryptionConfiguration = (output, context) => {
      const contents = {};
      if (output[_RKKID] != null) {
        contents[_RKKID] = expectString(output[_RKKID]);
      }
      return contents;
    };
    de_EndEvent = (output, context) => {
      const contents = {};
      return contents;
    };
    de__Error = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_Cod] != null) {
        contents[_Cod] = expectString(output[_Cod]);
      }
      if (output[_Mes] != null) {
        contents[_Mes] = expectString(output[_Mes]);
      }
      return contents;
    };
    de_ErrorDocument = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      return contents;
    };
    de_Errors = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de__Error(entry, context);
      });
    };
    de_EventBridgeConfiguration = (output, context) => {
      const contents = {};
      return contents;
    };
    de_EventList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_ExistingObjectReplication = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ExposeHeaders = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_FilterRule = (output, context) => {
      const contents = {};
      if (output[_N] != null) {
        contents[_N] = expectString(output[_N]);
      }
      if (output[_Va] != null) {
        contents[_Va] = expectString(output[_Va]);
      }
      return contents;
    };
    de_FilterRuleList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_FilterRule(entry, context);
      });
    };
    de_GetObjectAttributesParts = (output, context) => {
      const contents = {};
      if (output[_PC] != null) {
        contents[_TPC] = strictParseInt32(output[_PC]);
      }
      if (output[_PNM] != null) {
        contents[_PNM] = expectString(output[_PNM]);
      }
      if (output[_NPNM] != null) {
        contents[_NPNM] = expectString(output[_NPNM]);
      }
      if (output[_MP] != null) {
        contents[_MP] = strictParseInt32(output[_MP]);
      }
      if (output[_IT] != null) {
        contents[_IT] = parseBoolean(output[_IT]);
      }
      if (output.Part === "") {
        contents[_Part] = [];
      } else if (output[_Par] != null) {
        contents[_Part] = de_PartsList(getArrayIfSingleItem(output[_Par]), context);
      }
      return contents;
    };
    de_Grant = (output, context) => {
      const contents = {};
      if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
      }
      if (output[_Pe] != null) {
        contents[_Pe] = expectString(output[_Pe]);
      }
      return contents;
    };
    de_Grantee = (output, context) => {
      const contents = {};
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      if (output[_EA] != null) {
        contents[_EA] = expectString(output[_EA]);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_URI] != null) {
        contents[_URI] = expectString(output[_URI]);
      }
      if (output[_x] != null) {
        contents[_Ty] = expectString(output[_x]);
      }
      return contents;
    };
    de_Grants = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Grant(entry, context);
      });
    };
    de_IndexDocument = (output, context) => {
      const contents = {};
      if (output[_Su] != null) {
        contents[_Su] = expectString(output[_Su]);
      }
      return contents;
    };
    de_Initiator = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      return contents;
    };
    de_IntelligentTieringAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Tag === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_IntelligentTieringConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_F] != null) {
        contents[_F] = de_IntelligentTieringFilter(output[_F], context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output.Tiering === "") {
        contents[_Tie] = [];
      } else if (output[_Tier] != null) {
        contents[_Tie] = de_TieringList(getArrayIfSingleItem(output[_Tier]), context);
      }
      return contents;
    };
    de_IntelligentTieringConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_IntelligentTieringConfiguration(entry, context);
      });
    };
    de_IntelligentTieringFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
      }
      if (output[_A] != null) {
        contents[_A] = de_IntelligentTieringAndOperator(output[_A], context);
      }
      return contents;
    };
    de_InventoryConfiguration = (output, context) => {
      const contents = {};
      if (output[_Des] != null) {
        contents[_Des] = de_InventoryDestination(output[_Des], context);
      }
      if (output[_IE] != null) {
        contents[_IE] = parseBoolean(output[_IE]);
      }
      if (output[_F] != null) {
        contents[_F] = de_InventoryFilter(output[_F], context);
      }
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_IOV] != null) {
        contents[_IOV] = expectString(output[_IOV]);
      }
      if (output.OptionalFields === "") {
        contents[_OF] = [];
      } else if (output[_OF] != null && output[_OF][_Fi] != null) {
        contents[_OF] = de_InventoryOptionalFields(getArrayIfSingleItem(output[_OF][_Fi]), context);
      }
      if (output[_Sc] != null) {
        contents[_Sc] = de_InventorySchedule(output[_Sc], context);
      }
      return contents;
    };
    de_InventoryConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_InventoryConfiguration(entry, context);
      });
    };
    de_InventoryDestination = (output, context) => {
      const contents = {};
      if (output[_SBD] != null) {
        contents[_SBD] = de_InventoryS3BucketDestination(output[_SBD], context);
      }
      return contents;
    };
    de_InventoryEncryption = (output, context) => {
      const contents = {};
      if (output[_SS] != null) {
        contents[_SSES] = de_SSES3(output[_SS], context);
      }
      if (output[_SK] != null) {
        contents[_SSEKMS] = de_SSEKMS(output[_SK], context);
      }
      return contents;
    };
    de_InventoryFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_InventoryOptionalFields = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_InventoryS3BucketDestination = (output, context) => {
      const contents = {};
      if (output[_AIc] != null) {
        contents[_AIc] = expectString(output[_AIc]);
      }
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_Fo] != null) {
        contents[_Fo] = expectString(output[_Fo]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_En] != null) {
        contents[_En] = de_InventoryEncryption(output[_En], context);
      }
      return contents;
    };
    de_InventorySchedule = (output, context) => {
      const contents = {};
      if (output[_Fr] != null) {
        contents[_Fr] = expectString(output[_Fr]);
      }
      return contents;
    };
    de_LambdaFunctionConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_CF] != null) {
        contents[_LFA] = expectString(output[_CF]);
      }
      if (output.Event === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_LambdaFunctionConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_LambdaFunctionConfiguration(entry, context);
      });
    };
    de_LifecycleExpiration = (output, context) => {
      const contents = {};
      if (output[_Dat] != null) {
        contents[_Dat] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Dat]));
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_EODM] != null) {
        contents[_EODM] = parseBoolean(output[_EODM]);
      }
      return contents;
    };
    de_LifecycleRule = (output, context) => {
      const contents = {};
      if (output[_Exp] != null) {
        contents[_Exp] = de_LifecycleExpiration(output[_Exp], context);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Filter === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_LifecycleRuleFilter(expectUnion(output[_F]), context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output.Transition === "") {
        contents[_Tr] = [];
      } else if (output[_Tra] != null) {
        contents[_Tr] = de_TransitionList(getArrayIfSingleItem(output[_Tra]), context);
      }
      if (output.NoncurrentVersionTransition === "") {
        contents[_NVT] = [];
      } else if (output[_NVTo] != null) {
        contents[_NVT] = de_NoncurrentVersionTransitionList(getArrayIfSingleItem(output[_NVTo]), context);
      }
      if (output[_NVE] != null) {
        contents[_NVE] = de_NoncurrentVersionExpiration(output[_NVE], context);
      }
      if (output[_AIMU] != null) {
        contents[_AIMU] = de_AbortIncompleteMultipartUpload(output[_AIMU], context);
      }
      return contents;
    };
    de_LifecycleRuleAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Tag === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      if (output[_OSGT] != null) {
        contents[_OSGT] = strictParseLong(output[_OSGT]);
      }
      if (output[_OSLT] != null) {
        contents[_OSLT] = strictParseLong(output[_OSLT]);
      }
      return contents;
    };
    de_LifecycleRuleFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_OSGT] != null) {
        return {
          ObjectSizeGreaterThan: strictParseLong(output[_OSGT])
        };
      }
      if (output[_OSLT] != null) {
        return {
          ObjectSizeLessThan: strictParseLong(output[_OSLT])
        };
      }
      if (output[_A] != null) {
        return {
          And: de_LifecycleRuleAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_LifecycleRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_LifecycleRule(entry, context);
      });
    };
    de_LoggingEnabled = (output, context) => {
      const contents = {};
      if (output[_TB] != null) {
        contents[_TB] = expectString(output[_TB]);
      }
      if (output.TargetGrants === "") {
        contents[_TG] = [];
      } else if (output[_TG] != null && output[_TG][_G] != null) {
        contents[_TG] = de_TargetGrants(getArrayIfSingleItem(output[_TG][_G]), context);
      }
      if (output[_TP] != null) {
        contents[_TP] = expectString(output[_TP]);
      }
      if (output[_TOKF] != null) {
        contents[_TOKF] = de_TargetObjectKeyFormat(output[_TOKF], context);
      }
      return contents;
    };
    de_Metrics = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_ETv] != null) {
        contents[_ETv] = de_ReplicationTimeValue(output[_ETv], context);
      }
      return contents;
    };
    de_MetricsAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Tag === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      if (output[_APAc] != null) {
        contents[_APAc] = expectString(output[_APAc]);
      }
      return contents;
    };
    de_MetricsConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output.Filter === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_MetricsFilter(expectUnion(output[_F]), context);
      }
      return contents;
    };
    de_MetricsConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_MetricsConfiguration(entry, context);
      });
    };
    de_MetricsFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_APAc] != null) {
        return {
          AccessPointArn: expectString(output[_APAc])
        };
      }
      if (output[_A] != null) {
        return {
          And: de_MetricsAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_MultipartUpload = (output, context) => {
      const contents = {};
      if (output[_UI] != null) {
        contents[_UI] = expectString(output[_UI]);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_Ini] != null) {
        contents[_Ini] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ini]));
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_In] != null) {
        contents[_In] = de_Initiator(output[_In], context);
      }
      if (output[_CA] != null) {
        contents[_CA] = expectString(output[_CA]);
      }
      return contents;
    };
    de_MultipartUploadList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_MultipartUpload(entry, context);
      });
    };
    de_NoncurrentVersionExpiration = (output, context) => {
      const contents = {};
      if (output[_ND] != null) {
        contents[_ND] = strictParseInt32(output[_ND]);
      }
      if (output[_NNV] != null) {
        contents[_NNV] = strictParseInt32(output[_NNV]);
      }
      return contents;
    };
    de_NoncurrentVersionTransition = (output, context) => {
      const contents = {};
      if (output[_ND] != null) {
        contents[_ND] = strictParseInt32(output[_ND]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_NNV] != null) {
        contents[_NNV] = strictParseInt32(output[_NNV]);
      }
      return contents;
    };
    de_NoncurrentVersionTransitionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_NoncurrentVersionTransition(entry, context);
      });
    };
    de_NotificationConfigurationFilter = (output, context) => {
      const contents = {};
      if (output[_SKe] != null) {
        contents[_K] = de_S3KeyFilter(output[_SKe], context);
      }
      return contents;
    };
    de__Object = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output.ChecksumAlgorithm === "") {
        contents[_CA] = [];
      } else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList(getArrayIfSingleItem(output[_CA]), context);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_RSe] != null) {
        contents[_RSe] = de_RestoreStatus(output[_RSe], context);
      }
      return contents;
    };
    de_ObjectList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de__Object(entry, context);
      });
    };
    de_ObjectLockConfiguration = (output, context) => {
      const contents = {};
      if (output[_OLE] != null) {
        contents[_OLE] = expectString(output[_OLE]);
      }
      if (output[_Ru] != null) {
        contents[_Ru] = de_ObjectLockRule(output[_Ru], context);
      }
      return contents;
    };
    de_ObjectLockLegalHold = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ObjectLockRetention = (output, context) => {
      const contents = {};
      if (output[_Mo] != null) {
        contents[_Mo] = expectString(output[_Mo]);
      }
      if (output[_RUD] != null) {
        contents[_RUD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_RUD]));
      }
      return contents;
    };
    de_ObjectLockRule = (output, context) => {
      const contents = {};
      if (output[_DRe] != null) {
        contents[_DRe] = de_DefaultRetention(output[_DRe], context);
      }
      return contents;
    };
    de_ObjectPart = (output, context) => {
      const contents = {};
      if (output[_PN] != null) {
        contents[_PN] = strictParseInt32(output[_PN]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_ObjectVersion = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output.ChecksumAlgorithm === "") {
        contents[_CA] = [];
      } else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList(getArrayIfSingleItem(output[_CA]), context);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_IL] != null) {
        contents[_IL] = parseBoolean(output[_IL]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_RSe] != null) {
        contents[_RSe] = de_RestoreStatus(output[_RSe], context);
      }
      return contents;
    };
    de_ObjectVersionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ObjectVersion(entry, context);
      });
    };
    de_Owner = (output, context) => {
      const contents = {};
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      return contents;
    };
    de_OwnershipControls = (output, context) => {
      const contents = {};
      if (output.Rule === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_OwnershipControlsRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_OwnershipControlsRule = (output, context) => {
      const contents = {};
      if (output[_OO] != null) {
        contents[_OO] = expectString(output[_OO]);
      }
      return contents;
    };
    de_OwnershipControlsRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_OwnershipControlsRule(entry, context);
      });
    };
    de_Part = (output, context) => {
      const contents = {};
      if (output[_PN] != null) {
        contents[_PN] = strictParseInt32(output[_PN]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_PartitionedPrefix = (output, context) => {
      const contents = {};
      if (output[_PDS] != null) {
        contents[_PDS] = expectString(output[_PDS]);
      }
      return contents;
    };
    de_Parts = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Part(entry, context);
      });
    };
    de_PartsList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ObjectPart(entry, context);
      });
    };
    de_PolicyStatus = (output, context) => {
      const contents = {};
      if (output[_IP] != null) {
        contents[_IP] = parseBoolean(output[_IP]);
      }
      return contents;
    };
    de_Progress = (output, context) => {
      const contents = {};
      if (output[_BS] != null) {
        contents[_BS] = strictParseLong(output[_BS]);
      }
      if (output[_BP] != null) {
        contents[_BP] = strictParseLong(output[_BP]);
      }
      if (output[_BRy] != null) {
        contents[_BRy] = strictParseLong(output[_BRy]);
      }
      return contents;
    };
    de_PublicAccessBlockConfiguration = (output, context) => {
      const contents = {};
      if (output[_BPA] != null) {
        contents[_BPA] = parseBoolean(output[_BPA]);
      }
      if (output[_IPA] != null) {
        contents[_IPA] = parseBoolean(output[_IPA]);
      }
      if (output[_BPP] != null) {
        contents[_BPP] = parseBoolean(output[_BPP]);
      }
      if (output[_RPB] != null) {
        contents[_RPB] = parseBoolean(output[_RPB]);
      }
      return contents;
    };
    de_QueueConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_Qu] != null) {
        contents[_QA] = expectString(output[_Qu]);
      }
      if (output.Event === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_QueueConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_QueueConfiguration(entry, context);
      });
    };
    de_Redirect = (output, context) => {
      const contents = {};
      if (output[_HN] != null) {
        contents[_HN] = expectString(output[_HN]);
      }
      if (output[_HRC] != null) {
        contents[_HRC] = expectString(output[_HRC]);
      }
      if (output[_Pr] != null) {
        contents[_Pr] = expectString(output[_Pr]);
      }
      if (output[_RKPW] != null) {
        contents[_RKPW] = expectString(output[_RKPW]);
      }
      if (output[_RKW] != null) {
        contents[_RKW] = expectString(output[_RKW]);
      }
      return contents;
    };
    de_RedirectAllRequestsTo = (output, context) => {
      const contents = {};
      if (output[_HN] != null) {
        contents[_HN] = expectString(output[_HN]);
      }
      if (output[_Pr] != null) {
        contents[_Pr] = expectString(output[_Pr]);
      }
      return contents;
    };
    de_ReplicaModifications = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ReplicationConfiguration = (output, context) => {
      const contents = {};
      if (output[_Ro] != null) {
        contents[_Ro] = expectString(output[_Ro]);
      }
      if (output.Rule === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_ReplicationRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_ReplicationRule = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_Pri] != null) {
        contents[_Pri] = strictParseInt32(output[_Pri]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Filter === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_ReplicationRuleFilter(expectUnion(output[_F]), context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_SSC] != null) {
        contents[_SSC] = de_SourceSelectionCriteria(output[_SSC], context);
      }
      if (output[_EOR] != null) {
        contents[_EOR] = de_ExistingObjectReplication(output[_EOR], context);
      }
      if (output[_Des] != null) {
        contents[_Des] = de_Destination(output[_Des], context);
      }
      if (output[_DMR] != null) {
        contents[_DMR] = de_DeleteMarkerReplication(output[_DMR], context);
      }
      return contents;
    };
    de_ReplicationRuleAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output.Tag === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_ReplicationRuleFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_A] != null) {
        return {
          And: de_ReplicationRuleAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_ReplicationRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ReplicationRule(entry, context);
      });
    };
    de_ReplicationTime = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_Tim] != null) {
        contents[_Tim] = de_ReplicationTimeValue(output[_Tim], context);
      }
      return contents;
    };
    de_ReplicationTimeValue = (output, context) => {
      const contents = {};
      if (output[_Mi] != null) {
        contents[_Mi] = strictParseInt32(output[_Mi]);
      }
      return contents;
    };
    de_RestoreStatus = (output, context) => {
      const contents = {};
      if (output[_IRIP] != null) {
        contents[_IRIP] = parseBoolean(output[_IRIP]);
      }
      if (output[_RED] != null) {
        contents[_RED] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_RED]));
      }
      return contents;
    };
    de_RoutingRule = (output, context) => {
      const contents = {};
      if (output[_Con] != null) {
        contents[_Con] = de_Condition(output[_Con], context);
      }
      if (output[_Red] != null) {
        contents[_Red] = de_Redirect(output[_Red], context);
      }
      return contents;
    };
    de_RoutingRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_RoutingRule(entry, context);
      });
    };
    de_S3KeyFilter = (output, context) => {
      const contents = {};
      if (output.FilterRule === "") {
        contents[_FRi] = [];
      } else if (output[_FR] != null) {
        contents[_FRi] = de_FilterRuleList(getArrayIfSingleItem(output[_FR]), context);
      }
      return contents;
    };
    de_ServerSideEncryptionByDefault = (output, context) => {
      const contents = {};
      if (output[_SSEA] != null) {
        contents[_SSEA] = expectString(output[_SSEA]);
      }
      if (output[_KMSMKID] != null) {
        contents[_KMSMKID] = expectString(output[_KMSMKID]);
      }
      return contents;
    };
    de_ServerSideEncryptionConfiguration = (output, context) => {
      const contents = {};
      if (output.Rule === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_ServerSideEncryptionRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_ServerSideEncryptionRule = (output, context) => {
      const contents = {};
      if (output[_ASSEBD] != null) {
        contents[_ASSEBD] = de_ServerSideEncryptionByDefault(output[_ASSEBD], context);
      }
      if (output[_BKE] != null) {
        contents[_BKE] = parseBoolean(output[_BKE]);
      }
      return contents;
    };
    de_ServerSideEncryptionRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ServerSideEncryptionRule(entry, context);
      });
    };
    de_SessionCredentials = (output, context) => {
      const contents = {};
      if (output[_AKI] != null) {
        contents[_AKI] = expectString(output[_AKI]);
      }
      if (output[_SAK] != null) {
        contents[_SAK] = expectString(output[_SAK]);
      }
      if (output[_ST] != null) {
        contents[_ST] = expectString(output[_ST]);
      }
      if (output[_Exp] != null) {
        contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
      }
      return contents;
    };
    de_SimplePrefix = (output, context) => {
      const contents = {};
      return contents;
    };
    de_SourceSelectionCriteria = (output, context) => {
      const contents = {};
      if (output[_SKEO] != null) {
        contents[_SKEO] = de_SseKmsEncryptedObjects(output[_SKEO], context);
      }
      if (output[_RM] != null) {
        contents[_RM] = de_ReplicaModifications(output[_RM], context);
      }
      return contents;
    };
    de_SSEKMS = (output, context) => {
      const contents = {};
      if (output[_KI] != null) {
        contents[_KI] = expectString(output[_KI]);
      }
      return contents;
    };
    de_SseKmsEncryptedObjects = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_SSES3 = (output, context) => {
      const contents = {};
      return contents;
    };
    de_Stats = (output, context) => {
      const contents = {};
      if (output[_BS] != null) {
        contents[_BS] = strictParseLong(output[_BS]);
      }
      if (output[_BP] != null) {
        contents[_BP] = strictParseLong(output[_BP]);
      }
      if (output[_BRy] != null) {
        contents[_BRy] = strictParseLong(output[_BRy]);
      }
      return contents;
    };
    de_StorageClassAnalysis = (output, context) => {
      const contents = {};
      if (output[_DE] != null) {
        contents[_DE] = de_StorageClassAnalysisDataExport(output[_DE], context);
      }
      return contents;
    };
    de_StorageClassAnalysisDataExport = (output, context) => {
      const contents = {};
      if (output[_OSV] != null) {
        contents[_OSV] = expectString(output[_OSV]);
      }
      if (output[_Des] != null) {
        contents[_Des] = de_AnalyticsExportDestination(output[_Des], context);
      }
      return contents;
    };
    de_Tag = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_Va] != null) {
        contents[_Va] = expectString(output[_Va]);
      }
      return contents;
    };
    de_TagSet = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Tag(entry, context);
      });
    };
    de_TargetGrant = (output, context) => {
      const contents = {};
      if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
      }
      if (output[_Pe] != null) {
        contents[_Pe] = expectString(output[_Pe]);
      }
      return contents;
    };
    de_TargetGrants = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_TargetGrant(entry, context);
      });
    };
    de_TargetObjectKeyFormat = (output, context) => {
      const contents = {};
      if (output[_SPi] != null) {
        contents[_SPi] = de_SimplePrefix(output[_SPi], context);
      }
      if (output[_PP] != null) {
        contents[_PP] = de_PartitionedPrefix(output[_PP], context);
      }
      return contents;
    };
    de_Tiering = (output, context) => {
      const contents = {};
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_AT] != null) {
        contents[_AT] = expectString(output[_AT]);
      }
      return contents;
    };
    de_TieringList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Tiering(entry, context);
      });
    };
    de_TopicConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_Top] != null) {
        contents[_TA] = expectString(output[_Top]);
      }
      if (output.Event === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_TopicConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_TopicConfiguration(entry, context);
      });
    };
    de_Transition = (output, context) => {
      const contents = {};
      if (output[_Dat] != null) {
        contents[_Dat] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Dat]));
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      return contents;
    };
    de_TransitionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Transition(entry, context);
      });
    };
    deserializeMetadata2 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBodyString3 = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
    isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
    _A = "And";
    _AAO = "AnalyticsAndOperator";
    _AC = "AnalyticsConfiguration";
    _ACL = "ACL";
    _ACLc = "AccessControlList";
    _ACLn = "AnalyticsConfigurationList";
    _ACP = "AccessControlPolicy";
    _ACT = "AccessControlTranslation";
    _ACc = "AccelerateConfiguration";
    _AD = "AbortDate";
    _AED = "AnalyticsExportDestination";
    _AF = "AnalyticsFilter";
    _AH = "AllowedHeader";
    _AHl = "AllowedHeaders";
    _AI = "AnalyticsId";
    _AIMU = "AbortIncompleteMultipartUpload";
    _AIc = "AccountId";
    _AKI = "AccessKeyId";
    _AM = "AllowedMethod";
    _AMl = "AllowedMethods";
    _AO = "AllowedOrigin";
    _AOl = "AllowedOrigins";
    _APA = "AccessPointAlias";
    _APAc = "AccessPointArn";
    _AQRD = "AllowQuotedRecordDelimiter";
    _AR = "AcceptRanges";
    _ARI = "AbortRuleId";
    _AS = "ArchiveStatus";
    _ASBD = "AnalyticsS3BucketDestination";
    _ASEFF = "AnalyticsS3ExportFileFormat";
    _ASSEBD = "ApplyServerSideEncryptionByDefault";
    _AT = "AccessTier";
    _Ac = "Account";
    _B = "Bucket";
    _BAI = "BucketAccountId";
    _BAS = "BucketAccelerateStatus";
    _BGR = "BypassGovernanceRetention";
    _BI = "BucketInfo";
    _BKE = "BucketKeyEnabled";
    _BLC = "BucketLifecycleConfiguration";
    _BLCu = "BucketLocationConstraint";
    _BLN = "BucketLocationName";
    _BLP = "BucketLogsPermission";
    _BLS = "BucketLoggingStatus";
    _BLT = "BucketLocationType";
    _BN = "BucketName";
    _BP = "BytesProcessed";
    _BPA = "BlockPublicAcls";
    _BPP = "BlockPublicPolicy";
    _BR = "BucketRegion";
    _BRy = "BytesReturned";
    _BS = "BytesScanned";
    _BT = "BucketType";
    _BVS = "BucketVersioningStatus";
    _Bu = "Buckets";
    _C = "Credentials";
    _CA = "ChecksumAlgorithm";
    _CACL = "CannedACL";
    _CBC = "CreateBucketConfiguration";
    _CC = "CacheControl";
    _CCRC = "ChecksumCRC32";
    _CCRCC = "ChecksumCRC32C";
    _CD = "ContentDisposition";
    _CDr = "CreationDate";
    _CE = "ContentEncoding";
    _CF = "CloudFunction";
    _CFC = "CloudFunctionConfiguration";
    _CL = "ContentLanguage";
    _CLo = "ContentLength";
    _CM = "ChecksumMode";
    _CMD = "ContentMD5";
    _CMU = "CompletedMultipartUpload";
    _CORSC = "CORSConfiguration";
    _CORSR = "CORSRule";
    _CORSRu = "CORSRules";
    _CP = "CommonPrefixes";
    _CPo = "CompletedPart";
    _CR = "ContentRange";
    _CRSBA = "ConfirmRemoveSelfBucketAccess";
    _CS = "CopySource";
    _CSHA = "ChecksumSHA1";
    _CSHAh = "ChecksumSHA256";
    _CSIM = "CopySourceIfMatch";
    _CSIMS = "CopySourceIfModifiedSince";
    _CSINM = "CopySourceIfNoneMatch";
    _CSIUS = "CopySourceIfUnmodifiedSince";
    _CSR = "CopySourceRange";
    _CSSSECA = "CopySourceSSECustomerAlgorithm";
    _CSSSECK = "CopySourceSSECustomerKey";
    _CSSSECKMD = "CopySourceSSECustomerKeyMD5";
    _CSV = "CSV";
    _CSVI = "CopySourceVersionId";
    _CSVIn = "CSVInput";
    _CSVO = "CSVOutput";
    _CT = "ContentType";
    _CTo = "ContinuationToken";
    _CTom = "CompressionType";
    _Ch = "Checksum";
    _Co = "Contents";
    _Cod = "Code";
    _Com = "Comments";
    _Con = "Condition";
    _D = "Delimiter";
    _DAI = "DaysAfterInitiation";
    _DE = "DataExport";
    _DM = "DeleteMarker";
    _DMR = "DeleteMarkerReplication";
    _DMRS = "DeleteMarkerReplicationStatus";
    _DMVI = "DeleteMarkerVersionId";
    _DMe = "DeleteMarkers";
    _DN = "DisplayName";
    _DR = "DataRedundancy";
    _DRe = "DefaultRetention";
    _Da = "Days";
    _Dat = "Date";
    _De = "Deleted";
    _Del = "Delete";
    _Des = "Destination";
    _Desc = "Description";
    _E = "Expires";
    _EA = "EmailAddress";
    _EBC = "EventBridgeConfiguration";
    _EBO = "ExpectedBucketOwner";
    _EC = "ErrorCode";
    _ECn = "EncryptionConfiguration";
    _ED = "ErrorDocument";
    _EH = "ExposeHeaders";
    _EHx = "ExposeHeader";
    _EM = "ErrorMessage";
    _EODM = "ExpiredObjectDeleteMarker";
    _EOR = "ExistingObjectReplication";
    _EORS = "ExistingObjectReplicationStatus";
    _ERP = "EnableRequestProgress";
    _ES = "ExpiresString";
    _ESBO = "ExpectedSourceBucketOwner";
    _ESx = "ExpirationStatus";
    _ET = "EncodingType";
    _ETa = "ETag";
    _ETn = "EncryptionType";
    _ETv = "EventThreshold";
    _ETx = "ExpressionType";
    _En = "Encryption";
    _Ena = "Enabled";
    _End = "End";
    _Er = "Error";
    _Err = "Errors";
    _Ev = "Event";
    _Eve = "Events";
    _Ex = "Expression";
    _Exp = "Expiration";
    _F = "Filter";
    _FD = "FieldDelimiter";
    _FHI = "FileHeaderInfo";
    _FO = "FetchOwner";
    _FR = "FilterRule";
    _FRN = "FilterRuleName";
    _FRV = "FilterRuleValue";
    _FRi = "FilterRules";
    _Fi = "Field";
    _Fo = "Format";
    _Fr = "Frequency";
    _G = "Grant";
    _GFC = "GrantFullControl";
    _GJP = "GlacierJobParameters";
    _GR = "GrantRead";
    _GRACP = "GrantReadACP";
    _GW = "GrantWrite";
    _GWACP = "GrantWriteACP";
    _Gr = "Grants";
    _Gra = "Grantee";
    _HECRE = "HttpErrorCodeReturnedEquals";
    _HN = "HostName";
    _HRC = "HttpRedirectCode";
    _I = "Id";
    _IC = "InventoryConfiguration";
    _ICL = "InventoryConfigurationList";
    _ID = "IndexDocument";
    _ID_ = "ID";
    _IDn = "InventoryDestination";
    _IE = "IsEnabled";
    _IEn = "InventoryEncryption";
    _IF = "InventoryFilter";
    _IFn = "InventoryFormat";
    _IFnv = "InventoryFrequency";
    _II = "InventoryId";
    _IIOV = "InventoryIncludedObjectVersions";
    _IL = "IsLatest";
    _IM = "IfMatch";
    _IMS = "IfModifiedSince";
    _INM = "IfNoneMatch";
    _IOF = "InventoryOptionalField";
    _IOV = "IncludedObjectVersions";
    _IP = "IsPublic";
    _IPA = "IgnorePublicAcls";
    _IRIP = "IsRestoreInProgress";
    _IS = "InputSerialization";
    _ISBD = "InventoryS3BucketDestination";
    _ISn = "InventorySchedule";
    _IT = "IsTruncated";
    _ITAO = "IntelligentTieringAndOperator";
    _ITAT = "IntelligentTieringAccessTier";
    _ITC = "IntelligentTieringConfiguration";
    _ITCL = "IntelligentTieringConfigurationList";
    _ITD = "IntelligentTieringDays";
    _ITF = "IntelligentTieringFilter";
    _ITI = "IntelligentTieringId";
    _ITS = "IntelligentTieringStatus";
    _IUS = "IfUnmodifiedSince";
    _In = "Initiator";
    _Ini = "Initiated";
    _JSON = "JSON";
    _JSONI = "JSONInput";
    _JSONO = "JSONOutput";
    _JSONT = "JSONType";
    _K = "Key";
    _KC = "KeyCount";
    _KI = "KeyId";
    _KM = "KeyMarker";
    _KMSC = "KMSContext";
    _KMSKI = "KMSKeyId";
    _KMSMKID = "KMSMasterKeyID";
    _KPE = "KeyPrefixEquals";
    _L = "Location";
    _LC = "LocationConstraint";
    _LE = "LoggingEnabled";
    _LEi = "LifecycleExpiration";
    _LFA = "LambdaFunctionArn";
    _LFC = "LambdaFunctionConfigurations";
    _LFCa = "LambdaFunctionConfiguration";
    _LI = "LocationInfo";
    _LM = "LastModified";
    _LNAS = "LocationNameAsString";
    _LP = "LocationPrefix";
    _LR = "LifecycleRule";
    _LRAO = "LifecycleRuleAndOperator";
    _LRF = "LifecycleRuleFilter";
    _LT = "LocationType";
    _M = "Marker";
    _MAO = "MetricsAndOperator";
    _MAS = "MaxAgeSeconds";
    _MC = "MetricsConfiguration";
    _MCL = "MetricsConfigurationList";
    _MD = "MetadataDirective";
    _MDB = "MaxDirectoryBuckets";
    _MDf = "MfaDelete";
    _ME = "MetadataEntry";
    _MF = "MetricsFilter";
    _MFA = "MFA";
    _MFAD = "MFADelete";
    _MI = "MetricsId";
    _MK = "MaxKeys";
    _MKe = "MetadataKey";
    _MM = "MissingMeta";
    _MP = "MaxParts";
    _MS = "MetricsStatus";
    _MU = "MaxUploads";
    _MV = "MetadataValue";
    _Me = "Metrics";
    _Mes = "Message";
    _Mi = "Minutes";
    _Mo = "Mode";
    _N = "Name";
    _NC = "NotificationConfiguration";
    _NCF = "NotificationConfigurationFilter";
    _NCT = "NextContinuationToken";
    _ND = "NoncurrentDays";
    _NI = "NotificationId";
    _NKM = "NextKeyMarker";
    _NM = "NextMarker";
    _NNV = "NewerNoncurrentVersions";
    _NPNM = "NextPartNumberMarker";
    _NUIM = "NextUploadIdMarker";
    _NVE = "NoncurrentVersionExpiration";
    _NVIM = "NextVersionIdMarker";
    _NVT = "NoncurrentVersionTransitions";
    _NVTo = "NoncurrentVersionTransition";
    _O = "Owner";
    _OA = "ObjectAttributes";
    _OC = "OwnershipControls";
    _OCACL = "ObjectCannedACL";
    _OCR = "OwnershipControlsRule";
    _OF = "OptionalFields";
    _OI = "ObjectIdentifier";
    _OK = "ObjectKey";
    _OL = "OutputLocation";
    _OLC = "ObjectLockConfiguration";
    _OLE = "ObjectLockEnabled";
    _OLEFB = "ObjectLockEnabledForBucket";
    _OLLH = "ObjectLockLegalHold";
    _OLLHS = "ObjectLockLegalHoldStatus";
    _OLM = "ObjectLockMode";
    _OLR = "ObjectLockRetention";
    _OLRM = "ObjectLockRetentionMode";
    _OLRUD = "ObjectLockRetainUntilDate";
    _OLRb = "ObjectLockRule";
    _OO = "ObjectOwnership";
    _OOA = "OptionalObjectAttributes";
    _OOw = "OwnerOverride";
    _OP = "ObjectParts";
    _OS = "OutputSerialization";
    _OSGT = "ObjectSizeGreaterThan";
    _OSGTB = "ObjectSizeGreaterThanBytes";
    _OSLT = "ObjectSizeLessThan";
    _OSLTB = "ObjectSizeLessThanBytes";
    _OSV = "OutputSchemaVersion";
    _OSb = "ObjectSize";
    _OVI = "ObjectVersionId";
    _Ob = "Objects";
    _P = "Prefix";
    _PABC = "PublicAccessBlockConfiguration";
    _PC = "PartsCount";
    _PDS = "PartitionDateSource";
    _PI = "ParquetInput";
    _PN = "PartNumber";
    _PNM = "PartNumberMarker";
    _PP = "PartitionedPrefix";
    _Pa = "Payer";
    _Par = "Part";
    _Parq = "Parquet";
    _Part = "Parts";
    _Pe = "Permission";
    _Pr = "Protocol";
    _Pri = "Priority";
    _Q = "Quiet";
    _QA = "QueueArn";
    _QC = "QueueConfiguration";
    _QCu = "QueueConfigurations";
    _QCuo = "QuoteCharacter";
    _QEC = "QuoteEscapeCharacter";
    _QF = "QuoteFields";
    _Qu = "Queue";
    _R = "Range";
    _RART = "RedirectAllRequestsTo";
    _RC = "RequestCharged";
    _RCC = "ResponseCacheControl";
    _RCD = "ResponseContentDisposition";
    _RCE = "ResponseContentEncoding";
    _RCL = "ResponseContentLanguage";
    _RCT = "ResponseContentType";
    _RCe = "ReplicationConfiguration";
    _RD = "RecordDelimiter";
    _RE = "ResponseExpires";
    _RED = "RestoreExpiryDate";
    _RKKID = "ReplicaKmsKeyID";
    _RKPW = "ReplaceKeyPrefixWith";
    _RKW = "ReplaceKeyWith";
    _RM = "ReplicaModifications";
    _RMS = "ReplicaModificationsStatus";
    _ROP = "RestoreOutputPath";
    _RP = "RequestPayer";
    _RPB = "RestrictPublicBuckets";
    _RPC = "RequestPaymentConfiguration";
    _RPe = "RequestProgress";
    _RR = "RequestRoute";
    _RRAO = "ReplicationRuleAndOperator";
    _RRF = "ReplicationRuleFilter";
    _RRS = "ReplicationRuleStatus";
    _RRT = "RestoreRequestType";
    _RRe = "ReplicationRule";
    _RRes = "RestoreRequest";
    _RRo = "RoutingRules";
    _RRou = "RoutingRule";
    _RS = "ReplicationStatus";
    _RSe = "RestoreStatus";
    _RT = "RequestToken";
    _RTS = "ReplicationTimeStatus";
    _RTV = "ReplicationTimeValue";
    _RTe = "ReplicationTime";
    _RUD = "RetainUntilDate";
    _Re = "Restore";
    _Red = "Redirect";
    _Ro = "Role";
    _Ru = "Rule";
    _Rul = "Rules";
    _S = "Status";
    _SA = "StartAfter";
    _SAK = "SecretAccessKey";
    _SBD = "S3BucketDestination";
    _SC = "StorageClass";
    _SCA = "StorageClassAnalysis";
    _SCADE = "StorageClassAnalysisDataExport";
    _SCASV = "StorageClassAnalysisSchemaVersion";
    _SCt = "StatusCode";
    _SDV = "SkipDestinationValidation";
    _SK = "SSE-KMS";
    _SKEO = "SseKmsEncryptedObjects";
    _SKEOS = "SseKmsEncryptedObjectsStatus";
    _SKF = "S3KeyFilter";
    _SKe = "S3Key";
    _SL = "S3Location";
    _SM = "SessionMode";
    _SOCR = "SelectObjectContentRequest";
    _SP = "SelectParameters";
    _SPi = "SimplePrefix";
    _SR = "ScanRange";
    _SS = "SSE-S3";
    _SSC = "SourceSelectionCriteria";
    _SSE = "ServerSideEncryption";
    _SSEA = "SSEAlgorithm";
    _SSEBD = "ServerSideEncryptionByDefault";
    _SSEC = "ServerSideEncryptionConfiguration";
    _SSECA = "SSECustomerAlgorithm";
    _SSECK = "SSECustomerKey";
    _SSECKMD = "SSECustomerKeyMD5";
    _SSEKMS = "SSEKMS";
    _SSEKMSEC = "SSEKMSEncryptionContext";
    _SSEKMSKI = "SSEKMSKeyId";
    _SSER = "ServerSideEncryptionRule";
    _SSES = "SSES3";
    _ST = "SessionToken";
    _S_ = "S3";
    _Sc = "Schedule";
    _Se = "Setting";
    _Si = "Size";
    _St = "Start";
    _Su = "Suffix";
    _T = "Tagging";
    _TA = "TopicArn";
    _TB = "TargetBucket";
    _TC = "TagCount";
    _TCo = "TopicConfiguration";
    _TCop = "TopicConfigurations";
    _TD2 = "TaggingDirective";
    _TG = "TargetGrants";
    _TGa = "TargetGrant";
    _TOKF = "TargetObjectKeyFormat";
    _TP = "TargetPrefix";
    _TPC = "TotalPartsCount";
    _TS = "TagSet";
    _TSC = "TransitionStorageClass";
    _Ta = "Tag";
    _Tag = "Tags";
    _Ti = "Tier";
    _Tie = "Tierings";
    _Tier = "Tiering";
    _Tim = "Time";
    _To = "Token";
    _Top = "Topic";
    _Tr = "Transitions";
    _Tra = "Transition";
    _Ty = "Type";
    _U = "Upload";
    _UI = "UploadId";
    _UIM = "UploadIdMarker";
    _UM = "UserMetadata";
    _URI = "URI";
    _Up = "Uploads";
    _V = "Version";
    _VC = "VersionCount";
    _VCe = "VersioningConfiguration";
    _VI = "VersionId";
    _VIM = "VersionIdMarker";
    _Va = "Value";
    _Ve = "Versions";
    _WC = "WebsiteConfiguration";
    _WRL = "WebsiteRedirectLocation";
    _Y = "Years";
    _a = "analytics";
    _ac = "accelerate";
    _acl = "acl";
    _ar = "accept-ranges";
    _at = "attributes";
    _c = "cors";
    _cc = "cache-control";
    _cd = "content-disposition";
    _ce = "content-encoding";
    _cl = "content-language";
    _cl_ = "content-length";
    _cm = "content-md5";
    _cr = "content-range";
    _ct = "content-type";
    _ct_ = "continuation-token";
    _d = "delete";
    _de = "delimiter";
    _e = "expires";
    _en = "encryption";
    _et = "encoding-type";
    _eta = "etag";
    _ex = "expiresstring";
    _fo = "fetch-owner";
    _i = "id";
    _im = "if-match";
    _ims = "if-modified-since";
    _in = "inventory";
    _inm = "if-none-match";
    _it = "intelligent-tiering";
    _ius = "if-unmodified-since";
    _km = "key-marker";
    _l = "lifecycle";
    _lh = "legal-hold";
    _lm = "last-modified";
    _lo = "location";
    _log = "logging";
    _lt = "list-type";
    _m = "metrics";
    _ma = "marker";
    _mdb = "max-directory-buckets";
    _me = "member";
    _mk = "max-keys";
    _mp = "max-parts";
    _mu = "max-uploads";
    _n = "notification";
    _oC = "ownershipControls";
    _ol = "object-lock";
    _p = "policy";
    _pAB = "publicAccessBlock";
    _pN = "partNumber";
    _pS = "policyStatus";
    _pnm = "part-number-marker";
    _pr = "prefix";
    _r = "replication";
    _rP = "requestPayment";
    _ra = "range";
    _rcc = "response-cache-control";
    _rcd = "response-content-disposition";
    _rce = "response-content-encoding";
    _rcl = "response-content-language";
    _rct = "response-content-type";
    _re = "response-expires";
    _res = "restore";
    _ret = "retention";
    _s = "session";
    _sa = "start-after";
    _se = "select";
    _st = "select-type";
    _t = "tagging";
    _to = "torrent";
    _u = "uploads";
    _uI = "uploadId";
    _uim = "upload-id-marker";
    _v = "versioning";
    _vI = "versionId";
    _ve = '<?xml version="1.0" encoding="UTF-8"?>';
    _ver = "versions";
    _vim = "version-id-marker";
    _w = "website";
    _x = "xsi:type";
    _xaa = "x-amz-acl";
    _xaad = "x-amz-abort-date";
    _xaapa = "x-amz-access-point-alias";
    _xaari = "x-amz-abort-rule-id";
    _xaas = "x-amz-archive-status";
    _xabgr = "x-amz-bypass-governance-retention";
    _xabln = "x-amz-bucket-location-name";
    _xablt = "x-amz-bucket-location-type";
    _xabole = "x-amz-bucket-object-lock-enabled";
    _xabolt = "x-amz-bucket-object-lock-token";
    _xabr = "x-amz-bucket-region";
    _xaca = "x-amz-checksum-algorithm";
    _xacc = "x-amz-checksum-crc32";
    _xacc_ = "x-amz-checksum-crc32c";
    _xacm = "x-amz-checksum-mode";
    _xacrsba = "x-amz-confirm-remove-self-bucket-access";
    _xacs = "x-amz-checksum-sha1";
    _xacs_ = "x-amz-checksum-sha256";
    _xacs__ = "x-amz-copy-source";
    _xacsim = "x-amz-copy-source-if-match";
    _xacsims = "x-amz-copy-source-if-modified-since";
    _xacsinm = "x-amz-copy-source-if-none-match";
    _xacsius = "x-amz-copy-source-if-unmodified-since";
    _xacsm = "x-amz-create-session-mode";
    _xacsr = "x-amz-copy-source-range";
    _xacssseca = "x-amz-copy-source-server-side-encryption-customer-algorithm";
    _xacssseck = "x-amz-copy-source-server-side-encryption-customer-key";
    _xacssseckm = "x-amz-copy-source-server-side-encryption-customer-key-md5";
    _xacsvi = "x-amz-copy-source-version-id";
    _xadm = "x-amz-delete-marker";
    _xae = "x-amz-expiration";
    _xaebo = "x-amz-expected-bucket-owner";
    _xafec = "x-amz-fwd-error-code";
    _xafem = "x-amz-fwd-error-message";
    _xafhar = "x-amz-fwd-header-accept-ranges";
    _xafhcc = "x-amz-fwd-header-cache-control";
    _xafhcd = "x-amz-fwd-header-content-disposition";
    _xafhce = "x-amz-fwd-header-content-encoding";
    _xafhcl = "x-amz-fwd-header-content-language";
    _xafhcr = "x-amz-fwd-header-content-range";
    _xafhct = "x-amz-fwd-header-content-type";
    _xafhe = "x-amz-fwd-header-etag";
    _xafhe_ = "x-amz-fwd-header-expires";
    _xafhlm = "x-amz-fwd-header-last-modified";
    _xafhxacc = "x-amz-fwd-header-x-amz-checksum-crc32";
    _xafhxacc_ = "x-amz-fwd-header-x-amz-checksum-crc32c";
    _xafhxacs = "x-amz-fwd-header-x-amz-checksum-sha1";
    _xafhxacs_ = "x-amz-fwd-header-x-amz-checksum-sha256";
    _xafhxadm = "x-amz-fwd-header-x-amz-delete-marker";
    _xafhxae = "x-amz-fwd-header-x-amz-expiration";
    _xafhxamm = "x-amz-fwd-header-x-amz-missing-meta";
    _xafhxampc = "x-amz-fwd-header-x-amz-mp-parts-count";
    _xafhxaollh = "x-amz-fwd-header-x-amz-object-lock-legal-hold";
    _xafhxaolm = "x-amz-fwd-header-x-amz-object-lock-mode";
    _xafhxaolrud = "x-amz-fwd-header-x-amz-object-lock-retain-until-date";
    _xafhxar = "x-amz-fwd-header-x-amz-restore";
    _xafhxarc = "x-amz-fwd-header-x-amz-request-charged";
    _xafhxars = "x-amz-fwd-header-x-amz-replication-status";
    _xafhxasc = "x-amz-fwd-header-x-amz-storage-class";
    _xafhxasse = "x-amz-fwd-header-x-amz-server-side-encryption";
    _xafhxasseakki = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id";
    _xafhxassebke = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled";
    _xafhxasseca = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm";
    _xafhxasseckm = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5";
    _xafhxatc = "x-amz-fwd-header-x-amz-tagging-count";
    _xafhxavi = "x-amz-fwd-header-x-amz-version-id";
    _xafs = "x-amz-fwd-status";
    _xagfc = "x-amz-grant-full-control";
    _xagr = "x-amz-grant-read";
    _xagra = "x-amz-grant-read-acp";
    _xagw = "x-amz-grant-write";
    _xagwa = "x-amz-grant-write-acp";
    _xam = "x-amz-mfa";
    _xamd = "x-amz-metadata-directive";
    _xamm = "x-amz-missing-meta";
    _xamp = "x-amz-max-parts";
    _xampc = "x-amz-mp-parts-count";
    _xaoa = "x-amz-object-attributes";
    _xaollh = "x-amz-object-lock-legal-hold";
    _xaolm = "x-amz-object-lock-mode";
    _xaolrud = "x-amz-object-lock-retain-until-date";
    _xaoo = "x-amz-object-ownership";
    _xaooa = "x-amz-optional-object-attributes";
    _xapnm = "x-amz-part-number-marker";
    _xar = "x-amz-restore";
    _xarc = "x-amz-request-charged";
    _xarop = "x-amz-restore-output-path";
    _xarp = "x-amz-request-payer";
    _xarr = "x-amz-request-route";
    _xars = "x-amz-replication-status";
    _xart = "x-amz-request-token";
    _xasc = "x-amz-storage-class";
    _xasca = "x-amz-sdk-checksum-algorithm";
    _xasdv = "x-amz-skip-destination-validation";
    _xasebo = "x-amz-source-expected-bucket-owner";
    _xasse = "x-amz-server-side-encryption";
    _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
    _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
    _xassec = "x-amz-server-side-encryption-context";
    _xasseca = "x-amz-server-side-encryption-customer-algorithm";
    _xasseck = "x-amz-server-side-encryption-customer-key";
    _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
    _xat = "x-amz-tagging";
    _xatc = "x-amz-tagging-count";
    _xatd = "x-amz-tagging-directive";
    _xavi = "x-amz-version-id";
    _xawrl = "x-amz-website-redirect-location";
    _xi = "x-id";
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
var CreateSessionCommand;
var init_CreateSessionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CreateSessionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/package.json
var package_default;
var init_package = __esm({
  "../node_modules/@aws-sdk/client-s3/package.json"() {
    package_default = {
      name: "@aws-sdk/client-s3",
      description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
      version: "3.576.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-s3",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
        test: "yarn test:unit",
        "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
        "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
        "test:e2e:node": "jest --c jest.config.e2e.js",
        "test:unit": "ts-mocha test/unit/**/*.spec.ts"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha1-browser": "3.0.0",
        "@aws-crypto/sha256-browser": "3.0.0",
        "@aws-crypto/sha256-js": "3.0.0",
        "@aws-sdk/client-sso-oidc": "3.576.0",
        "@aws-sdk/client-sts": "3.576.0",
        "@aws-sdk/core": "3.576.0",
        "@aws-sdk/credential-provider-node": "3.576.0",
        "@aws-sdk/middleware-bucket-endpoint": "3.575.0",
        "@aws-sdk/middleware-expect-continue": "3.575.0",
        "@aws-sdk/middleware-flexible-checksums": "3.575.0",
        "@aws-sdk/middleware-host-header": "3.575.0",
        "@aws-sdk/middleware-location-constraint": "3.575.0",
        "@aws-sdk/middleware-logger": "3.575.0",
        "@aws-sdk/middleware-recursion-detection": "3.575.0",
        "@aws-sdk/middleware-sdk-s3": "3.575.0",
        "@aws-sdk/middleware-signing": "3.575.0",
        "@aws-sdk/middleware-ssec": "3.575.0",
        "@aws-sdk/middleware-user-agent": "3.575.0",
        "@aws-sdk/region-config-resolver": "3.575.0",
        "@aws-sdk/signature-v4-multi-region": "3.575.0",
        "@aws-sdk/types": "3.575.0",
        "@aws-sdk/util-endpoints": "3.575.0",
        "@aws-sdk/util-user-agent-browser": "3.575.0",
        "@aws-sdk/util-user-agent-node": "3.575.0",
        "@aws-sdk/xml-builder": "3.575.0",
        "@smithy/config-resolver": "^3.0.0",
        "@smithy/core": "^2.0.0",
        "@smithy/eventstream-serde-browser": "^3.0.0",
        "@smithy/eventstream-serde-config-resolver": "^3.0.0",
        "@smithy/eventstream-serde-node": "^3.0.0",
        "@smithy/fetch-http-handler": "^3.0.0",
        "@smithy/hash-blob-browser": "^3.0.0",
        "@smithy/hash-node": "^3.0.0",
        "@smithy/hash-stream-node": "^3.0.0",
        "@smithy/invalid-dependency": "^3.0.0",
        "@smithy/md5-js": "^3.0.0",
        "@smithy/middleware-content-length": "^3.0.0",
        "@smithy/middleware-endpoint": "^3.0.0",
        "@smithy/middleware-retry": "^3.0.0",
        "@smithy/middleware-serde": "^3.0.0",
        "@smithy/middleware-stack": "^3.0.0",
        "@smithy/node-config-provider": "^3.0.0",
        "@smithy/node-http-handler": "^3.0.0",
        "@smithy/protocol-http": "^4.0.0",
        "@smithy/smithy-client": "^3.0.0",
        "@smithy/types": "^3.0.0",
        "@smithy/url-parser": "^3.0.0",
        "@smithy/util-base64": "^3.0.0",
        "@smithy/util-body-length-browser": "^3.0.0",
        "@smithy/util-body-length-node": "^3.0.0",
        "@smithy/util-defaults-mode-browser": "^3.0.0",
        "@smithy/util-defaults-mode-node": "^3.0.0",
        "@smithy/util-endpoints": "^2.0.0",
        "@smithy/util-retry": "^3.0.0",
        "@smithy/util-stream": "^3.0.0",
        "@smithy/util-utf8": "^3.0.0",
        "@smithy/util-waiter": "^3.0.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        "@aws-sdk/signature-v4-crt": "3.575.0",
        "@tsconfig/node16": "16.1.3",
        "@types/chai": "^4.2.11",
        "@types/mocha": "^8.0.4",
        "@types/node": "^16.18.96",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~4.9.5"
      },
      engines: {
        node: ">=16.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-s3"
      }
    };
  }
});

// ../node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/constants.js
var require_constants = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/constants.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_1 = exports.SHA_1_HMAC_ALGO = exports.SHA_1_HASH = void 0;
    exports.SHA_1_HASH = { name: "SHA-1" };
    exports.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_1_HASH
    };
    exports.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }
});

// ../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
var require_pureJs = __commonJS({
  "../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var fromUtf82 = (input) => {
      const bytes = [];
      for (let i2 = 0, len = input.length; i2 < len; i2++) {
        const value = input.charCodeAt(i2);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i2 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i2 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i2) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    exports.fromUtf8 = fromUtf82;
    var toUtf82 = (input) => {
      let decoded = "";
      for (let i2 = 0, len = input.length; i2 < len; i2++) {
        const byte = input[i2];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i2];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i2], input[++i2], input[++i2]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i2] & 63) << 6 | input[++i2] & 63);
        }
      }
      return decoded;
    };
    exports.toUtf8 = toUtf82;
  }
});

// ../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
var require_whatwgEncodingApi = __commonJS({
  "../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    function fromUtf82(input) {
      return new TextEncoder().encode(input);
    }
    exports.fromUtf8 = fromUtf82;
    function toUtf82(input) {
      return new TextDecoder("utf-8").decode(input);
    }
    exports.toUtf8 = toUtf82;
  }
});

// ../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var pureJs_1 = require_pureJs();
    var whatwgEncodingApi_1 = require_whatwgEncodingApi();
    var fromUtf82 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
    exports.fromUtf8 = fromUtf82;
    var toUtf82 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
    exports.toUtf8 = toUtf82;
  }
});

// ../node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "../node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      locateWindow: () => locateWindow
    });
    module.exports = __toCommonJS(src_exports);
    var fallbackWindow = {};
    function locateWindow() {
      if (typeof window !== "undefined") {
        return window;
      } else if (typeof self !== "undefined") {
        return self;
      }
      return fallbackWindow;
    }
    __name(locateWindow, "locateWindow");
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js
var require_ie11Sha1 = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var isEmptyData_1 = require_isEmptyData();
    var constants_1 = require_constants();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          this.secret = secret;
          this.reset();
        }
        Sha13.prototype.update = function(toHash) {
          var _this = this;
          if ((0, isEmptyData_1.isEmptyData)(toHash)) {
            return;
          }
          this.operation = this.operation.then(function(operation) {
            operation.onerror = function() {
              _this.operation = Promise.reject(new Error("Error encountered updating hash"));
            };
            operation.process(toArrayBufferView(toHash));
            return operation;
          });
          this.operation.catch(function() {
          });
        };
        Sha13.prototype.digest = function() {
          return this.operation.then(function(operation) {
            return new Promise(function(resolve, reject) {
              operation.onerror = function() {
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.oncomplete = function() {
                if (operation.result) {
                  resolve(new Uint8Array(operation.result));
                }
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.finish();
            });
          });
        };
        Sha13.prototype.reset = function() {
          if (this.secret) {
            this.operation = getKeyPromise(this.secret).then(function(keyData) {
              return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, keyData);
            });
            this.operation.catch(function() {
            });
          } else {
            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-1"));
          }
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js
var require_webCryptoSha1 = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var isEmptyData_1 = require_isEmptyData();
    var constants_1 = require_constants();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          this.toHash = new Uint8Array(0);
          if (secret !== void 0) {
            this.key = new Promise(function(resolve, reject) {
              (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", convertToBuffer2(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
            });
            this.key.catch(function() {
            });
          }
        }
        Sha13.prototype.update = function(data) {
          if ((0, isEmptyData_1.isEmptyData)(data)) {
            return;
          }
          var update = convertToBuffer2(data);
          var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
          typedArray.set(this.toHash, 0);
          typedArray.set(update, this.toHash.byteLength);
          this.toHash = typedArray;
        };
        Sha13.prototype.digest = function() {
          var _this = this;
          if (this.key) {
            return this.key.then(function(key) {
              return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, key, _this.toHash).then(function(data) {
                return new Uint8Array(data);
              });
            });
          }
          if ((0, isEmptyData_1.isEmptyData)(this.toHash)) {
            return Promise.resolve(constants_1.EMPTY_DATA_SHA_1);
          }
          return Promise.resolve().then(function() {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_1_HASH, _this.toHash);
          }).then(function(data) {
            return Promise.resolve(new Uint8Array(data));
          });
        };
        Sha13.prototype.reset = function() {
          this.toHash = new Uint8Array(0);
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
    function convertToBuffer2(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "../node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js
var require_supportsWebCrypto = __commonJS({
  "../node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportsZeroByteGCM = exports.supportsSubtleCrypto = exports.supportsSecureRandom = exports.supportsWebCrypto = void 0;
    var tslib_1 = require_tslib2();
    var subtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function supportsWebCrypto(window2) {
      if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
        var subtle = window2.crypto.subtle;
        return supportsSubtleCrypto(subtle);
      }
      return false;
    }
    exports.supportsWebCrypto = supportsWebCrypto;
    function supportsSecureRandom(window2) {
      if (typeof window2 === "object" && typeof window2.crypto === "object") {
        var getRandomValues2 = window2.crypto.getRandomValues;
        return typeof getRandomValues2 === "function";
      }
      return false;
    }
    exports.supportsSecureRandom = supportsSecureRandom;
    function supportsSubtleCrypto(subtle) {
      return subtle && subtleCryptoMethods.every(function(methodName) {
        return typeof subtle[methodName] === "function";
      });
    }
    exports.supportsSubtleCrypto = supportsSubtleCrypto;
    function supportsZeroByteGCM(subtle) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var key, zeroByteAuthTag, _a2;
        return tslib_1.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!supportsSubtleCrypto(subtle))
                return [2, false];
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
            case 2:
              key = _b.sent();
              return [4, subtle.encrypt({
                name: "AES-GCM",
                iv: new Uint8Array(Array(12)),
                additionalData: new Uint8Array(Array(16)),
                tagLength: 128
              }, key, new Uint8Array(0))];
            case 3:
              zeroByteAuthTag = _b.sent();
              return [2, zeroByteAuthTag.byteLength === 16];
            case 4:
              _a2 = _b.sent();
              return [2, false];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.supportsZeroByteGCM = supportsZeroByteGCM;
  }
});

// ../node_modules/@aws-crypto/supports-web-crypto/build/index.js
var require_build = __commonJS({
  "../node_modules/@aws-crypto/supports-web-crypto/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib2();
    tslib_1.__exportStar(require_supportsWebCrypto(), exports);
  }
});

// ../node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js
var require_CryptoOperation = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/Key.js
var require_Key = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/Key.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js
var require_KeyOperation = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js
var require_MsSubtleCrypto = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/MsWindow.js
var require_MsWindow = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/MsWindow.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsWindow = void 0;
    var msSubtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function quacksLikeAnMsWindow(window2) {
      return "MSInputMethodContext" in window2 && "msCrypto" in window2;
    }
    function isMsWindow(window2) {
      if (quacksLikeAnMsWindow(window2) && window2.msCrypto.subtle !== void 0) {
        var _a2 = window2.msCrypto, getRandomValues2 = _a2.getRandomValues, subtle_1 = _a2.subtle;
        return msSubtleCryptoMethods.map(function(methodName) {
          return subtle_1[methodName];
        }).concat(getRandomValues2).every(function(method) {
          return typeof method === "function";
        });
      }
      return false;
    }
    exports.isMsWindow = isMsWindow;
  }
});

// ../node_modules/@aws-crypto/ie11-detection/build/index.js
var require_build2 = __commonJS({
  "../node_modules/@aws-crypto/ie11-detection/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib3();
    tslib_1.__exportStar(require_CryptoOperation(), exports);
    tslib_1.__exportStar(require_Key(), exports);
    tslib_1.__exportStar(require_KeyOperation(), exports);
    tslib_1.__exportStar(require_MsSubtleCrypto(), exports);
    tslib_1.__exportStar(require_MsWindow(), exports);
  }
});

// ../node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "../node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var fromUtf82 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer2(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf82(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer2;
  }
});

// ../node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData2 = __commonJS({
  "../node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// ../node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "../node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// ../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// ../node_modules/@aws-crypto/util/build/index.js
var require_build3 = __commonJS({
  "../node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData2();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js
var require_crossPlatformSha1 = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var ie11Sha1_1 = require_ie11Sha1();
    var webCryptoSha1_1 = require_webCryptoSha1();
    var supports_web_crypto_1 = require_build();
    var ie11_detection_1 = require_build2();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build3();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new webCryptoSha1_1.Sha1(secret);
          } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new ie11Sha1_1.Sha1(secret);
          } else {
            throw new Error("SHA1 not supported");
          }
        }
        Sha13.prototype.update = function(data, encoding) {
          this.hash.update((0, util_1.convertToBuffer)(data));
        };
        Sha13.prototype.digest = function() {
          return this.hash.digest();
        };
        Sha13.prototype.reset = function() {
          this.hash.reset();
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
  }
});

// ../node_modules/@aws-crypto/sha1-browser/build/index.js
var require_build4 = __commonJS({
  "../node_modules/@aws-crypto/sha1-browser/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha1 = exports.Ie11Sha1 = void 0;
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_crossPlatformSha1(), exports);
    var ie11Sha1_1 = require_ie11Sha1();
    Object.defineProperty(exports, "Ie11Sha1", { enumerable: true, get: function() {
      return ie11Sha1_1.Sha1;
    } });
    var webCryptoSha1_1 = require_webCryptoSha1();
    Object.defineProperty(exports, "WebCryptoSha1", { enumerable: true, get: function() {
      return webCryptoSha1_1.Sha1;
    } });
  }
});

// ../node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js
var require_tslib4 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js
var require_isEmptyData3 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData2(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData2;
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/constants.js
var require_constants2 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/constants.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    exports.SHA_256_HASH = { name: "SHA-256" };
    exports.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_256_HASH
    };
    exports.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js
var require_ie11Sha256 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var isEmptyData_1 = require_isEmptyData3();
    var constants_1 = require_constants2();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.secret = secret;
          this.reset();
        }
        Sha2563.prototype.update = function(toHash) {
          var _this = this;
          if ((0, isEmptyData_1.isEmptyData)(toHash)) {
            return;
          }
          this.operation = this.operation.then(function(operation) {
            operation.onerror = function() {
              _this.operation = Promise.reject(new Error("Error encountered updating hash"));
            };
            operation.process(toArrayBufferView(toHash));
            return operation;
          });
          this.operation.catch(function() {
          });
        };
        Sha2563.prototype.digest = function() {
          return this.operation.then(function(operation) {
            return new Promise(function(resolve, reject) {
              operation.onerror = function() {
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.oncomplete = function() {
                if (operation.result) {
                  resolve(new Uint8Array(operation.result));
                }
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.finish();
            });
          });
        };
        Sha2563.prototype.reset = function() {
          if (this.secret) {
            this.operation = getKeyPromise(this.secret).then(function(keyData) {
              return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
            });
            this.operation.catch(function() {
            });
          } else {
            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js
var require_webCryptoSha256 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var util_1 = require_build3();
    var constants_1 = require_constants2();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.toHash = new Uint8Array(0);
          this.secret = secret;
          this.reset();
        }
        Sha2563.prototype.update = function(data) {
          if ((0, util_1.isEmptyData)(data)) {
            return;
          }
          var update = (0, util_1.convertToBuffer)(data);
          var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
          typedArray.set(this.toHash, 0);
          typedArray.set(update, this.toHash.byteLength);
          this.toHash = typedArray;
        };
        Sha2563.prototype.digest = function() {
          var _this = this;
          if (this.key) {
            return this.key.then(function(key) {
              return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
                return new Uint8Array(data);
              });
            });
          }
          if ((0, util_1.isEmptyData)(this.toHash)) {
            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
          }
          return Promise.resolve().then(function() {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
          }).then(function(data) {
            return Promise.resolve(new Uint8Array(data));
          });
        };
        Sha2563.prototype.reset = function() {
          var _this = this;
          this.toHash = new Uint8Array(0);
          if (this.secret && this.secret !== void 0) {
            this.key = new Promise(function(resolve, reject) {
              (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
            });
            this.key.catch(function() {
            });
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
  }
});

// ../node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js
var require_tslib5 = __commonJS({
  "../node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/sha256-js/build/constants.js
var require_constants3 = __commonJS({
  "../node_modules/@aws-crypto/sha256-js/build/constants.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
    exports.BLOCK_SIZE = 64;
    exports.DIGEST_LENGTH = 32;
    exports.KEY = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    exports.INIT = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
  }
});

// ../node_modules/@aws-crypto/sha256-js/build/RawSha256.js
var require_RawSha256 = __commonJS({
  "../node_modules/@aws-crypto/sha256-js/build/RawSha256.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawSha256 = void 0;
    var constants_1 = require_constants3();
    var RawSha256 = (
      /** @class */
      function() {
        function RawSha2562() {
          this.state = Int32Array.from(constants_1.INIT);
          this.temp = new Int32Array(64);
          this.buffer = new Uint8Array(64);
          this.bufferLength = 0;
          this.bytesHashed = 0;
          this.finished = false;
        }
        RawSha2562.prototype.update = function(data) {
          if (this.finished) {
            throw new Error("Attempted to update an already finished hash.");
          }
          var position = 0;
          var byteLength2 = data.byteLength;
          this.bytesHashed += byteLength2;
          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          }
          while (byteLength2 > 0) {
            this.buffer[this.bufferLength++] = data[position++];
            byteLength2--;
            if (this.bufferLength === constants_1.BLOCK_SIZE) {
              this.hashBuffer();
              this.bufferLength = 0;
            }
          }
        };
        RawSha2562.prototype.digest = function() {
          if (!this.finished) {
            var bitsHashed = this.bytesHashed * 8;
            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            var undecoratedLength = this.bufferLength;
            bufferView.setUint8(this.bufferLength++, 128);
            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
              for (var i2 = this.bufferLength; i2 < constants_1.BLOCK_SIZE; i2++) {
                bufferView.setUint8(i2, 0);
              }
              this.hashBuffer();
              this.bufferLength = 0;
            }
            for (var i2 = this.bufferLength; i2 < constants_1.BLOCK_SIZE - 8; i2++) {
              bufferView.setUint8(i2, 0);
            }
            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
            this.hashBuffer();
            this.finished = true;
          }
          var out = new Uint8Array(constants_1.DIGEST_LENGTH);
          for (var i2 = 0; i2 < 8; i2++) {
            out[i2 * 4] = this.state[i2] >>> 24 & 255;
            out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
            out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
            out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
          }
          return out;
        };
        RawSha2562.prototype.hashBuffer = function() {
          var _a2 = this, buffer2 = _a2.buffer, state = _a2.state;
          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
          for (var i2 = 0; i2 < constants_1.BLOCK_SIZE; i2++) {
            if (i2 < 16) {
              this.temp[i2] = (buffer2[i2 * 4] & 255) << 24 | (buffer2[i2 * 4 + 1] & 255) << 16 | (buffer2[i2 * 4 + 2] & 255) << 8 | buffer2[i2 * 4 + 3] & 255;
            } else {
              var u2 = this.temp[i2 - 2];
              var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
              u2 = this.temp[i2 - 15];
              var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
              this.temp[i2] = (t1_1 + this.temp[i2 - 7] | 0) + (t2_1 + this.temp[i2 - 16] | 0);
            }
            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i2] + this.temp[i2] | 0) | 0) | 0;
            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
            state7 = state6;
            state6 = state5;
            state5 = state4;
            state4 = state3 + t1 | 0;
            state3 = state2;
            state2 = state1;
            state1 = state0;
            state0 = t1 + t2 | 0;
          }
          state[0] += state0;
          state[1] += state1;
          state[2] += state2;
          state[3] += state3;
          state[4] += state4;
          state[5] += state5;
          state[6] += state6;
          state[7] += state7;
        };
        return RawSha2562;
      }()
    );
    exports.RawSha256 = RawSha256;
  }
});

// ../node_modules/@aws-crypto/sha256-js/build/jsSha256.js
var require_jsSha256 = __commonJS({
  "../node_modules/@aws-crypto/sha256-js/build/jsSha256.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var tslib_1 = require_tslib5();
    var constants_1 = require_constants3();
    var RawSha256_1 = require_RawSha256();
    var util_1 = require_build3();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.secret = secret;
          this.hash = new RawSha256_1.RawSha256();
          this.reset();
        }
        Sha2563.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash) || this.error) {
            return;
          }
          try {
            this.hash.update((0, util_1.convertToBuffer)(toHash));
          } catch (e2) {
            this.error = e2;
          }
        };
        Sha2563.prototype.digestSync = function() {
          if (this.error) {
            throw this.error;
          }
          if (this.outer) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest();
          }
          return this.hash.digest();
        };
        Sha2563.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, this.digestSync()];
            });
          });
        };
        Sha2563.prototype.reset = function() {
          this.hash = new RawSha256_1.RawSha256();
          if (this.secret) {
            this.outer = new RawSha256_1.RawSha256();
            var inner = bufferFromSecret(this.secret);
            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
            outer.set(inner);
            for (var i2 = 0; i2 < constants_1.BLOCK_SIZE; i2++) {
              inner[i2] ^= 54;
              outer[i2] ^= 92;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i2 = 0; i2 < inner.byteLength; i2++) {
              inner[i2] = 0;
            }
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
    function bufferFromSecret(secret) {
      var input = (0, util_1.convertToBuffer)(secret);
      if (input.byteLength > constants_1.BLOCK_SIZE) {
        var bufferHash = new RawSha256_1.RawSha256();
        bufferHash.update(input);
        input = bufferHash.digest();
      }
      var buffer2 = new Uint8Array(constants_1.BLOCK_SIZE);
      buffer2.set(input);
      return buffer2;
    }
  }
});

// ../node_modules/@aws-crypto/sha256-js/build/index.js
var require_build5 = __commonJS({
  "../node_modules/@aws-crypto/sha256-js/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    tslib_1.__exportStar(require_jsSha256(), exports);
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js
var require_crossPlatformSha256 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var ie11Sha256_1 = require_ie11Sha256();
    var webCryptoSha256_1 = require_webCryptoSha256();
    var sha256_js_1 = require_build5();
    var supports_web_crypto_1 = require_build();
    var ie11_detection_1 = require_build2();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build3();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new webCryptoSha256_1.Sha256(secret);
          } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new ie11Sha256_1.Sha256(secret);
          } else {
            this.hash = new sha256_js_1.Sha256(secret);
          }
        }
        Sha2563.prototype.update = function(data, encoding) {
          this.hash.update((0, util_1.convertToBuffer)(data));
        };
        Sha2563.prototype.digest = function() {
          return this.hash.digest();
        };
        Sha2563.prototype.reset = function() {
          this.hash.reset();
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
  }
});

// ../node_modules/@aws-crypto/sha256-browser/build/index.js
var require_build6 = __commonJS({
  "../node_modules/@aws-crypto/sha256-browser/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    var tslib_1 = require_tslib4();
    tslib_1.__exportStar(require_crossPlatformSha256(), exports);
    var ie11Sha256_1 = require_ie11Sha256();
    Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function() {
      return ie11Sha256_1.Sha256;
    } });
    var webCryptoSha256_1 = require_webCryptoSha256();
    Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function() {
      return webCryptoSha256_1.Sha256;
    } });
  }
});

// ../node_modules/bowser/es5.js
var require_es5 = __commonJS({
  "../node_modules/bowser/es5.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    !function(e2, t2) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define([], t2) : "object" == typeof exports ? exports.bowser = t2() : e2.bowser = t2();
    }(exports, function() {
      return function(e2) {
        var t2 = {};
        function r2(n2) {
          if (t2[n2])
            return t2[n2].exports;
          var i2 = t2[n2] = { i: n2, l: false, exports: {} };
          return e2[n2].call(i2.exports, i2, i2.exports, r2), i2.l = true, i2.exports;
        }
        return r2.m = e2, r2.c = t2, r2.d = function(e3, t3, n2) {
          r2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: n2 });
        }, r2.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, r2.t = function(e3, t3) {
          if (1 & t3 && (e3 = r2(e3)), 8 & t3)
            return e3;
          if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
            return e3;
          var n2 = /* @__PURE__ */ Object.create(null);
          if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
            for (var i2 in e3)
              r2.d(n2, i2, function(t4) {
                return e3[t4];
              }.bind(null, i2));
          return n2;
        }, r2.n = function(e3) {
          var t3 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return r2.d(t3, "a", t3), t3;
        }, r2.o = function(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }, r2.p = "", r2(r2.s = 90);
      }({ 17: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2 = r2(18), i2 = function() {
          function e3() {
          }
          return e3.getFirstMatch = function(e4, t3) {
            var r3 = t3.match(e4);
            return r3 && r3.length > 0 && r3[1] || "";
          }, e3.getSecondMatch = function(e4, t3) {
            var r3 = t3.match(e4);
            return r3 && r3.length > 1 && r3[2] || "";
          }, e3.matchAndReturnConst = function(e4, t3, r3) {
            if (e4.test(t3))
              return r3;
          }, e3.getWindowsVersionName = function(e4) {
            switch (e4) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e3.getMacOSVersionName = function(e4) {
            var t3 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t3.push(0), 10 === t3[0])
              switch (t3[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
          }, e3.getAndroidVersionName = function(e4) {
            var t3 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t3.push(0), !(1 === t3[0] && t3[1] < 5))
              return 1 === t3[0] && t3[1] < 6 ? "Cupcake" : 1 === t3[0] && t3[1] >= 6 ? "Donut" : 2 === t3[0] && t3[1] < 2 ? "Eclair" : 2 === t3[0] && 2 === t3[1] ? "Froyo" : 2 === t3[0] && t3[1] > 2 ? "Gingerbread" : 3 === t3[0] ? "Honeycomb" : 4 === t3[0] && t3[1] < 1 ? "Ice Cream Sandwich" : 4 === t3[0] && t3[1] < 4 ? "Jelly Bean" : 4 === t3[0] && t3[1] >= 4 ? "KitKat" : 5 === t3[0] ? "Lollipop" : 6 === t3[0] ? "Marshmallow" : 7 === t3[0] ? "Nougat" : 8 === t3[0] ? "Oreo" : 9 === t3[0] ? "Pie" : void 0;
          }, e3.getVersionPrecision = function(e4) {
            return e4.split(".").length;
          }, e3.compareVersions = function(t3, r3, n3) {
            void 0 === n3 && (n3 = false);
            var i3 = e3.getVersionPrecision(t3), s2 = e3.getVersionPrecision(r3), a2 = Math.max(i3, s2), o2 = 0, u2 = e3.map([t3, r3], function(t4) {
              var r4 = a2 - e3.getVersionPrecision(t4), n4 = t4 + new Array(r4 + 1).join(".0");
              return e3.map(n4.split("."), function(e4) {
                return new Array(20 - e4.length).join("0") + e4;
              }).reverse();
            });
            for (n3 && (o2 = a2 - Math.min(i3, s2)), a2 -= 1; a2 >= o2; ) {
              if (u2[0][a2] > u2[1][a2])
                return 1;
              if (u2[0][a2] === u2[1][a2]) {
                if (a2 === o2)
                  return 0;
                a2 -= 1;
              } else if (u2[0][a2] < u2[1][a2])
                return -1;
            }
          }, e3.map = function(e4, t3) {
            var r3, n3 = [];
            if (Array.prototype.map)
              return Array.prototype.map.call(e4, t3);
            for (r3 = 0; r3 < e4.length; r3 += 1)
              n3.push(t3(e4[r3]));
            return n3;
          }, e3.find = function(e4, t3) {
            var r3, n3;
            if (Array.prototype.find)
              return Array.prototype.find.call(e4, t3);
            for (r3 = 0, n3 = e4.length; r3 < n3; r3 += 1) {
              var i3 = e4[r3];
              if (t3(i3, r3))
                return i3;
            }
          }, e3.assign = function(e4) {
            for (var t3, r3, n3 = e4, i3 = arguments.length, s2 = new Array(i3 > 1 ? i3 - 1 : 0), a2 = 1; a2 < i3; a2++)
              s2[a2 - 1] = arguments[a2];
            if (Object.assign)
              return Object.assign.apply(Object, [e4].concat(s2));
            var o2 = function() {
              var e5 = s2[t3];
              "object" == typeof e5 && null !== e5 && Object.keys(e5).forEach(function(t4) {
                n3[t4] = e5[t4];
              });
            };
            for (t3 = 0, r3 = s2.length; t3 < r3; t3 += 1)
              o2();
            return e4;
          }, e3.getBrowserAlias = function(e4) {
            return n2.BROWSER_ALIASES_MAP[e4];
          }, e3.getBrowserTypeByAlias = function(e4) {
            return n2.BROWSER_MAP[e4] || "";
          }, e3;
        }();
        t2.default = i2, e2.exports = t2.default;
      }, 18: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.ENGINE_MAP = t2.OS_MAP = t2.PLATFORMS_MAP = t2.BROWSER_MAP = t2.BROWSER_ALIASES_MAP = void 0;
        t2.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
        t2.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
        t2.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
        t2.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
        t2.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
      }, 90: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(91)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        function a2(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        var o2 = function() {
          function e3() {
          }
          var t3, r3, n3;
          return e3.getParser = function(e4, t4) {
            if (void 0 === t4 && (t4 = false), "string" != typeof e4)
              throw new Error("UserAgent should be a string");
            return new i2.default(e4, t4);
          }, e3.parse = function(e4) {
            return new i2.default(e4).getResult();
          }, t3 = e3, n3 = [{ key: "BROWSER_MAP", get: function() {
            return s2.BROWSER_MAP;
          } }, { key: "ENGINE_MAP", get: function() {
            return s2.ENGINE_MAP;
          } }, { key: "OS_MAP", get: function() {
            return s2.OS_MAP;
          } }, { key: "PLATFORMS_MAP", get: function() {
            return s2.PLATFORMS_MAP;
          } }], (r3 = null) && a2(t3.prototype, r3), n3 && a2(t3, n3), e3;
        }();
        t2.default = o2, e2.exports = t2.default;
      }, 91: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2 = u2(r2(92)), i2 = u2(r2(93)), s2 = u2(r2(94)), a2 = u2(r2(95)), o2 = u2(r2(17));
        function u2(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var d2 = function() {
          function e3(e4, t4) {
            if (void 0 === t4 && (t4 = false), null == e4 || "" === e4)
              throw new Error("UserAgent parameter can't be empty");
            this._ua = e4, this.parsedResult = {}, true !== t4 && this.parse();
          }
          var t3 = e3.prototype;
          return t3.getUA = function() {
            return this._ua;
          }, t3.test = function(e4) {
            return e4.test(this._ua);
          }, t3.parseBrowser = function() {
            var e4 = this;
            this.parsedResult.browser = {};
            var t4 = o2.default.find(n2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.browser = t4.describe(this.getUA())), this.parsedResult.browser;
          }, t3.getBrowser = function() {
            return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
          }, t3.getBrowserName = function(e4) {
            return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
          }, t3.getBrowserVersion = function() {
            return this.getBrowser().version;
          }, t3.getOS = function() {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }, t3.parseOS = function() {
            var e4 = this;
            this.parsedResult.os = {};
            var t4 = o2.default.find(i2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.os = t4.describe(this.getUA())), this.parsedResult.os;
          }, t3.getOSName = function(e4) {
            var t4 = this.getOS().name;
            return e4 ? String(t4).toLowerCase() || "" : t4 || "";
          }, t3.getOSVersion = function() {
            return this.getOS().version;
          }, t3.getPlatform = function() {
            return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
          }, t3.getPlatformType = function(e4) {
            void 0 === e4 && (e4 = false);
            var t4 = this.getPlatform().type;
            return e4 ? String(t4).toLowerCase() || "" : t4 || "";
          }, t3.parsePlatform = function() {
            var e4 = this;
            this.parsedResult.platform = {};
            var t4 = o2.default.find(s2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.platform = t4.describe(this.getUA())), this.parsedResult.platform;
          }, t3.getEngine = function() {
            return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
          }, t3.getEngineName = function(e4) {
            return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
          }, t3.parseEngine = function() {
            var e4 = this;
            this.parsedResult.engine = {};
            var t4 = o2.default.find(a2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.engine = t4.describe(this.getUA())), this.parsedResult.engine;
          }, t3.parse = function() {
            return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
          }, t3.getResult = function() {
            return o2.default.assign({}, this.parsedResult);
          }, t3.satisfies = function(e4) {
            var t4 = this, r3 = {}, n3 = 0, i3 = {}, s3 = 0;
            if (Object.keys(e4).forEach(function(t5) {
              var a4 = e4[t5];
              "string" == typeof a4 ? (i3[t5] = a4, s3 += 1) : "object" == typeof a4 && (r3[t5] = a4, n3 += 1);
            }), n3 > 0) {
              var a3 = Object.keys(r3), u3 = o2.default.find(a3, function(e5) {
                return t4.isOS(e5);
              });
              if (u3) {
                var d3 = this.satisfies(r3[u3]);
                if (void 0 !== d3)
                  return d3;
              }
              var c2 = o2.default.find(a3, function(e5) {
                return t4.isPlatform(e5);
              });
              if (c2) {
                var f2 = this.satisfies(r3[c2]);
                if (void 0 !== f2)
                  return f2;
              }
            }
            if (s3 > 0) {
              var l2 = Object.keys(i3), h2 = o2.default.find(l2, function(e5) {
                return t4.isBrowser(e5, true);
              });
              if (void 0 !== h2)
                return this.compareVersion(i3[h2]);
            }
          }, t3.isBrowser = function(e4, t4) {
            void 0 === t4 && (t4 = false);
            var r3 = this.getBrowserName().toLowerCase(), n3 = e4.toLowerCase(), i3 = o2.default.getBrowserTypeByAlias(n3);
            return t4 && i3 && (n3 = i3.toLowerCase()), n3 === r3;
          }, t3.compareVersion = function(e4) {
            var t4 = [0], r3 = e4, n3 = false, i3 = this.getBrowserVersion();
            if ("string" == typeof i3)
              return ">" === e4[0] || "<" === e4[0] ? (r3 = e4.substr(1), "=" === e4[1] ? (n3 = true, r3 = e4.substr(2)) : t4 = [], ">" === e4[0] ? t4.push(1) : t4.push(-1)) : "=" === e4[0] ? r3 = e4.substr(1) : "~" === e4[0] && (n3 = true, r3 = e4.substr(1)), t4.indexOf(o2.default.compareVersions(i3, r3, n3)) > -1;
          }, t3.isOS = function(e4) {
            return this.getOSName(true) === String(e4).toLowerCase();
          }, t3.isPlatform = function(e4) {
            return this.getPlatformType(true) === String(e4).toLowerCase();
          }, t3.isEngine = function(e4) {
            return this.getEngineName(true) === String(e4).toLowerCase();
          }, t3.is = function(e4, t4) {
            return void 0 === t4 && (t4 = false), this.isBrowser(e4, t4) || this.isOS(e4) || this.isPlatform(e4);
          }, t3.some = function(e4) {
            var t4 = this;
            return void 0 === e4 && (e4 = []), e4.some(function(e5) {
              return t4.is(e5);
            });
          }, e3;
        }();
        t2.default = d2, e2.exports = t2.default;
      }, 92: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 };
        var s2 = /version\/(\d+(\.?_?\d+)+)/i, a2 = [{ test: [/googlebot/i], describe: function(e3) {
          var t3 = { name: "Googlebot" }, r3 = i2.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opera/i], describe: function(e3) {
          var t3 = { name: "Opera" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opr\/|opios/i], describe: function(e3) {
          var t3 = { name: "Opera" }, r3 = i2.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/SamsungBrowser/i], describe: function(e3) {
          var t3 = { name: "Samsung Internet for Android" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/Whale/i], describe: function(e3) {
          var t3 = { name: "NAVER Whale Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/MZBrowser/i], describe: function(e3) {
          var t3 = { name: "MZ Browser" }, r3 = i2.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/focus/i], describe: function(e3) {
          var t3 = { name: "Focus" }, r3 = i2.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/swing/i], describe: function(e3) {
          var t3 = { name: "Swing" }, r3 = i2.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/coast/i], describe: function(e3) {
          var t3 = { name: "Opera Coast" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e3) {
          var t3 = { name: "Opera Touch" }, r3 = i2.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/yabrowser/i], describe: function(e3) {
          var t3 = { name: "Yandex Browser" }, r3 = i2.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/ucbrowser/i], describe: function(e3) {
          var t3 = { name: "UC Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/Maxthon|mxios/i], describe: function(e3) {
          var t3 = { name: "Maxthon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/epiphany/i], describe: function(e3) {
          var t3 = { name: "Epiphany" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/puffin/i], describe: function(e3) {
          var t3 = { name: "Puffin" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/sleipnir/i], describe: function(e3) {
          var t3 = { name: "Sleipnir" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/k-meleon/i], describe: function(e3) {
          var t3 = { name: "K-Meleon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/micromessenger/i], describe: function(e3) {
          var t3 = { name: "WeChat" }, r3 = i2.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/qqbrowser/i], describe: function(e3) {
          var t3 = { name: /qqbrowserlite/i.test(e3) ? "QQ Browser Lite" : "QQ Browser" }, r3 = i2.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/msie|trident/i], describe: function(e3) {
          var t3 = { name: "Internet Explorer" }, r3 = i2.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/\sedg\//i], describe: function(e3) {
          var t3 = { name: "Microsoft Edge" }, r3 = i2.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/edg([ea]|ios)/i], describe: function(e3) {
          var t3 = { name: "Microsoft Edge" }, r3 = i2.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/vivaldi/i], describe: function(e3) {
          var t3 = { name: "Vivaldi" }, r3 = i2.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/seamonkey/i], describe: function(e3) {
          var t3 = { name: "SeaMonkey" }, r3 = i2.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/sailfish/i], describe: function(e3) {
          var t3 = { name: "Sailfish" }, r3 = i2.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/silk/i], describe: function(e3) {
          var t3 = { name: "Amazon Silk" }, r3 = i2.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/phantom/i], describe: function(e3) {
          var t3 = { name: "PhantomJS" }, r3 = i2.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/slimerjs/i], describe: function(e3) {
          var t3 = { name: "SlimerJS" }, r3 = i2.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t3 = { name: "BlackBerry" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t3 = { name: "WebOS Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/bada/i], describe: function(e3) {
          var t3 = { name: "Bada" }, r3 = i2.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/tizen/i], describe: function(e3) {
          var t3 = { name: "Tizen" }, r3 = i2.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/qupzilla/i], describe: function(e3) {
          var t3 = { name: "QupZilla" }, r3 = i2.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e3) {
          var t3 = { name: "Firefox" }, r3 = i2.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/electron/i], describe: function(e3) {
          var t3 = { name: "Electron" }, r3 = i2.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/MiuiBrowser/i], describe: function(e3) {
          var t3 = { name: "Miui" }, r3 = i2.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/chromium/i], describe: function(e3) {
          var t3 = { name: "Chromium" }, r3 = i2.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/chrome|crios|crmo/i], describe: function(e3) {
          var t3 = { name: "Chrome" }, r3 = i2.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/GSA/i], describe: function(e3) {
          var t3 = { name: "Google Search" }, r3 = i2.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          var t3 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t3 && r3;
        }, describe: function(e3) {
          var t3 = { name: "Android Browser" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/playstation 4/i], describe: function(e3) {
          var t3 = { name: "PlayStation 4" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/safari|applewebkit/i], describe: function(e3) {
          var t3 = { name: "Safari" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/.*/i], describe: function(e3) {
          var t3 = -1 !== e3.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
          return { name: i2.default.getFirstMatch(t3, e3), version: i2.default.getSecondMatch(t3, e3) };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 93: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/Roku\/DVP/], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e3);
          return { name: s2.OS_MAP.Roku, version: t3 };
        } }, { test: [/windows phone/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.WindowsPhone, version: t3 };
        } }, { test: [/windows /i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e3), r3 = i2.default.getWindowsVersionName(t3);
          return { name: s2.OS_MAP.Windows, version: t3, versionName: r3 };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e3) {
          var t3 = { name: s2.OS_MAP.iOS }, r3 = i2.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/macintosh/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e3).replace(/[_\s]/g, "."), r3 = i2.default.getMacOSVersionName(t3), n3 = { name: s2.OS_MAP.MacOS, version: t3 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e3).replace(/[_\s]/g, ".");
          return { name: s2.OS_MAP.iOS, version: t3 };
        } }, { test: function(e3) {
          var t3 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t3 && r3;
        }, describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e3), r3 = i2.default.getAndroidVersionName(t3), n3 = { name: s2.OS_MAP.Android, version: t3 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e3), r3 = { name: s2.OS_MAP.WebOS };
          return t3 && t3.length && (r3.version = t3), r3;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e3) || i2.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e3) || i2.default.getFirstMatch(/\bbb(\d+)/i, e3);
          return { name: s2.OS_MAP.BlackBerry, version: t3 };
        } }, { test: [/bada/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Bada, version: t3 };
        } }, { test: [/tizen/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Tizen, version: t3 };
        } }, { test: [/linux/i], describe: function() {
          return { name: s2.OS_MAP.Linux };
        } }, { test: [/CrOS/], describe: function() {
          return { name: s2.OS_MAP.ChromeOS };
        } }, { test: [/PlayStation 4/], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.PlayStation4, version: t3 };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 94: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/googlebot/i], describe: function() {
          return { type: "bot", vendor: "Google" };
        } }, { test: [/huawei/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(can-l01)/i, e3) && "Nova", r3 = { type: s2.PLATFORMS_MAP.mobile, vendor: "Huawei" };
          return t3 && (r3.model = t3), r3;
        } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Nexus" };
        } }, { test: [/ipad/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/kftt build/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
        } }, { test: [/silk/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon" };
        } }, { test: [/tablet(?! pc)/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          var t3 = e3.test(/ipod|iphone/i), r3 = e3.test(/like (ipod|iphone)/i);
          return t3 && !r3;
        }, describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(ipod|iphone)/i, e3);
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Apple", model: t3 };
        } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Nexus" };
        } }, { test: [/[^-]mobi/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "blackberry" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
        } }, { test: function(e3) {
          return "bada" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "windows phone" === e3.getBrowserName();
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
        } }, { test: function(e3) {
          var t3 = Number(String(e3.getOSVersion()).split(".")[0]);
          return "android" === e3.getOSName(true) && t3 >= 3;
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          return "android" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "macos" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop, vendor: "Apple" };
        } }, { test: function(e3) {
          return "windows" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "linux" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "playstation 4" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }, { test: function(e3) {
          return "roku" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 95: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: function(e3) {
          return "microsoft edge" === e3.getBrowserName(true);
        }, describe: function(e3) {
          if (/\sedg\//i.test(e3))
            return { name: s2.ENGINE_MAP.Blink };
          var t3 = i2.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e3);
          return { name: s2.ENGINE_MAP.EdgeHTML, version: t3 };
        } }, { test: [/trident/i], describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Trident }, r3 = i2.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          return e3.test(/presto/i);
        }, describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Presto }, r3 = i2.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          var t3 = e3.test(/gecko/i), r3 = e3.test(/like gecko/i);
          return t3 && !r3;
        }, describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Gecko }, r3 = i2.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
          return { name: s2.ENGINE_MAP.Blink };
        } }, { test: [/(apple)?webkit/i], describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.WebKit }, r3 = i2.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }];
        t2.default = a2, e2.exports = t2.default;
      } });
    });
  }
});

// ../node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
var import_bowser, defaultUserAgent;
var init_dist_es40 = __esm({
  "../node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    import_bowser = __toESM(require_es5());
    defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
      const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser.default.parse(window.navigator.userAgent) : void 0;
      const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.0"],
        [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
        ["lang/js"],
        ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`]
      ];
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      return sections;
    };
  }
});

// ../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.js
var require_tslib6 = __commonJS({
  "../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "../node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = require_tslib6();
    var util_1 = require_build3();
    var index_1 = require_build7();
    var AwsCrc322 = (
      /** @class */
      function() {
        function AwsCrc323() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc323.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc323.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc323.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc323;
      }()
    );
    exports.AwsCrc32 = AwsCrc322;
  }
});

// ../node_modules/@aws-crypto/crc32/build/index.js
var require_build7 = __commonJS({
  "../node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = require_tslib6();
    var util_1 = require_build3();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc323 = (
      /** @class */
      function() {
        function Crc324() {
          this.checksum = 4294967295;
        }
        Crc324.prototype.update = function(data) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
                _a2.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc324.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc324;
      }()
    );
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/Int64.js
function negate2(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}
var Int642;
var init_Int64 = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/Int64.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es13();
    Int642 = class {
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
          bytes[i2] = remaining;
        }
        if (number < 0) {
          negate2(bytes);
        }
        return new Int642(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate2(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller, HEADER_VALUE_TYPE2, BOOLEAN_TAG, BYTE_TAG, SHORT_TAG, INT_TAG, LONG_TAG, BINARY_TAG, STRING_TAG, TIMESTAMP_TAG, UUID_TAG, UUID_PATTERN2;
var init_HeaderMarshaller = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es13();
    init_Int64();
    HeaderMarshaller = class {
      constructor(toUtf82, fromUtf82) {
        this.toUtf8 = toUtf82;
        this.fromUtf8 = fromUtf82;
      }
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = this.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = this.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN2.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
      parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
          const nameLength = headers.getUint8(position++);
          const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
          position += nameLength;
          switch (headers.getUint8(position++)) {
            case 0:
              out[name] = {
                type: BOOLEAN_TAG,
                value: true
              };
              break;
            case 1:
              out[name] = {
                type: BOOLEAN_TAG,
                value: false
              };
              break;
            case 2:
              out[name] = {
                type: BYTE_TAG,
                value: headers.getInt8(position++)
              };
              break;
            case 3:
              out[name] = {
                type: SHORT_TAG,
                value: headers.getInt16(position, false)
              };
              position += 2;
              break;
            case 4:
              out[name] = {
                type: INT_TAG,
                value: headers.getInt32(position, false)
              };
              position += 4;
              break;
            case 5:
              out[name] = {
                type: LONG_TAG,
                value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
              };
              position += 8;
              break;
            case 6:
              const binaryLength = headers.getUint16(position, false);
              position += 2;
              out[name] = {
                type: BINARY_TAG,
                value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
              };
              position += binaryLength;
              break;
            case 7:
              const stringLength = headers.getUint16(position, false);
              position += 2;
              out[name] = {
                type: STRING_TAG,
                value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
              };
              position += stringLength;
              break;
            case 8:
              out[name] = {
                type: TIMESTAMP_TAG,
                value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
              };
              position += 8;
              break;
            case 9:
              const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
              position += 16;
              out[name] = {
                type: UUID_TAG,
                value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
              };
              break;
            default:
              throw new Error(`Unrecognized header type tag`);
          }
        }
        return out;
      }
    };
    (function(HEADER_VALUE_TYPE3) {
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
    BOOLEAN_TAG = "boolean";
    BYTE_TAG = "byte";
    SHORT_TAG = "short";
    INT_TAG = "integer";
    LONG_TAG = "long";
    BINARY_TAG = "binary";
    STRING_TAG = "string";
    TIMESTAMP_TAG = "timestamp";
    UUID_TAG = "uuid";
    UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
function splitMessage({ byteLength: byteLength2, byteOffset, buffer: buffer2 }) {
  if (byteLength2 < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer2, byteOffset, byteLength2);
  const messageLength = view.getUint32(0, false);
  if (byteLength2 !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength2 - CHECKSUM_LENGTH, false);
  const checksummer = new import_crc32.Crc32().update(new Uint8Array(buffer2, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer2, byteOffset + PRELUDE_LENGTH, byteLength2 - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer2, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer2, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}
var import_crc32, PRELUDE_MEMBER_LENGTH, PRELUDE_LENGTH, CHECKSUM_LENGTH, MINIMUM_MESSAGE_LENGTH;
var init_splitMessage = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    import_crc32 = __toESM(require_build7());
    PRELUDE_MEMBER_LENGTH = 4;
    PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    CHECKSUM_LENGTH = 4;
    MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc322, EventStreamCodec;
var init_EventStreamCodec = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    import_crc322 = __toESM(require_build7());
    init_HeaderMarshaller();
    init_splitMessage();
    EventStreamCodec = class {
      constructor(toUtf82, fromUtf82) {
        this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf82);
        this.messageBuffer = [];
        this.isEndOfStream = false;
      }
      feed(message) {
        this.messageBuffer.push(this.decode(message));
      }
      endOfStream() {
        this.isEndOfStream = true;
      }
      getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessage() {
            return message;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessages() {
            return messages;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new import_crc322.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
      }
      decode(message) {
        const { headers, body } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers), body };
      }
      formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/Message.js
var init_Message = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/Message.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream;
var init_MessageDecoderStream = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    MessageDecoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream;
var init_MessageEncoderStream = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    MessageEncoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream;
var init_SmithyMessageDecoderStream = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    SmithyMessageDecoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream;
var init_SmithyMessageEncoderStream = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    SmithyMessageEncoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk);
          yield payloadBuf;
        }
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-codec/dist-es/index.js
var init_dist_es41 = __esm({
  "../node_modules/@smithy/eventstream-codec/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamCodec();
    init_HeaderMarshaller();
    init_Int64();
    init_Message();
    init_MessageDecoderStream();
    init_MessageEncoderStream();
    init_SmithyMessageDecoderStream();
    init_SmithyMessageEncoderStream();
  }
});

// ../node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}
var init_getChunkedStream = __esm({
  "../node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getMessageUnmarshaller(deserializer, toUtf82) {
  return async function(message) {
    const { value: messageType } = message.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code2 = message.headers[":exception-type"].value;
      const exception = { [code2]: message };
      const deserializedException = await deserializer(exception);
      if (deserializedException.$unknown) {
        const error = new Error(toUtf82(message.body));
        error.name = code2;
        throw error;
      }
      throw deserializedException[code2];
    } else if (messageType === "event") {
      const event = {
        [message.headers[":event-type"].value]: message
      };
      const deserialized = await deserializer(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
    }
  };
}
var init_getUnmarshalledStream = __esm({
  "../node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller;
var init_EventStreamMarshaller = __esm({
  "../node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es41();
    init_getChunkedStream();
    init_getUnmarshalledStream();
    EventStreamMarshaller = class {
      constructor({ utf8Encoder, utf8Decoder }) {
        this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
      }
      deserialize(body, deserializer) {
        const inputStream = getChunkedStream(body);
        return new SmithyMessageDecoderStream({
          messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
          deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
        });
      }
      serialize(inputStream, serializer) {
        return new MessageEncoderStream({
          messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
          encoder: this.eventStreamCodec,
          includeEndFrame: true
        });
      }
    };
  }
});

// ../node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js
var init_provider = __esm({
  "../node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamMarshaller();
  }
});

// ../node_modules/@smithy/eventstream-serde-universal/dist-es/index.js
var init_dist_es42 = __esm({
  "../node_modules/@smithy/eventstream-serde-universal/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamMarshaller();
    init_provider();
  }
});

// ../node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
var readableStreamtoIterable, iterableToReadableStream;
var init_utils2 = __esm({
  "../node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    readableStreamtoIterable = (readableStream) => ({
      [Symbol.asyncIterator]: async function* () {
        const reader = readableStream.getReader();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              return;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      }
    });
    iterableToReadableStream = (asyncIterable) => {
      const iterator = asyncIterable[Symbol.asyncIterator]();
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            return controller.close();
          }
          controller.enqueue(value);
        }
      });
    };
  }
});

// ../node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2, isReadableStream;
var init_EventStreamMarshaller2 = __esm({
  "../node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es42();
    init_utils2();
    EventStreamMarshaller2 = class {
      constructor({ utf8Encoder, utf8Decoder }) {
        this.universalMarshaller = new EventStreamMarshaller({
          utf8Decoder,
          utf8Encoder
        });
      }
      deserialize(body, deserializer) {
        const bodyIterable = isReadableStream(body) ? readableStreamtoIterable(body) : body;
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
      }
      serialize(input, serializer) {
        const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
        return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
      }
    };
    isReadableStream = (body) => typeof ReadableStream === "function" && body instanceof ReadableStream;
  }
});

// ../node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
var eventStreamSerdeProvider;
var init_provider2 = __esm({
  "../node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamMarshaller2();
    eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);
  }
});

// ../node_modules/@smithy/eventstream-serde-browser/dist-es/index.js
var init_dist_es43 = __esm({
  "../node_modules/@smithy/eventstream-serde-browser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_EventStreamMarshaller2();
    init_provider2();
    init_utils2();
  }
});

// ../node_modules/@smithy/chunked-blob-reader/dist-es/index.js
function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.addEventListener("error", reject);
    fileReader.addEventListener("abort", reject);
    const size = blob.size;
    let totalBytesRead = 0;
    function read3() {
      if (totalBytesRead >= size) {
        resolve();
        return;
      }
      fileReader.readAsArrayBuffer(blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize)));
    }
    fileReader.addEventListener("load", (event) => {
      const result = event.target.result;
      onChunk(new Uint8Array(result));
      totalBytesRead += result.byteLength;
      read3();
    });
    read3();
  });
}
var init_dist_es44 = __esm({
  "../node_modules/@smithy/chunked-blob-reader/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/hash-blob-browser/dist-es/index.js
var blobHasher;
var init_dist_es45 = __esm({
  "../node_modules/@smithy/hash-blob-browser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es44();
    blobHasher = async function blobHasher2(hashCtor, blob) {
      const hash = new hashCtor();
      await blobReader(blob, (chunk) => {
        hash.update(chunk);
      });
      return hash.digest();
    };
  }
});

// ../node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js
var init_invalidFunction = __esm({
  "../node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js
var invalidProvider;
var init_invalidProvider = __esm({
  "../node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    invalidProvider = (message) => () => Promise.reject(message);
  }
});

// ../node_modules/@smithy/invalid-dependency/dist-es/index.js
var init_dist_es46 = __esm({
  "../node_modules/@smithy/invalid-dependency/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_invalidFunction();
    init_invalidProvider();
  }
});

// ../node_modules/@smithy/md5-js/dist-es/constants.js
var BLOCK_SIZE, DIGEST_LENGTH, INIT;
var init_constants7 = __esm({
  "../node_modules/@smithy/md5-js/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    BLOCK_SIZE = 64;
    DIGEST_LENGTH = 16;
    INIT = [1732584193, 4023233417, 2562383102, 271733878];
  }
});

// ../node_modules/@smithy/md5-js/dist-es/index.js
function cmn(q2, a2, b2, x2, s2, t2) {
  a2 = (a2 + q2 & 4294967295) + (x2 + t2 & 4294967295) & 4294967295;
  return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
}
function ff(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function gg(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function hh(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function ii(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
function convertToBuffer(data) {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
var Md5;
var init_dist_es47 = __esm({
  "../node_modules/@smithy/md5-js/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es8();
    init_constants7();
    Md5 = class {
      constructor() {
        this.reset();
      }
      update(sourceData) {
        if (isEmptyData(sourceData)) {
          return;
        } else if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        const data = convertToBuffer(sourceData);
        let position = 0;
        let { byteLength: byteLength2 } = data;
        this.bytesHashed += byteLength2;
        while (byteLength2 > 0) {
          this.buffer.setUint8(this.bufferLength++, data[position++]);
          byteLength2--;
          if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      }
      async digest() {
        if (!this.finished) {
          const { buffer: buffer2, bufferLength: undecoratedLength, bytesHashed } = this;
          const bitsHashed = bytesHashed * 8;
          buffer2.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (let i2 = this.bufferLength; i2 < BLOCK_SIZE; i2++) {
              buffer2.setUint8(i2, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (let i2 = this.bufferLength; i2 < BLOCK_SIZE - 8; i2++) {
            buffer2.setUint8(i2, 0);
          }
          buffer2.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
          buffer2.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 4294967296), true);
          this.hashBuffer();
          this.finished = true;
        }
        const out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
        for (let i2 = 0; i2 < 4; i2++) {
          out.setUint32(i2 * 4, this.state[i2], true);
        }
        return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
      }
      hashBuffer() {
        const { buffer: buffer2, state } = this;
        let a2 = state[0], b2 = state[1], c2 = state[2], d2 = state[3];
        a2 = ff(a2, b2, c2, d2, buffer2.getUint32(0, true), 7, 3614090360);
        d2 = ff(d2, a2, b2, c2, buffer2.getUint32(4, true), 12, 3905402710);
        c2 = ff(c2, d2, a2, b2, buffer2.getUint32(8, true), 17, 606105819);
        b2 = ff(b2, c2, d2, a2, buffer2.getUint32(12, true), 22, 3250441966);
        a2 = ff(a2, b2, c2, d2, buffer2.getUint32(16, true), 7, 4118548399);
        d2 = ff(d2, a2, b2, c2, buffer2.getUint32(20, true), 12, 1200080426);
        c2 = ff(c2, d2, a2, b2, buffer2.getUint32(24, true), 17, 2821735955);
        b2 = ff(b2, c2, d2, a2, buffer2.getUint32(28, true), 22, 4249261313);
        a2 = ff(a2, b2, c2, d2, buffer2.getUint32(32, true), 7, 1770035416);
        d2 = ff(d2, a2, b2, c2, buffer2.getUint32(36, true), 12, 2336552879);
        c2 = ff(c2, d2, a2, b2, buffer2.getUint32(40, true), 17, 4294925233);
        b2 = ff(b2, c2, d2, a2, buffer2.getUint32(44, true), 22, 2304563134);
        a2 = ff(a2, b2, c2, d2, buffer2.getUint32(48, true), 7, 1804603682);
        d2 = ff(d2, a2, b2, c2, buffer2.getUint32(52, true), 12, 4254626195);
        c2 = ff(c2, d2, a2, b2, buffer2.getUint32(56, true), 17, 2792965006);
        b2 = ff(b2, c2, d2, a2, buffer2.getUint32(60, true), 22, 1236535329);
        a2 = gg(a2, b2, c2, d2, buffer2.getUint32(4, true), 5, 4129170786);
        d2 = gg(d2, a2, b2, c2, buffer2.getUint32(24, true), 9, 3225465664);
        c2 = gg(c2, d2, a2, b2, buffer2.getUint32(44, true), 14, 643717713);
        b2 = gg(b2, c2, d2, a2, buffer2.getUint32(0, true), 20, 3921069994);
        a2 = gg(a2, b2, c2, d2, buffer2.getUint32(20, true), 5, 3593408605);
        d2 = gg(d2, a2, b2, c2, buffer2.getUint32(40, true), 9, 38016083);
        c2 = gg(c2, d2, a2, b2, buffer2.getUint32(60, true), 14, 3634488961);
        b2 = gg(b2, c2, d2, a2, buffer2.getUint32(16, true), 20, 3889429448);
        a2 = gg(a2, b2, c2, d2, buffer2.getUint32(36, true), 5, 568446438);
        d2 = gg(d2, a2, b2, c2, buffer2.getUint32(56, true), 9, 3275163606);
        c2 = gg(c2, d2, a2, b2, buffer2.getUint32(12, true), 14, 4107603335);
        b2 = gg(b2, c2, d2, a2, buffer2.getUint32(32, true), 20, 1163531501);
        a2 = gg(a2, b2, c2, d2, buffer2.getUint32(52, true), 5, 2850285829);
        d2 = gg(d2, a2, b2, c2, buffer2.getUint32(8, true), 9, 4243563512);
        c2 = gg(c2, d2, a2, b2, buffer2.getUint32(28, true), 14, 1735328473);
        b2 = gg(b2, c2, d2, a2, buffer2.getUint32(48, true), 20, 2368359562);
        a2 = hh(a2, b2, c2, d2, buffer2.getUint32(20, true), 4, 4294588738);
        d2 = hh(d2, a2, b2, c2, buffer2.getUint32(32, true), 11, 2272392833);
        c2 = hh(c2, d2, a2, b2, buffer2.getUint32(44, true), 16, 1839030562);
        b2 = hh(b2, c2, d2, a2, buffer2.getUint32(56, true), 23, 4259657740);
        a2 = hh(a2, b2, c2, d2, buffer2.getUint32(4, true), 4, 2763975236);
        d2 = hh(d2, a2, b2, c2, buffer2.getUint32(16, true), 11, 1272893353);
        c2 = hh(c2, d2, a2, b2, buffer2.getUint32(28, true), 16, 4139469664);
        b2 = hh(b2, c2, d2, a2, buffer2.getUint32(40, true), 23, 3200236656);
        a2 = hh(a2, b2, c2, d2, buffer2.getUint32(52, true), 4, 681279174);
        d2 = hh(d2, a2, b2, c2, buffer2.getUint32(0, true), 11, 3936430074);
        c2 = hh(c2, d2, a2, b2, buffer2.getUint32(12, true), 16, 3572445317);
        b2 = hh(b2, c2, d2, a2, buffer2.getUint32(24, true), 23, 76029189);
        a2 = hh(a2, b2, c2, d2, buffer2.getUint32(36, true), 4, 3654602809);
        d2 = hh(d2, a2, b2, c2, buffer2.getUint32(48, true), 11, 3873151461);
        c2 = hh(c2, d2, a2, b2, buffer2.getUint32(60, true), 16, 530742520);
        b2 = hh(b2, c2, d2, a2, buffer2.getUint32(8, true), 23, 3299628645);
        a2 = ii(a2, b2, c2, d2, buffer2.getUint32(0, true), 6, 4096336452);
        d2 = ii(d2, a2, b2, c2, buffer2.getUint32(28, true), 10, 1126891415);
        c2 = ii(c2, d2, a2, b2, buffer2.getUint32(56, true), 15, 2878612391);
        b2 = ii(b2, c2, d2, a2, buffer2.getUint32(20, true), 21, 4237533241);
        a2 = ii(a2, b2, c2, d2, buffer2.getUint32(48, true), 6, 1700485571);
        d2 = ii(d2, a2, b2, c2, buffer2.getUint32(12, true), 10, 2399980690);
        c2 = ii(c2, d2, a2, b2, buffer2.getUint32(40, true), 15, 4293915773);
        b2 = ii(b2, c2, d2, a2, buffer2.getUint32(4, true), 21, 2240044497);
        a2 = ii(a2, b2, c2, d2, buffer2.getUint32(32, true), 6, 1873313359);
        d2 = ii(d2, a2, b2, c2, buffer2.getUint32(60, true), 10, 4264355552);
        c2 = ii(c2, d2, a2, b2, buffer2.getUint32(24, true), 15, 2734768916);
        b2 = ii(b2, c2, d2, a2, buffer2.getUint32(52, true), 21, 1309151649);
        a2 = ii(a2, b2, c2, d2, buffer2.getUint32(16, true), 6, 4149444226);
        d2 = ii(d2, a2, b2, c2, buffer2.getUint32(44, true), 10, 3174756917);
        c2 = ii(c2, d2, a2, b2, buffer2.getUint32(8, true), 15, 718787259);
        b2 = ii(b2, c2, d2, a2, buffer2.getUint32(36, true), 21, 3951481745);
        state[0] = a2 + state[0] & 4294967295;
        state[1] = b2 + state[1] & 4294967295;
        state[2] = c2 + state[2] & 4294967295;
        state[3] = d2 + state[3] & 4294967295;
      }
      reset() {
        this.state = Uint32Array.from(INIT);
        this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
    };
  }
});

// ../node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js
var TEXT_ENCODER, calculateBodyLength;
var init_calculateBodyLength = __esm({
  "../node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
    calculateBodyLength = (body) => {
      if (typeof body === "string") {
        if (TEXT_ENCODER) {
          return TEXT_ENCODER.encode(body).byteLength;
        }
        let len = body.length;
        for (let i2 = len - 1; i2 >= 0; i2--) {
          const code2 = body.charCodeAt(i2);
          if (code2 > 127 && code2 <= 2047)
            len++;
          else if (code2 > 2047 && code2 <= 65535)
            len += 2;
          if (code2 >= 56320 && code2 <= 57343)
            i2--;
        }
        return len;
      } else if (typeof body.byteLength === "number") {
        return body.byteLength;
      } else if (typeof body.size === "number") {
        return body.size;
      }
      throw new Error(`Body Length computation failed for ${body}`);
    };
  }
});

// ../node_modules/@smithy/util-body-length-browser/dist-es/index.js
var init_dist_es48 = __esm({
  "../node_modules/@smithy/util-body-length-browser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_calculateBodyLength();
  }
});

// ../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
var signatureV4CrtContainer;
var init_signature_v4_crt_container = __esm({
  "../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    signatureV4CrtContainer = {
      CrtSignerV4: null
    };
  }
});

// ../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion;
var init_SignatureV4MultiRegion = __esm({
  "../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es21();
    init_signature_v4_crt_container();
    SignatureV4MultiRegion = class {
      constructor(options) {
        this.sigv4Signer = new SignatureV4S3Express(options);
        this.signerOptions = options;
      }
      async sign(requestToSign, options = {}) {
        if (options.signingRegion === "*") {
          if (this.signerOptions.runtime !== "node")
            throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
          return this.getSigv4aSigner().sign(requestToSign, options);
        }
        return this.sigv4Signer.sign(requestToSign, options);
      }
      async signWithCredentials(requestToSign, credentials, options = {}) {
        if (options.signingRegion === "*") {
          if (this.signerOptions.runtime !== "node")
            throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
          return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
        }
        return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
      }
      async presign(originalRequest, options = {}) {
        if (options.signingRegion === "*") {
          if (this.signerOptions.runtime !== "node")
            throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
          return this.getSigv4aSigner().presign(originalRequest, options);
        }
        return this.sigv4Signer.presign(originalRequest, options);
      }
      async presignWithCredentials(originalRequest, credentials, options = {}) {
        if (options.signingRegion === "*") {
          throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        }
        return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
      }
      getSigv4aSigner() {
        if (!this.sigv4aSigner) {
          let CrtSignerV4 = null;
          try {
            CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
            if (typeof CrtSignerV4 !== "function")
              throw new Error();
          } catch (e2) {
            e2.message = `${e2.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
            throw e2;
          }
          this.sigv4aSigner = new CrtSignerV4({
            ...this.signerOptions,
            signingAlgorithm: 1
          });
        }
        return this.sigv4aSigner;
      }
    };
  }
});

// ../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js
var init_dist_es49 = __esm({
  "../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_SignatureV4MultiRegion();
    init_signature_v4_crt_container();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var ce, cf, cg, ch, ci, cj, ck, cl, cm, cn, co, cp, cq, cr, cs, ct, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, ba, bb, bc, bd, be, bf, bg, bh, bi, bj, bk, bl, bm, bn, bo, bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz, bA, bB, bC, bD, bE, bF, bG, bH, bI, bJ, bK, bL, bM, bN, bO, bP, bQ, bR, bS, bT, bU, bV, bW, bX, bY, bZ, ca, cb, cc, cd, _data, ruleSet;
var init_ruleset = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    ce = "required";
    cf = "type";
    cg = "conditions";
    ch = "fn";
    ci = "argv";
    cj = "ref";
    ck = "assign";
    cl = "url";
    cm = "properties";
    cn = "backend";
    co = "authSchemes";
    cp = "disableDoubleEncoding";
    cq = "signingName";
    cr = "signingRegion";
    cs = "headers";
    ct = "signingRegionSet";
    a = false;
    b = true;
    c = "isSet";
    d = "booleanEquals";
    e = "error";
    f = "aws.partition";
    g = "stringEquals";
    h = "getAttr";
    i = "name";
    j = "substring";
    k = "bucketSuffix";
    l = "parseURL";
    m = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
    n = "endpoint";
    o = "tree";
    p = "aws.isVirtualHostableS3Bucket";
    q = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
    r = "not";
    s = "{url#scheme}://{url#authority}{url#path}";
    t = "hardwareType";
    u = "regionPrefix";
    v = "bucketAliasSuffix";
    w = "outpostId";
    x = "isValidHostLabel";
    y = "sigv4a";
    z = "s3-outposts";
    A = "s3";
    B = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
    C = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
    D = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
    E = "aws.parseArn";
    F = "bucketArn";
    G = "arnType";
    H = "";
    I = "s3-object-lambda";
    J = "accesspoint";
    K = "accessPointName";
    L = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
    M = "mrapPartition";
    N = "outpostType";
    O = "arnPrefix";
    P = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
    Q = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
    R = "https://s3.{partitionResult#dnsSuffix}";
    S = { [ce]: false, [cf]: "String" };
    T = { [ce]: true, "default": false, [cf]: "Boolean" };
    U = { [ce]: false, [cf]: "Boolean" };
    V = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, true] };
    W = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, true] };
    X = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, true] };
    Y = { [ch]: c, [ci]: [{ [cj]: "Endpoint" }] };
    Z = { [ch]: f, [ci]: [{ [cj]: "Region" }], [ck]: "partitionResult" };
    aa = { [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }, "aws-cn"] };
    ab = { [ch]: c, [ci]: [{ [cj]: "Bucket" }] };
    ac = { [cj]: "Bucket" };
    ad = { [ch]: l, [ci]: [{ [cj]: "Endpoint" }], [ck]: "url" };
    ae = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "url" }, "isIp"] }, true] };
    af = { [cj]: "url" };
    ag = { [ch]: "uriEncode", [ci]: [ac], [ck]: "uri_encoded_bucket" };
    ah = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4", [cq]: "s3express", [cr]: "{Region}" }] };
    ai = {};
    aj = { [ch]: p, [ci]: [ac, false] };
    ak = { [e]: "S3Express bucket name is not a valid virtual hostable name.", [cf]: e };
    al = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4-s3express", [cq]: "s3express", [cr]: "{Region}" }] };
    am = { [ch]: c, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }] };
    an = { [ch]: d, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }, true] };
    ao = { [ch]: r, [ci]: [Y] };
    ap = { [e]: "Unrecognized S3Express bucket name format.", [cf]: e };
    aq = { [ch]: r, [ci]: [ab] };
    ar = { [cj]: t };
    as = { [cg]: [ao], [e]: "Expected a endpoint to be specified but no endpoint was found", [cf]: e };
    at = { [co]: [{ [cp]: true, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z, [cr]: "{Region}" }] };
    au = { [ch]: d, [ci]: [{ [cj]: "ForcePathStyle" }, false] };
    av = { [cj]: "ForcePathStyle" };
    aw = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, false] };
    ax = { [ch]: g, [ci]: [{ [cj]: "Region" }, "aws-global"] };
    ay = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "us-east-1" }] };
    az = { [ch]: r, [ci]: [ax] };
    aA = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, true] };
    aB = { [cl]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] }, [cs]: {} };
    aC = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] };
    aD = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, false] };
    aE = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, false] };
    aF = { [cl]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    aG = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, false] };
    aH = { [cl]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    aI = { [cl]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    aJ = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [af, "isIp"] }, false] };
    aK = { [cl]: B, [cm]: aC, [cs]: {} };
    aL = { [cl]: q, [cm]: aC, [cs]: {} };
    aM = { [n]: aL, [cf]: n };
    aN = { [cl]: C, [cm]: aC, [cs]: {} };
    aO = { [cl]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    aP = { [e]: "Invalid region: region was not a valid DNS name.", [cf]: e };
    aQ = { [cj]: F };
    aR = { [cj]: G };
    aS = { [ch]: h, [ci]: [aQ, "service"] };
    aT = { [cj]: K };
    aU = { [cg]: [X], [e]: "S3 Object Lambda does not support Dual-stack", [cf]: e };
    aV = { [cg]: [V], [e]: "S3 Object Lambda does not support S3 Accelerate", [cf]: e };
    aW = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "DisableAccessPoints" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableAccessPoints" }, true] }], [e]: "Access points are not supported for this operation", [cf]: e };
    aX = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "UseArnRegion" }] }, { [ch]: d, [ci]: [{ [cj]: "UseArnRegion" }, false] }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, "{Region}"] }] }], [e]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cf]: e };
    aY = { [ch]: h, [ci]: [{ [cj]: "bucketPartition" }, i] };
    aZ = { [ch]: h, [ci]: [aQ, "accountId"] };
    ba = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{bucketArn#region}" }] };
    bb = { [e]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cf]: e };
    bc = { [e]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cf]: e };
    bd = { [e]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cf]: e };
    be = { [e]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cf]: e };
    bf = { [e]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cf]: e };
    bg = { [e]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cf]: e };
    bh = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{bucketArn#region}" }] };
    bi = { [co]: [{ [cp]: true, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z, [cr]: "{bucketArn#region}" }] };
    bj = { [ch]: E, [ci]: [ac] };
    bk = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
    bl = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
    bm = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
    bn = { [cl]: P, [cm]: aC, [cs]: {} };
    bo = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
    bp = { [cj]: "UseObjectLambdaEndpoint" };
    bq = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{Region}" }] };
    br = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    bs = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    bt = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    bu = { [cl]: s, [cm]: aC, [cs]: {} };
    bv = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
    bw = [{ [cj]: "Region" }];
    bx = [{ [cj]: "Endpoint" }];
    by = [ac];
    bz = [X];
    bA = [V];
    bB = [Y, ad];
    bC = [{ [ch]: c, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }, true] }];
    bD = [ae];
    bE = [ag];
    bF = [aj];
    bG = [W];
    bH = [{ [ch]: j, [ci]: [ac, 6, 14, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 14, 16, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bI = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }];
    bJ = [{ [ch]: j, [ci]: [ac, 6, 15, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 15, 17, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bK = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }];
    bL = [ab];
    bM = [{ [ch]: x, [ci]: [{ [cj]: w }, false] }];
    bN = [{ [ch]: g, [ci]: [{ [cj]: u }, "beta"] }];
    bO = ["*"];
    bP = [Z];
    bQ = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, false] }];
    bR = [{ [ch]: g, [ci]: [{ [cj]: "Region" }, "us-east-1"] }];
    bS = [{ [ch]: g, [ci]: [aR, J] }];
    bT = [{ [ch]: h, [ci]: [aQ, "resourceId[1]"], [ck]: K }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aT, H] }] }];
    bU = [aQ, "resourceId[1]"];
    bV = [{ [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, H] }] }];
    bW = [{ [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[2]"] }] }] }];
    bX = [aQ, "resourceId[2]"];
    bY = [{ [ch]: f, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }], [ck]: "bucketPartition" }];
    bZ = [{ [ch]: g, [ci]: [aY, { [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }] }];
    ca = [{ [ch]: x, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, true] }];
    cb = [{ [ch]: x, [ci]: [aZ, false] }];
    cc = [{ [ch]: x, [ci]: [aT, false] }];
    cd = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, true] }];
    _data = { version: "1.0", parameters: { Bucket: S, Region: S, UseFIPS: T, UseDualStack: T, Endpoint: S, ForcePathStyle: T, Accelerate: T, UseGlobalEndpoint: T, UseObjectLambdaEndpoint: U, Key: S, Prefix: S, DisableAccessPoints: U, DisableMultiRegionAccessPoints: T, UseArnRegion: U, UseS3ExpressControlEndpoint: U, DisableS3ExpressSessionAuth: U }, rules: [{ [cg]: [{ [ch]: c, [ci]: bw }], rules: [{ [cg]: [V, W], error: "Accelerate cannot be used with FIPS", [cf]: e }, { [cg]: [X, Y], error: "Cannot set dual-stack in combination with a custom endpoint.", [cf]: e }, { [cg]: [Y, W], error: "A custom endpoint cannot be combined with FIPS", [cf]: e }, { [cg]: [Y, V], error: "A custom endpoint cannot be combined with S3 Accelerate", [cf]: e }, { [cg]: [W, Z, aa], error: "Partition does not support FIPS", [cf]: e }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 0, 6, b], [ck]: k }, { [ch]: g, [ci]: [{ [cj]: k }, "--x-s3"] }], rules: [{ [cg]: bz, error: "S3Express does not support Dual-stack.", [cf]: e }, { [cg]: bA, error: "S3Express does not support S3 Accelerate.", [cf]: e }, { [cg]: bB, rules: [{ [cg]: bC, rules: [{ [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: [am, an], rules: [{ [cg]: [ag, ao], rules: [{ [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ [cg]: bC, rules: [{ [cg]: bH, rules: bI, [cf]: o }, { [cg]: bJ, rules: bI, [cf]: o }, ap], [cf]: o }, { [cg]: bH, rules: bK, [cf]: o }, { [cg]: bJ, rules: bK, [cf]: o }, ap], [cf]: o }, ak], [cf]: o }, { [cg]: [aq, am, an], rules: [{ [cg]: bB, endpoint: { [cl]: s, [cm]: ah, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 49, 50, b], [ck]: t }, { [ch]: j, [ci]: [ac, 8, 12, b], [ck]: u }, { [ch]: j, [ci]: [ac, 0, 7, b], [ck]: v }, { [ch]: j, [ci]: [ac, 32, 49, b], [ck]: w }, { [ch]: f, [ci]: bw, [ck]: "regionPartition" }, { [ch]: g, [ci]: [{ [cj]: v }, "--op-s3"] }], rules: [{ [cg]: bM, rules: [{ [cg]: [{ [ch]: g, [ci]: [ar, "e"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.ec2.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [ar, "o"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cf]: e }], [cf]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cf]: e }], [cf]: o }, { [cg]: bL, rules: [{ [cg]: [Y, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: l, [ci]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cf]: e }, { [cg]: [au, aj], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [{ [cg]: [V, aa], error: "S3 Accelerate cannot be used in this region", [cf]: e }, { [cg]: [X, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, W, aw, ao, az, aA], rules: [{ endpoint: aB, [cf]: n }], [cf]: o }, { [cg]: [X, W, aw, ao, az, aD], endpoint: aB, [cf]: n }, { [cg]: [aE, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, W, aw, ao, az, aA], rules: [{ endpoint: aF, [cf]: n }], [cf]: o }, { [cg]: [aE, W, aw, ao, az, aD], endpoint: aF, [cf]: n }, { [cg]: [X, aG, V, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, V, ao, az, aA], rules: [{ endpoint: aH, [cf]: n }], [cf]: o }, { [cg]: [X, aG, V, ao, az, aD], endpoint: aH, [cf]: n }, { [cg]: [X, aG, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, aw, ao, az, aA], rules: [{ endpoint: aI, [cf]: n }], [cf]: o }, { [cg]: [X, aG, aw, ao, az, aD], endpoint: aI, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, ax], endpoint: { [cl]: B, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, ax], endpoint: { [cl]: q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aA], rules: [{ [cg]: bR, endpoint: aK, [cf]: n }, { endpoint: aK, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aA], rules: [{ [cg]: bR, endpoint: aL, [cf]: n }, aM], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aD], endpoint: aK, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aD], endpoint: aL, [cf]: n }, { [cg]: [aE, aG, V, ao, ax], endpoint: { [cl]: C, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, V, ao, az, aA], rules: [{ [cg]: bR, endpoint: aN, [cf]: n }, { endpoint: aN, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, V, ao, az, aD], endpoint: aN, [cf]: n }, { [cg]: [aE, aG, aw, ao, ax], endpoint: { [cl]: D, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: D, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: aO, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, ao, az, aD], endpoint: aO, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [Y, ad, { [ch]: g, [ci]: [{ [ch]: h, [ci]: [af, "scheme"] }, "http"] }, { [ch]: p, [ci]: [ac, b] }, au, aG, aE, aw], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [aM], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [au, { [ch]: E, [ci]: by, [ck]: F }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[0]"], [ck]: G }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aR, H] }] }], rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, I] }], rules: [{ [cg]: bS, rules: [{ [cg]: bT, rules: [aU, aV, { [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aZ, H] }], error: "Invalid ARN: Missing account id", [cf]: e }, { [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bB, endpoint: { [cl]: L, [cm]: ba, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [cf]: e }], [cf]: o }, bg], [cf]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cf]: e }], [cf]: o }, { [cg]: bS, rules: [{ [cg]: bT, rules: [{ [cg]: bV, rules: [{ [cg]: bS, rules: [{ [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: [{ [ch]: g, [ci]: [aY, "{partitionResult#name}"] }], rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, A] }], rules: [{ [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bA, error: "Access Points do not support S3 Accelerate", [cf]: e }, { [cg]: [W, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [W, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad], endpoint: { [cl]: L, [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cf]: e }], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: x, [ci]: [aT, b] }], rules: [{ [cg]: bz, error: "S3 MRAP does not support dual-stack", [cf]: e }, { [cg]: bG, error: "S3 MRAP does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 MRAP does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [{ [cj]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cf]: e }, { [cg]: [{ [ch]: f, [ci]: bw, [ck]: M }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: M }, i] }, { [ch]: h, [ci]: [aQ, "partition"] }] }], rules: [{ endpoint: { [cl]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cm]: { [co]: [{ [cp]: b, name: y, [cq]: A, [ct]: bO }] }, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cf]: e }], [cf]: o }], [cf]: o }, { error: "Invalid Access Point Name", [cf]: e }], [cf]: o }, bg], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [aS, z] }], rules: [{ [cg]: bz, error: "S3 Outposts does not support Dual-stack", [cf]: e }, { [cg]: bG, error: "S3 Outposts does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 Outposts does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cf]: e }, { [cg]: [{ [ch]: h, [ci]: bU, [ck]: w }], rules: [{ [cg]: bM, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: cb, rules: [{ [cg]: [{ [ch]: h, [ci]: bX, [ck]: N }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[3]"], [ck]: K }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [cj]: N }, J] }], rules: [{ [cg]: bB, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cm]: bi, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bi, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cf]: e }], [cf]: o }, { error: "Invalid ARN: expected an access point name", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Expected a 4-component resource", [cf]: e }], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cf]: e }], [cf]: o }, { error: "Invalid ARN: The Outpost Id was not set", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cf]: e }], [cf]: o }, { error: "Invalid ARN: No ARN type specified", [cf]: e }], [cf]: o }, { [cg]: [{ [ch]: j, [ci]: [ac, 0, 4, a], [ck]: O }, { [ch]: g, [ci]: [{ [cj]: O }, "arn:"] }, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [bj] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [av, b] }, bj], error: "Path-style addressing cannot be used with ARN buckets", [cf]: e }, { [cg]: bE, rules: [{ [cg]: bP, rules: [{ [cg]: [aw], rules: [{ [cg]: [X, ao, W, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, W, az, aA], rules: [{ endpoint: bk, [cf]: n }], [cf]: o }, { [cg]: [X, ao, W, az, aD], endpoint: bk, [cf]: n }, { [cg]: [aE, ao, W, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, W, az, aA], rules: [{ endpoint: bl, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, W, az, aD], endpoint: bl, [cf]: n }, { [cg]: [X, ao, aG, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, aG, az, aA], rules: [{ endpoint: bm, [cf]: n }], [cf]: o }, { [cg]: [X, ao, aG, az, aD], endpoint: bm, [cf]: n }, { [cg]: [aE, Y, ad, aG, ax], endpoint: { [cl]: P, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, Y, ad, aG, az, aA], rules: [{ [cg]: bR, endpoint: bn, [cf]: n }, { endpoint: bn, [cf]: n }], [cf]: o }, { [cg]: [aE, Y, ad, aG, az, aD], endpoint: bn, [cf]: n }, { [cg]: [aE, ao, aG, ax], endpoint: { [cl]: Q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, aG, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: Q, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bo, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, aG, az, aD], endpoint: bo, [cf]: n }], [cf]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cf]: e }], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: c, [ci]: [bp] }, { [ch]: d, [ci]: [bp, b] }], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [aU, aV, { [cg]: bB, endpoint: { [cl]: s, [cm]: bq, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [aq], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [{ [cg]: [W, X, ao, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, X, ao, az, aA], rules: [{ endpoint: br, [cf]: n }], [cf]: o }, { [cg]: [W, X, ao, az, aD], endpoint: br, [cf]: n }, { [cg]: [W, aE, ao, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, aE, ao, az, aA], rules: [{ endpoint: bs, [cf]: n }], [cf]: o }, { [cg]: [W, aE, ao, az, aD], endpoint: bs, [cf]: n }, { [cg]: [aG, X, ao, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, X, ao, az, aA], rules: [{ endpoint: bt, [cf]: n }], [cf]: o }, { [cg]: [aG, X, ao, az, aD], endpoint: bt, [cf]: n }, { [cg]: [aG, aE, Y, ad, ax], endpoint: { [cl]: s, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad, az, aA], rules: [{ [cg]: bR, endpoint: bu, [cf]: n }, { endpoint: bu, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, Y, ad, az, aD], endpoint: bu, [cf]: n }, { [cg]: [aG, aE, ao, ax], endpoint: { [cl]: R, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: R, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bv, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, ao, az, aD], endpoint: bv, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }], [cf]: o }, { error: "A region must be set when sending requests to S3.", [cf]: e }] };
    ruleSet = _data;
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver;
var init_endpointResolver = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es25();
    init_dist_es24();
    init_ruleset();
    defaultEndpointResolver = (endpointParams, context = {}) => {
      return resolveEndpoint(ruleSet, {
        endpointParams,
        logger: context.logger
      });
    };
    customEndpointFunctions.aws = awsEndpointFunctions;
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var getRuntimeConfig;
var init_runtimeConfig_shared = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es49();
    init_dist_es15();
    init_dist_es31();
    init_dist_es9();
    init_dist_es14();
    init_dist_es8();
    init_endpointResolver();
    getRuntimeConfig = (config) => {
      return {
        apiVersion: "2006-03-01",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
        logger: config?.logger ?? new NoOpLogger(),
        sdkStreamMixin: config?.sdkStreamMixin ?? sdkStreamMixin,
        serviceId: config?.serviceId ?? "S3",
        signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
        signingEscapePath: config?.signingEscapePath ?? false,
        urlParser: config?.urlParser ?? parseUrl,
        useArnRegion: config?.useArnRegion ?? false,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8
      };
    };
  }
});

// ../node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js
var DEFAULTS_MODE_OPTIONS;
var init_constants8 = __esm({
  "../node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  }
});

// ../node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var import_bowser2, resolveDefaultsModeConfig, isMobileBrowser;
var init_resolveDefaultsModeConfig = __esm({
  "../node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es22();
    import_bowser2 = __toESM(require_es5());
    init_constants8();
    resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
      const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
      switch (mode?.toLowerCase()) {
        case "auto":
          return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
        case "mobile":
        case "in-region":
        case "cross-region":
        case "standard":
        case "legacy":
          return Promise.resolve(mode?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
      }
    });
    isMobileBrowser = () => {
      const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser2.default.parse(window.navigator.userAgent) : void 0;
      const platform = parsedUA?.platform?.type;
      return platform === "tablet" || platform === "mobile";
    };
  }
});

// ../node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js
var init_dist_es50 = __esm({
  "../node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_resolveDefaultsModeConfig();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var import_sha1_browser, import_sha256_browser, getRuntimeConfig2;
var init_runtimeConfig_browser = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_package();
    import_sha1_browser = __toESM(require_build4());
    import_sha256_browser = __toESM(require_build6());
    init_dist_es40();
    init_dist_es27();
    init_dist_es43();
    init_dist_es12();
    init_dist_es45();
    init_dist_es46();
    init_dist_es47();
    init_dist_es48();
    init_dist_es35();
    init_runtimeConfig_shared();
    init_dist_es15();
    init_dist_es50();
    getRuntimeConfig2 = (config) => {
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "browser",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
        maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
        md5: config?.md5 ?? Md5,
        region: config?.region ?? invalidProvider("Region is missing"),
        requestHandler: FetchHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
        sha1: config?.sha1 ?? import_sha1_browser.Sha1,
        sha256: config?.sha256 ?? import_sha256_browser.Sha256,
        streamCollector: config?.streamCollector ?? streamCollector,
        streamHasher: config?.streamHasher ?? blobHasher,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
        useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
      };
    };
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
var getAwsRegionExtensionConfiguration, resolveAwsRegionExtensionConfiguration;
var init_extensions4 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    getAwsRegionExtensionConfiguration = (runtimeConfig) => {
      let runtimeConfigRegion = async () => {
        if (runtimeConfig.region === void 0) {
          throw new Error("Region is missing from runtimeConfig");
        }
        const region = runtimeConfig.region;
        if (typeof region === "string") {
          return region;
        }
        return region();
      };
      return {
        setRegion(region) {
          runtimeConfigRegion = region;
        },
        region() {
          return runtimeConfigRegion;
        }
      };
    };
    resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
      return {
        region: awsRegionExtensionConfiguration.region()
      };
    };
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
var init_config4 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/isFipsRegion.js
var init_isFipsRegion2 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/isFipsRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js
var init_getRealRegion2 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_isFipsRegion2();
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var init_resolveRegionConfig2 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getRealRegion2();
    init_isFipsRegion2();
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js
var init_regionConfig2 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_config4();
    init_resolveRegionConfig2();
  }
});

// ../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
var init_dist_es51 = __esm({
  "../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_extensions4();
    init_regionConfig2();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var asPartial, resolveRuntimeExtensions;
var init_runtimeExtensions = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es51();
    init_dist_es2();
    init_dist_es15();
    asPartial = (t2) => t2;
    resolveRuntimeExtensions = (runtimeConfig, extensions) => {
      const extensionConfiguration = {
        ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
        ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
        ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig))
      };
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return {
        ...runtimeConfig,
        ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
        ...resolveDefaultRuntimeConfig(extensionConfiguration),
        ...resolveHttpHandlerRuntimeConfig(extensionConfiguration)
      };
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client;
var init_S3Client = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es3();
    init_dist_es4();
    init_dist_es5();
    init_dist_es6();
    init_dist_es21();
    init_dist_es23();
    init_dist_es26();
    init_dist_es27();
    init_dist_es28();
    init_dist_es29();
    init_dist_es33();
    init_dist_es36();
    init_dist_es15();
    init_CreateSessionCommand();
    init_EndpointParameters();
    init_runtimeConfig_browser();
    init_runtimeExtensions();
    S3Client = class extends Client {
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig2(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = resolveRegionConfig(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveAwsAuthConfig(_config_5);
        const _config_7 = resolveS3Config(_config_6, { session: [() => this, CreateSessionCommand] });
        const _config_8 = resolveUserAgentConfig(_config_7);
        const _config_9 = resolveEventStreamSerdeConfig(_config_8);
        const _config_10 = resolveRuntimeExtensions(_config_9, configuration?.extensions || []);
        super(_config_10);
        this.config = _config_10;
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getAwsAuthPlugin(this.config));
        this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
        this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
        this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
        this.middlewareStack.use(getS3ExpressPlugin(this.config));
        this.middlewareStack.use(getUserAgentPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/AbortMultipartUploadCommand.js
var AbortMultipartUploadCommand;
var init_AbortMultipartUploadCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/AbortMultipartUploadCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    AbortMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "AbortMultipartUpload", {}).n("S3Client", "AbortMultipartUploadCommand").f(void 0, void 0).ser(se_AbortMultipartUploadCommand).de(de_AbortMultipartUploadCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
function ssecMiddleware(options) {
  return (next) => async (args) => {
    const input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        let valueForHash;
        if (typeof value === "string") {
          if (isValidBase64EncodedSSECustomerKey(value, options)) {
            valueForHash = options.base64Decoder(value);
          } else {
            valueForHash = options.utf8Decoder(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
        } else {
          valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
          input[prop.target] = options.base64Encoder(valueForHash);
        }
        const hash = new options.md5();
        hash.update(valueForHash);
        input[prop.hash] = options.base64Encoder(await hash.digest());
      }
    }
    return next({
      ...args,
      input
    });
  };
}
function isValidBase64EncodedSSECustomerKey(str, options) {
  const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  if (!base64Regex.test(str))
    return false;
  try {
    const decodedBytes = options.base64Decoder(str);
    return decodedBytes.length === 32;
  } catch {
    return false;
  }
}
var ssecMiddlewareOptions, getSsecPlugin;
var init_dist_es52 = __esm({
  "../node_modules/@aws-sdk/middleware-ssec/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    ssecMiddlewareOptions = {
      name: "ssecMiddleware",
      step: "initialize",
      tags: ["SSE"],
      override: true
    };
    getSsecPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/CompleteMultipartUploadCommand.js
var CompleteMultipartUploadCommand;
var init_CompleteMultipartUploadCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/CompleteMultipartUploadCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CompleteMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CompleteMultipartUpload", {}).n("S3Client", "CompleteMultipartUploadCommand").f(CompleteMultipartUploadRequestFilterSensitiveLog, CompleteMultipartUploadOutputFilterSensitiveLog).ser(se_CompleteMultipartUploadCommand).de(de_CompleteMultipartUploadCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/CopyObjectCommand.js
var CopyObjectCommand;
var init_CopyObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/CopyObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CopyObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CopyObject", {}).n("S3Client", "CopyObjectCommand").f(CopyObjectRequestFilterSensitiveLog, CopyObjectOutputFilterSensitiveLog).ser(se_CopyObjectCommand).de(de_CopyObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/middleware-location-constraint/dist-es/index.js
function locationConstraintMiddleware(options) {
  return (next) => async (args) => {
    const { CreateBucketConfiguration } = args.input;
    const region = await options.region();
    if (!CreateBucketConfiguration?.LocationConstraint && !CreateBucketConfiguration?.Location) {
      args = {
        ...args,
        input: {
          ...args.input,
          CreateBucketConfiguration: region === "us-east-1" ? void 0 : { LocationConstraint: region }
        }
      };
    }
    return next(args);
  };
}
var locationConstraintMiddlewareOptions, getLocationConstraintPlugin;
var init_dist_es53 = __esm({
  "../node_modules/@aws-sdk/middleware-location-constraint/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    locationConstraintMiddlewareOptions = {
      step: "initialize",
      tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
      name: "locationConstraintMiddleware",
      override: true
    };
    getLocationConstraintPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(locationConstraintMiddleware(config), locationConstraintMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketCommand.js
var CreateBucketCommand;
var init_CreateBucketCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es53();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    CreateBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      DisableAccessPoints: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getLocationConstraintPlugin(config)
      ];
    }).s("AmazonS3", "CreateBucket", {}).n("S3Client", "CreateBucketCommand").f(void 0, void 0).ser(se_CreateBucketCommand).de(de_CreateBucketCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateMultipartUploadCommand.js
var CreateMultipartUploadCommand;
var init_CreateMultipartUploadCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateMultipartUploadCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CreateMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CreateMultipartUpload", {}).n("S3Client", "CreateMultipartUploadCommand").f(CreateMultipartUploadRequestFilterSensitiveLog, CreateMultipartUploadOutputFilterSensitiveLog).ser(se_CreateMultipartUploadCommand).de(de_CreateMultipartUploadCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketAnalyticsConfigurationCommand.js
var DeleteBucketAnalyticsConfigurationCommand;
var init_DeleteBucketAnalyticsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketAnalyticsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {}).n("S3Client", "DeleteBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketAnalyticsConfigurationCommand).de(de_DeleteBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCommand.js
var DeleteBucketCommand;
var init_DeleteBucketCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucket", {}).n("S3Client", "DeleteBucketCommand").f(void 0, void 0).ser(se_DeleteBucketCommand).de(de_DeleteBucketCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCorsCommand.js
var DeleteBucketCorsCommand;
var init_DeleteBucketCorsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCorsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketCors", {}).n("S3Client", "DeleteBucketCorsCommand").f(void 0, void 0).ser(se_DeleteBucketCorsCommand).de(de_DeleteBucketCorsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketEncryptionCommand.js
var DeleteBucketEncryptionCommand;
var init_DeleteBucketEncryptionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketEncryptionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketEncryption", {}).n("S3Client", "DeleteBucketEncryptionCommand").f(void 0, void 0).ser(se_DeleteBucketEncryptionCommand).de(de_DeleteBucketEncryptionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketIntelligentTieringConfigurationCommand.js
var DeleteBucketIntelligentTieringConfigurationCommand;
var init_DeleteBucketIntelligentTieringConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketIntelligentTieringConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {}).n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketIntelligentTieringConfigurationCommand).de(de_DeleteBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketInventoryConfigurationCommand.js
var DeleteBucketInventoryConfigurationCommand;
var init_DeleteBucketInventoryConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketInventoryConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketInventoryConfiguration", {}).n("S3Client", "DeleteBucketInventoryConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketInventoryConfigurationCommand).de(de_DeleteBucketInventoryConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketLifecycleCommand.js
var DeleteBucketLifecycleCommand;
var init_DeleteBucketLifecycleCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketLifecycleCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketLifecycleCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketLifecycle", {}).n("S3Client", "DeleteBucketLifecycleCommand").f(void 0, void 0).ser(se_DeleteBucketLifecycleCommand).de(de_DeleteBucketLifecycleCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetricsConfigurationCommand.js
var DeleteBucketMetricsConfigurationCommand;
var init_DeleteBucketMetricsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetricsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketMetricsConfiguration", {}).n("S3Client", "DeleteBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketMetricsConfigurationCommand).de(de_DeleteBucketMetricsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketOwnershipControlsCommand.js
var DeleteBucketOwnershipControlsCommand;
var init_DeleteBucketOwnershipControlsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketOwnershipControlsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketOwnershipControls", {}).n("S3Client", "DeleteBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_DeleteBucketOwnershipControlsCommand).de(de_DeleteBucketOwnershipControlsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketPolicyCommand.js
var DeleteBucketPolicyCommand;
var init_DeleteBucketPolicyCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketPolicyCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketPolicy", {}).n("S3Client", "DeleteBucketPolicyCommand").f(void 0, void 0).ser(se_DeleteBucketPolicyCommand).de(de_DeleteBucketPolicyCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketReplicationCommand.js
var DeleteBucketReplicationCommand;
var init_DeleteBucketReplicationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketReplicationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketReplication", {}).n("S3Client", "DeleteBucketReplicationCommand").f(void 0, void 0).ser(se_DeleteBucketReplicationCommand).de(de_DeleteBucketReplicationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketTaggingCommand.js
var DeleteBucketTaggingCommand;
var init_DeleteBucketTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketTagging", {}).n("S3Client", "DeleteBucketTaggingCommand").f(void 0, void 0).ser(se_DeleteBucketTaggingCommand).de(de_DeleteBucketTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketWebsiteCommand.js
var DeleteBucketWebsiteCommand;
var init_DeleteBucketWebsiteCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketWebsiteCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketWebsite", {}).n("S3Client", "DeleteBucketWebsiteCommand").f(void 0, void 0).ser(se_DeleteBucketWebsiteCommand).de(de_DeleteBucketWebsiteCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectCommand.js
var DeleteObjectCommand;
var init_DeleteObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteObject", {}).n("S3Client", "DeleteObjectCommand").f(void 0, void 0).ser(se_DeleteObjectCommand).de(de_DeleteObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var ChecksumAlgorithm, ChecksumLocation, DEFAULT_CHECKSUM_ALGORITHM, S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM;
var init_constants9 = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(ChecksumAlgorithm2) {
      ChecksumAlgorithm2["MD5"] = "MD5";
      ChecksumAlgorithm2["CRC32"] = "CRC32";
      ChecksumAlgorithm2["CRC32C"] = "CRC32C";
      ChecksumAlgorithm2["SHA1"] = "SHA1";
      ChecksumAlgorithm2["SHA256"] = "SHA256";
    })(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
    (function(ChecksumLocation2) {
      ChecksumLocation2["HEADER"] = "header";
      ChecksumLocation2["TRAILER"] = "trailer";
    })(ChecksumLocation || (ChecksumLocation = {}));
    DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.MD5;
    S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS, PRIORITY_ORDER_ALGORITHMS;
var init_types7 = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants9();
    CLIENT_SUPPORTED_ALGORITHMS = [
      ChecksumAlgorithm.CRC32,
      ChecksumAlgorithm.CRC32C,
      ChecksumAlgorithm.SHA1,
      ChecksumAlgorithm.SHA256
    ];
    PRIORITY_ORDER_ALGORITHMS = [
      ChecksumAlgorithm.CRC32,
      ChecksumAlgorithm.CRC32C,
      ChecksumAlgorithm.SHA1,
      ChecksumAlgorithm.SHA256
    ];
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest;
var init_getChecksumAlgorithmForRequest = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants9();
    init_types7();
    getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }, isS3Express) => {
      const defaultAlgorithm = isS3Express ? S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM : DEFAULT_CHECKSUM_ALGORITHM;
      if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
        return requestChecksumRequired ? defaultAlgorithm : void 0;
      }
      const checksumAlgorithm = input[requestAlgorithmMember];
      if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
        throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
      }
      return checksumAlgorithm;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
var getChecksumLocationName;
var init_getChecksumLocationName = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants9();
    getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
var hasHeader2;
var init_hasHeader = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    hasHeader2 = (header, headers) => {
      const soughtHeader = header.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
var isStreaming;
var init_isStreaming = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es17();
    isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);
  }
});

// ../node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.js
var require_tslib7 = __commonJS({
  "../node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends2;
    var __assign2;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        extendStatics2(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// ../node_modules/@aws-crypto/crc32c/build/aws_crc32c.js
var require_aws_crc32c = __commonJS({
  "../node_modules/@aws-crypto/crc32c/build/aws_crc32c.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = void 0;
    var tslib_1 = require_tslib7();
    var util_1 = require_build3();
    var index_1 = require_build8();
    var AwsCrc32c2 = (
      /** @class */
      function() {
        function AwsCrc32c3() {
          this.crc32c = new index_1.Crc32c();
        }
        AwsCrc32c3.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32c.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc32c3.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
            });
          });
        };
        AwsCrc32c3.prototype.reset = function() {
          this.crc32c = new index_1.Crc32c();
        };
        return AwsCrc32c3;
      }()
    );
    exports.AwsCrc32c = AwsCrc32c2;
  }
});

// ../node_modules/@aws-crypto/crc32c/build/index.js
var require_build8 = __commonJS({
  "../node_modules/@aws-crypto/crc32c/build/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = exports.Crc32c = exports.crc32c = void 0;
    var tslib_1 = require_tslib7();
    var util_1 = require_build3();
    function crc32c(data) {
      return new Crc32c().update(data).digest();
    }
    exports.crc32c = crc32c;
    var Crc32c = (
      /** @class */
      function() {
        function Crc32c2() {
          this.checksum = 4294967295;
        }
        Crc32c2.prototype.update = function(data) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
                _a2.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc32c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc32c2;
      }()
    );
    exports.Crc32c = Crc32c;
    var a_lookupTable = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
    var aws_crc32c_1 = require_aws_crc32c();
    Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
      return aws_crc32c_1.AwsCrc32c;
    } });
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var import_crc323, import_crc32c, selectChecksumAlgorithmFunction;
var init_selectChecksumAlgorithmFunction = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    import_crc323 = __toESM(require_build7());
    import_crc32c = __toESM(require_build8());
    init_constants9();
    selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
      [ChecksumAlgorithm.MD5]: config.md5,
      [ChecksumAlgorithm.CRC32]: import_crc323.AwsCrc32,
      [ChecksumAlgorithm.CRC32C]: import_crc32c.AwsCrc32c,
      [ChecksumAlgorithm.SHA1]: config.sha1,
      [ChecksumAlgorithm.SHA256]: config.sha256
    })[checksumAlgorithm];
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
var stringHasher;
var init_stringHasher = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es8();
    stringHasher = (checksumAlgorithmFn, body) => {
      const hash = new checksumAlgorithmFn();
      hash.update(toUint8Array2(body || ""));
      return hash.digest();
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddlewareOptions, flexibleChecksumsMiddleware;
var init_flexibleChecksumsMiddleware = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_getChecksumAlgorithmForRequest();
    init_getChecksumLocationName();
    init_hasHeader();
    init_isStreaming();
    init_selectChecksumAlgorithmFunction();
    init_stringHasher();
    flexibleChecksumsMiddlewareOptions = {
      name: "flexibleChecksumsMiddleware",
      step: "build",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const { request } = args;
      const { body: requestBody, headers } = request;
      const { base64Encoder, streamHasher } = config;
      const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
      const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
        requestChecksumRequired,
        requestAlgorithmMember
      }, !!context.isS3ExpressBucket);
      let updatedBody = requestBody;
      let updatedHeaders = headers;
      if (checksumAlgorithm) {
        const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
        const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
        if (isStreaming(requestBody)) {
          const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config;
          updatedBody = getAwsChunkedEncodingStream2(requestBody, {
            base64Encoder,
            bodyLengthChecker,
            checksumLocationName,
            checksumAlgorithmFn,
            streamHasher
          });
          updatedHeaders = {
            ...headers,
            "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
            "transfer-encoding": "chunked",
            "x-amz-decoded-content-length": headers["content-length"],
            "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
            "x-amz-trailer": checksumLocationName
          };
          delete updatedHeaders["content-length"];
        } else if (!hasHeader2(checksumLocationName, headers)) {
          const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
          updatedHeaders = {
            ...headers,
            [checksumLocationName]: base64Encoder(rawChecksum)
          };
        }
      }
      const result = await next({
        ...args,
        request: {
          ...request,
          headers: updatedHeaders,
          body: updatedBody
        }
      });
      return result;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
var getChecksumAlgorithmListForResponse;
var init_getChecksumAlgorithmListForResponse = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_types7();
    getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
      const validChecksumAlgorithms = [];
      for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
        if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
          continue;
        }
        validChecksumAlgorithms.push(algorithm);
      }
      return validChecksumAlgorithms;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
var isChecksumWithPartNumber;
var init_isChecksumWithPartNumber = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    isChecksumWithPartNumber = (checksum) => {
      const lastHyphenIndex = checksum.lastIndexOf("-");
      if (lastHyphenIndex !== -1) {
        const numberPart = checksum.slice(lastHyphenIndex + 1);
        if (!numberPart.startsWith("0")) {
          const number = parseInt(numberPart, 10);
          if (!isNaN(number) && number >= 1 && number <= 1e4) {
            return true;
          }
        }
      }
      return false;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/streams/create-read-stream-on-buffer.browser.js
function createReadStreamOnBuffer(buffer2) {
  return new Blob([buffer2]).stream();
}
var init_create_read_stream_on_buffer_browser = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/streams/create-read-stream-on-buffer.browser.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
var getChecksum;
var init_getChecksum = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_isStreaming();
    init_stringHasher();
    getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
      const digest = isStreaming(body) ? streamHasher(checksumAlgorithmFn, body) : stringHasher(checksumAlgorithmFn, body);
      return base64Encoder(await digest);
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse;
var init_validateChecksumFromResponse = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_getChecksum();
    init_getChecksumAlgorithmListForResponse();
    init_getChecksumLocationName();
    init_selectChecksumAlgorithmFunction();
    validateChecksumFromResponse = async (response, { config, responseAlgorithms }) => {
      const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
      const { body: responseBody, headers: responseHeaders } = response;
      for (const algorithm of checksumAlgorithms) {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = responseHeaders[responseHeader];
        if (checksumFromResponse) {
          const checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
          const { streamHasher, base64Encoder } = config;
          const checksum = await getChecksum(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
          if (checksum === checksumFromResponse) {
            break;
          }
          throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
        }
      }
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
var flexibleChecksumsResponseMiddlewareOptions, flexibleChecksumsResponseMiddleware;
var init_flexibleChecksumsResponseMiddleware = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es2();
    init_getChecksumAlgorithmListForResponse();
    init_getChecksumLocationName();
    init_isChecksumWithPartNumber();
    init_isStreaming();
    init_create_read_stream_on_buffer_browser();
    init_validateChecksumFromResponse();
    flexibleChecksumsResponseMiddlewareOptions = {
      name: "flexibleChecksumsResponseMiddleware",
      toMiddleware: "deserializerMiddleware",
      relation: "after",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const input = args.input;
      const result = await next(args);
      const response = result.response;
      let collectedStream = void 0;
      const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
      if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
        const { clientName, commandName } = context;
        const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
          const responseHeader = getChecksumLocationName(algorithm);
          const checksumFromResponse = response.headers[responseHeader];
          return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
        });
        if (isS3WholeObjectMultipartGetResponseChecksum) {
          return result;
        }
        const isStreamingBody = isStreaming(response.body);
        if (isStreamingBody) {
          collectedStream = await config.streamCollector(response.body);
          response.body = createReadStreamOnBuffer(collectedStream);
        }
        await validateChecksumFromResponse(result.response, {
          config,
          responseAlgorithms
        });
        if (isStreamingBody && collectedStream) {
          response.body = createReadStreamOnBuffer(collectedStream);
        }
      }
      return result;
    };
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var getFlexibleChecksumsPlugin;
var init_getFlexibleChecksumsPlugin = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_flexibleChecksumsMiddleware();
    init_flexibleChecksumsResponseMiddleware();
    getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
        clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
      }
    });
  }
});

// ../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js
var init_dist_es54 = __esm({
  "../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_constants9();
    init_flexibleChecksumsMiddleware();
    init_getFlexibleChecksumsPlugin();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectsCommand.js
var DeleteObjectsCommand;
var init_DeleteObjectsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "DeleteObjects", {}).n("S3Client", "DeleteObjectsCommand").f(void 0, void 0).ser(se_DeleteObjectsCommand).de(de_DeleteObjectsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectTaggingCommand.js
var DeleteObjectTaggingCommand;
var init_DeleteObjectTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteObjectTagging", {}).n("S3Client", "DeleteObjectTaggingCommand").f(void 0, void 0).ser(se_DeleteObjectTaggingCommand).de(de_DeleteObjectTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/DeletePublicAccessBlockCommand.js
var DeletePublicAccessBlockCommand;
var init_DeletePublicAccessBlockCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/DeletePublicAccessBlockCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    DeletePublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeletePublicAccessBlock", {}).n("S3Client", "DeletePublicAccessBlockCommand").f(void 0, void 0).ser(se_DeletePublicAccessBlockCommand).de(de_DeletePublicAccessBlockCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAccelerateConfigurationCommand.js
var GetBucketAccelerateConfigurationCommand;
var init_GetBucketAccelerateConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAccelerateConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAccelerateConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketAccelerateConfiguration", {}).n("S3Client", "GetBucketAccelerateConfigurationCommand").f(void 0, void 0).ser(se_GetBucketAccelerateConfigurationCommand).de(de_GetBucketAccelerateConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAclCommand.js
var GetBucketAclCommand;
var init_GetBucketAclCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAclCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketAcl", {}).n("S3Client", "GetBucketAclCommand").f(void 0, void 0).ser(se_GetBucketAclCommand).de(de_GetBucketAclCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAnalyticsConfigurationCommand.js
var GetBucketAnalyticsConfigurationCommand;
var init_GetBucketAnalyticsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAnalyticsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketAnalyticsConfiguration", {}).n("S3Client", "GetBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_GetBucketAnalyticsConfigurationCommand).de(de_GetBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketCorsCommand.js
var GetBucketCorsCommand;
var init_GetBucketCorsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketCorsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketCors", {}).n("S3Client", "GetBucketCorsCommand").f(void 0, void 0).ser(se_GetBucketCorsCommand).de(de_GetBucketCorsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketEncryptionCommand.js
var GetBucketEncryptionCommand;
var init_GetBucketEncryptionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketEncryptionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketEncryption", {}).n("S3Client", "GetBucketEncryptionCommand").f(void 0, GetBucketEncryptionOutputFilterSensitiveLog).ser(se_GetBucketEncryptionCommand).de(de_GetBucketEncryptionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketIntelligentTieringConfigurationCommand.js
var GetBucketIntelligentTieringConfigurationCommand;
var init_GetBucketIntelligentTieringConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketIntelligentTieringConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {}).n("S3Client", "GetBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_GetBucketIntelligentTieringConfigurationCommand).de(de_GetBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketInventoryConfigurationCommand.js
var GetBucketInventoryConfigurationCommand;
var init_GetBucketInventoryConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketInventoryConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketInventoryConfiguration", {}).n("S3Client", "GetBucketInventoryConfigurationCommand").f(void 0, GetBucketInventoryConfigurationOutputFilterSensitiveLog).ser(se_GetBucketInventoryConfigurationCommand).de(de_GetBucketInventoryConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLifecycleConfigurationCommand.js
var GetBucketLifecycleConfigurationCommand;
var init_GetBucketLifecycleConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLifecycleConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLifecycleConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketLifecycleConfiguration", {}).n("S3Client", "GetBucketLifecycleConfigurationCommand").f(void 0, void 0).ser(se_GetBucketLifecycleConfigurationCommand).de(de_GetBucketLifecycleConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLocationCommand.js
var GetBucketLocationCommand;
var init_GetBucketLocationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLocationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLocationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketLocation", {}).n("S3Client", "GetBucketLocationCommand").f(void 0, void 0).ser(se_GetBucketLocationCommand).de(de_GetBucketLocationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLoggingCommand.js
var GetBucketLoggingCommand;
var init_GetBucketLoggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLoggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLoggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketLogging", {}).n("S3Client", "GetBucketLoggingCommand").f(void 0, void 0).ser(se_GetBucketLoggingCommand).de(de_GetBucketLoggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetricsConfigurationCommand.js
var GetBucketMetricsConfigurationCommand;
var init_GetBucketMetricsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetricsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketMetricsConfiguration", {}).n("S3Client", "GetBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_GetBucketMetricsConfigurationCommand).de(de_GetBucketMetricsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketNotificationConfigurationCommand.js
var GetBucketNotificationConfigurationCommand;
var init_GetBucketNotificationConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketNotificationConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketNotificationConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketNotificationConfiguration", {}).n("S3Client", "GetBucketNotificationConfigurationCommand").f(void 0, void 0).ser(se_GetBucketNotificationConfigurationCommand).de(de_GetBucketNotificationConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketOwnershipControlsCommand.js
var GetBucketOwnershipControlsCommand;
var init_GetBucketOwnershipControlsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketOwnershipControlsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketOwnershipControls", {}).n("S3Client", "GetBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_GetBucketOwnershipControlsCommand).de(de_GetBucketOwnershipControlsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyCommand.js
var GetBucketPolicyCommand;
var init_GetBucketPolicyCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketPolicy", {}).n("S3Client", "GetBucketPolicyCommand").f(void 0, void 0).ser(se_GetBucketPolicyCommand).de(de_GetBucketPolicyCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyStatusCommand.js
var GetBucketPolicyStatusCommand;
var init_GetBucketPolicyStatusCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyStatusCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketPolicyStatusCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketPolicyStatus", {}).n("S3Client", "GetBucketPolicyStatusCommand").f(void 0, void 0).ser(se_GetBucketPolicyStatusCommand).de(de_GetBucketPolicyStatusCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketReplicationCommand.js
var GetBucketReplicationCommand;
var init_GetBucketReplicationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketReplicationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketReplication", {}).n("S3Client", "GetBucketReplicationCommand").f(void 0, void 0).ser(se_GetBucketReplicationCommand).de(de_GetBucketReplicationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketRequestPaymentCommand.js
var GetBucketRequestPaymentCommand;
var init_GetBucketRequestPaymentCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketRequestPaymentCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketRequestPaymentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketRequestPayment", {}).n("S3Client", "GetBucketRequestPaymentCommand").f(void 0, void 0).ser(se_GetBucketRequestPaymentCommand).de(de_GetBucketRequestPaymentCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketTaggingCommand.js
var GetBucketTaggingCommand;
var init_GetBucketTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketTagging", {}).n("S3Client", "GetBucketTaggingCommand").f(void 0, void 0).ser(se_GetBucketTaggingCommand).de(de_GetBucketTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketVersioningCommand.js
var GetBucketVersioningCommand;
var init_GetBucketVersioningCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketVersioningCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketVersioningCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketVersioning", {}).n("S3Client", "GetBucketVersioningCommand").f(void 0, void 0).ser(se_GetBucketVersioningCommand).de(de_GetBucketVersioningCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketWebsiteCommand.js
var GetBucketWebsiteCommand;
var init_GetBucketWebsiteCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketWebsiteCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetBucketWebsite", {}).n("S3Client", "GetBucketWebsiteCommand").f(void 0, void 0).ser(se_GetBucketWebsiteCommand).de(de_GetBucketWebsiteCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAclCommand.js
var GetObjectAclCommand;
var init_GetObjectAclCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAclCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectAcl", {}).n("S3Client", "GetObjectAclCommand").f(void 0, void 0).ser(se_GetObjectAclCommand).de(de_GetObjectAclCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAttributesCommand.js
var GetObjectAttributesCommand;
var init_GetObjectAttributesCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAttributesCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectAttributesCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectAttributes", {}).n("S3Client", "GetObjectAttributesCommand").f(GetObjectAttributesRequestFilterSensitiveLog, void 0).ser(se_GetObjectAttributesCommand).de(de_GetObjectAttributesCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js
var GetObjectCommand;
var init_GetObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config),
        getS3ExpiresMiddlewarePlugin(config),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestChecksumRequired: false,
          requestValidationModeMember: "ChecksumMode",
          responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"]
        })
      ];
    }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").f(GetObjectRequestFilterSensitiveLog, GetObjectOutputFilterSensitiveLog).ser(se_GetObjectCommand).de(de_GetObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLegalHoldCommand.js
var GetObjectLegalHoldCommand;
var init_GetObjectLegalHoldCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLegalHoldCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectLegalHoldCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectLegalHold", {}).n("S3Client", "GetObjectLegalHoldCommand").f(void 0, void 0).ser(se_GetObjectLegalHoldCommand).de(de_GetObjectLegalHoldCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLockConfigurationCommand.js
var GetObjectLockConfigurationCommand;
var init_GetObjectLockConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLockConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectLockConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectLockConfiguration", {}).n("S3Client", "GetObjectLockConfigurationCommand").f(void 0, void 0).ser(se_GetObjectLockConfigurationCommand).de(de_GetObjectLockConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectRetentionCommand.js
var GetObjectRetentionCommand;
var init_GetObjectRetentionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectRetentionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectRetentionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectRetention", {}).n("S3Client", "GetObjectRetentionCommand").f(void 0, void 0).ser(se_GetObjectRetentionCommand).de(de_GetObjectRetentionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTaggingCommand.js
var GetObjectTaggingCommand;
var init_GetObjectTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectTagging", {}).n("S3Client", "GetObjectTaggingCommand").f(void 0, void 0).ser(se_GetObjectTaggingCommand).de(de_GetObjectTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTorrentCommand.js
var GetObjectTorrentCommand;
var init_GetObjectTorrentCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTorrentCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectTorrentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectTorrent", {}).n("S3Client", "GetObjectTorrentCommand").f(void 0, GetObjectTorrentOutputFilterSensitiveLog).ser(se_GetObjectTorrentCommand).de(de_GetObjectTorrentCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/GetPublicAccessBlockCommand.js
var GetPublicAccessBlockCommand;
var init_GetPublicAccessBlockCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/GetPublicAccessBlockCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    GetPublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetPublicAccessBlock", {}).n("S3Client", "GetPublicAccessBlockCommand").f(void 0, void 0).ser(se_GetPublicAccessBlockCommand).de(de_GetPublicAccessBlockCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/HeadBucketCommand.js
var HeadBucketCommand;
var init_HeadBucketCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/HeadBucketCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    HeadBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "HeadBucket", {}).n("S3Client", "HeadBucketCommand").f(void 0, void 0).ser(se_HeadBucketCommand).de(de_HeadBucketCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js
var HeadObjectCommand;
var init_HeadObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    HeadObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config),
        getS3ExpiresMiddlewarePlugin(config)
      ];
    }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").f(HeadObjectRequestFilterSensitiveLog, HeadObjectOutputFilterSensitiveLog).ser(se_HeadObjectCommand).de(de_HeadObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketAnalyticsConfigurationsCommand.js
var ListBucketAnalyticsConfigurationsCommand;
var init_ListBucketAnalyticsConfigurationsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketAnalyticsConfigurationsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketAnalyticsConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListBucketAnalyticsConfigurations", {}).n("S3Client", "ListBucketAnalyticsConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketAnalyticsConfigurationsCommand).de(de_ListBucketAnalyticsConfigurationsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketIntelligentTieringConfigurationsCommand.js
var ListBucketIntelligentTieringConfigurationsCommand;
var init_ListBucketIntelligentTieringConfigurationsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketIntelligentTieringConfigurationsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketIntelligentTieringConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {}).n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketIntelligentTieringConfigurationsCommand).de(de_ListBucketIntelligentTieringConfigurationsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketInventoryConfigurationsCommand.js
var ListBucketInventoryConfigurationsCommand;
var init_ListBucketInventoryConfigurationsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketInventoryConfigurationsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    ListBucketInventoryConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListBucketInventoryConfigurations", {}).n("S3Client", "ListBucketInventoryConfigurationsCommand").f(void 0, ListBucketInventoryConfigurationsOutputFilterSensitiveLog).ser(se_ListBucketInventoryConfigurationsCommand).de(de_ListBucketInventoryConfigurationsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketMetricsConfigurationsCommand.js
var ListBucketMetricsConfigurationsCommand;
var init_ListBucketMetricsConfigurationsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketMetricsConfigurationsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketMetricsConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListBucketMetricsConfigurations", {}).n("S3Client", "ListBucketMetricsConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketMetricsConfigurationsCommand).de(de_ListBucketMetricsConfigurationsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketsCommand.js
var ListBucketsCommand;
var init_ListBucketsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketsCommand = class extends Command.classBuilder().ep({
      ...commonParams
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListBuckets", {}).n("S3Client", "ListBucketsCommand").f(void 0, void 0).ser(se_ListBucketsCommand).de(de_ListBucketsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListDirectoryBucketsCommand.js
var ListDirectoryBucketsCommand;
var init_ListDirectoryBucketsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListDirectoryBucketsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListDirectoryBucketsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListDirectoryBuckets", {}).n("S3Client", "ListDirectoryBucketsCommand").f(void 0, void 0).ser(se_ListDirectoryBucketsCommand).de(de_ListDirectoryBucketsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListMultipartUploadsCommand.js
var ListMultipartUploadsCommand;
var init_ListMultipartUploadsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListMultipartUploadsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListMultipartUploadsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListMultipartUploads", {}).n("S3Client", "ListMultipartUploadsCommand").f(void 0, void 0).ser(se_ListMultipartUploadsCommand).de(de_ListMultipartUploadsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsCommand.js
var ListObjectsCommand;
var init_ListObjectsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListObjects", {}).n("S3Client", "ListObjectsCommand").f(void 0, void 0).ser(se_ListObjectsCommand).de(de_ListObjectsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsV2Command.js
var ListObjectsV2Command;
var init_ListObjectsV2Command = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsV2Command.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectsV2Command = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListObjectsV2", {}).n("S3Client", "ListObjectsV2Command").f(void 0, void 0).ser(se_ListObjectsV2Command).de(de_ListObjectsV2Command).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectVersionsCommand.js
var ListObjectVersionsCommand;
var init_ListObjectVersionsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectVersionsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectVersionsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "ListObjectVersions", {}).n("S3Client", "ListObjectVersionsCommand").f(void 0, void 0).ser(se_ListObjectVersionsCommand).de(de_ListObjectVersionsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/ListPartsCommand.js
var ListPartsCommand;
var init_ListPartsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/ListPartsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    ListPartsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "ListParts", {}).n("S3Client", "ListPartsCommand").f(ListPartsRequestFilterSensitiveLog, void 0).ser(se_ListPartsCommand).de(de_ListPartsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAccelerateConfigurationCommand.js
var PutBucketAccelerateConfigurationCommand;
var init_PutBucketAccelerateConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAccelerateConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAccelerateConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "PutBucketAccelerateConfiguration", {}).n("S3Client", "PutBucketAccelerateConfigurationCommand").f(void 0, void 0).ser(se_PutBucketAccelerateConfigurationCommand).de(de_PutBucketAccelerateConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAclCommand.js
var PutBucketAclCommand;
var init_PutBucketAclCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAclCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketAcl", {}).n("S3Client", "PutBucketAclCommand").f(void 0, void 0).ser(se_PutBucketAclCommand).de(de_PutBucketAclCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAnalyticsConfigurationCommand.js
var PutBucketAnalyticsConfigurationCommand;
var init_PutBucketAnalyticsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAnalyticsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketAnalyticsConfiguration", {}).n("S3Client", "PutBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_PutBucketAnalyticsConfigurationCommand).de(de_PutBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketCorsCommand.js
var PutBucketCorsCommand;
var init_PutBucketCorsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketCorsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketCors", {}).n("S3Client", "PutBucketCorsCommand").f(void 0, void 0).ser(se_PutBucketCorsCommand).de(de_PutBucketCorsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketEncryptionCommand.js
var PutBucketEncryptionCommand;
var init_PutBucketEncryptionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketEncryptionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    PutBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketEncryption", {}).n("S3Client", "PutBucketEncryptionCommand").f(PutBucketEncryptionRequestFilterSensitiveLog, void 0).ser(se_PutBucketEncryptionCommand).de(de_PutBucketEncryptionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketIntelligentTieringConfigurationCommand.js
var PutBucketIntelligentTieringConfigurationCommand;
var init_PutBucketIntelligentTieringConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketIntelligentTieringConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {}).n("S3Client", "PutBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_PutBucketIntelligentTieringConfigurationCommand).de(de_PutBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketInventoryConfigurationCommand.js
var PutBucketInventoryConfigurationCommand;
var init_PutBucketInventoryConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketInventoryConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    PutBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketInventoryConfiguration", {}).n("S3Client", "PutBucketInventoryConfigurationCommand").f(PutBucketInventoryConfigurationRequestFilterSensitiveLog, void 0).ser(se_PutBucketInventoryConfigurationCommand).de(de_PutBucketInventoryConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLifecycleConfigurationCommand.js
var PutBucketLifecycleConfigurationCommand;
var init_PutBucketLifecycleConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLifecycleConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketLifecycleConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketLifecycleConfiguration", {}).n("S3Client", "PutBucketLifecycleConfigurationCommand").f(void 0, void 0).ser(se_PutBucketLifecycleConfigurationCommand).de(de_PutBucketLifecycleConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLoggingCommand.js
var PutBucketLoggingCommand;
var init_PutBucketLoggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLoggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketLoggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketLogging", {}).n("S3Client", "PutBucketLoggingCommand").f(void 0, void 0).ser(se_PutBucketLoggingCommand).de(de_PutBucketLoggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketMetricsConfigurationCommand.js
var PutBucketMetricsConfigurationCommand;
var init_PutBucketMetricsConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketMetricsConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketMetricsConfiguration", {}).n("S3Client", "PutBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_PutBucketMetricsConfigurationCommand).de(de_PutBucketMetricsConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketNotificationConfigurationCommand.js
var PutBucketNotificationConfigurationCommand;
var init_PutBucketNotificationConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketNotificationConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketNotificationConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketNotificationConfiguration", {}).n("S3Client", "PutBucketNotificationConfigurationCommand").f(void 0, void 0).ser(se_PutBucketNotificationConfigurationCommand).de(de_PutBucketNotificationConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketOwnershipControlsCommand.js
var PutBucketOwnershipControlsCommand;
var init_PutBucketOwnershipControlsCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketOwnershipControlsCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, { input: this.input, requestChecksumRequired: true })
      ];
    }).s("AmazonS3", "PutBucketOwnershipControls", {}).n("S3Client", "PutBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_PutBucketOwnershipControlsCommand).de(de_PutBucketOwnershipControlsCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketPolicyCommand.js
var PutBucketPolicyCommand;
var init_PutBucketPolicyCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketPolicyCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketPolicy", {}).n("S3Client", "PutBucketPolicyCommand").f(void 0, void 0).ser(se_PutBucketPolicyCommand).de(de_PutBucketPolicyCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketReplicationCommand.js
var PutBucketReplicationCommand;
var init_PutBucketReplicationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketReplicationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketReplication", {}).n("S3Client", "PutBucketReplicationCommand").f(void 0, void 0).ser(se_PutBucketReplicationCommand).de(de_PutBucketReplicationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketRequestPaymentCommand.js
var PutBucketRequestPaymentCommand;
var init_PutBucketRequestPaymentCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketRequestPaymentCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketRequestPaymentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketRequestPayment", {}).n("S3Client", "PutBucketRequestPaymentCommand").f(void 0, void 0).ser(se_PutBucketRequestPaymentCommand).de(de_PutBucketRequestPaymentCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketTaggingCommand.js
var PutBucketTaggingCommand;
var init_PutBucketTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketTagging", {}).n("S3Client", "PutBucketTaggingCommand").f(void 0, void 0).ser(se_PutBucketTaggingCommand).de(de_PutBucketTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketVersioningCommand.js
var PutBucketVersioningCommand;
var init_PutBucketVersioningCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketVersioningCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketVersioningCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketVersioning", {}).n("S3Client", "PutBucketVersioningCommand").f(void 0, void 0).ser(se_PutBucketVersioningCommand).de(de_PutBucketVersioningCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketWebsiteCommand.js
var PutBucketWebsiteCommand;
var init_PutBucketWebsiteCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketWebsiteCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketWebsite", {}).n("S3Client", "PutBucketWebsiteCommand").f(void 0, void 0).ser(se_PutBucketWebsiteCommand).de(de_PutBucketWebsiteCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectAclCommand.js
var PutObjectAclCommand;
var init_PutObjectAclCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectAclCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutObjectAcl", {}).n("S3Client", "PutObjectAclCommand").f(void 0, void 0).ser(se_PutObjectAclCommand).de(de_PutObjectAclCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
var PutObjectCommand;
var init_PutObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    PutObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getCheckContentLengthHeaderPlugin(config),
        getSsecPlugin(config),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLegalHoldCommand.js
var PutObjectLegalHoldCommand;
var init_PutObjectLegalHoldCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLegalHoldCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectLegalHoldCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutObjectLegalHold", {}).n("S3Client", "PutObjectLegalHoldCommand").f(void 0, void 0).ser(se_PutObjectLegalHoldCommand).de(de_PutObjectLegalHoldCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLockConfigurationCommand.js
var PutObjectLockConfigurationCommand;
var init_PutObjectLockConfigurationCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLockConfigurationCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectLockConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutObjectLockConfiguration", {}).n("S3Client", "PutObjectLockConfigurationCommand").f(void 0, void 0).ser(se_PutObjectLockConfigurationCommand).de(de_PutObjectLockConfigurationCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectRetentionCommand.js
var PutObjectRetentionCommand;
var init_PutObjectRetentionCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectRetentionCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectRetentionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutObjectRetention", {}).n("S3Client", "PutObjectRetentionCommand").f(void 0, void 0).ser(se_PutObjectRetentionCommand).de(de_PutObjectRetentionCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectTaggingCommand.js
var PutObjectTaggingCommand;
var init_PutObjectTaggingCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectTaggingCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutObjectTagging", {}).n("S3Client", "PutObjectTaggingCommand").f(void 0, void 0).ser(se_PutObjectTaggingCommand).de(de_PutObjectTaggingCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/PutPublicAccessBlockCommand.js
var PutPublicAccessBlockCommand;
var init_PutPublicAccessBlockCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/PutPublicAccessBlockCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_Aws_restXml();
    PutPublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutPublicAccessBlock", {}).n("S3Client", "PutPublicAccessBlockCommand").f(void 0, void 0).ser(se_PutPublicAccessBlockCommand).de(de_PutPublicAccessBlockCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/RestoreObjectCommand.js
var RestoreObjectCommand;
var init_RestoreObjectCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/RestoreObjectCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    RestoreObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "RestoreObject", {}).n("S3Client", "RestoreObjectCommand").f(RestoreObjectRequestFilterSensitiveLog, void 0).ser(se_RestoreObjectCommand).de(de_RestoreObjectCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/SelectObjectContentCommand.js
var SelectObjectContentCommand;
var init_SelectObjectContentCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/SelectObjectContentCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    SelectObjectContentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "SelectObjectContent", {
      eventStream: {
        output: true
      }
    }).n("S3Client", "SelectObjectContentCommand").f(SelectObjectContentRequestFilterSensitiveLog, SelectObjectContentOutputFilterSensitiveLog).ser(se_SelectObjectContentCommand).de(de_SelectObjectContentCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCommand.js
var UploadPartCommand;
var init_UploadPartCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es54();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    UploadPartCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getSsecPlugin(config),
        getFlexibleChecksumsPlugin(config, {
          input: this.input,
          requestAlgorithmMember: "ChecksumAlgorithm",
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "UploadPart", {}).n("S3Client", "UploadPartCommand").f(UploadPartRequestFilterSensitiveLog, UploadPartOutputFilterSensitiveLog).ser(se_UploadPartCommand).de(de_UploadPartCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCopyCommand.js
var UploadPartCopyCommand;
var init_UploadPartCopyCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCopyCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es21();
    init_dist_es52();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    UploadPartCopyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "UploadPartCopy", {}).n("S3Client", "UploadPartCopyCommand").f(UploadPartCopyRequestFilterSensitiveLog, UploadPartCopyOutputFilterSensitiveLog).ser(se_UploadPartCopyCommand).de(de_UploadPartCopyCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/WriteGetObjectResponseCommand.js
var WriteGetObjectResponseCommand;
var init_WriteGetObjectResponseCommand = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/WriteGetObjectResponseCommand.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es33();
    init_dist_es32();
    init_dist_es15();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    WriteGetObjectResponseCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseObjectLambdaEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "WriteGetObjectResponse", {}).n("S3Client", "WriteGetObjectResponseCommand").f(WriteGetObjectResponseRequestFilterSensitiveLog, void 0).ser(se_WriteGetObjectResponseCommand).de(de_WriteGetObjectResponseCommand).build() {
    };
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/S3.js
var commands, S3;
var init_S3 = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/S3.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es15();
    init_AbortMultipartUploadCommand();
    init_CompleteMultipartUploadCommand();
    init_CopyObjectCommand();
    init_CreateBucketCommand();
    init_CreateMultipartUploadCommand();
    init_CreateSessionCommand();
    init_DeleteBucketAnalyticsConfigurationCommand();
    init_DeleteBucketCommand();
    init_DeleteBucketCorsCommand();
    init_DeleteBucketEncryptionCommand();
    init_DeleteBucketIntelligentTieringConfigurationCommand();
    init_DeleteBucketInventoryConfigurationCommand();
    init_DeleteBucketLifecycleCommand();
    init_DeleteBucketMetricsConfigurationCommand();
    init_DeleteBucketOwnershipControlsCommand();
    init_DeleteBucketPolicyCommand();
    init_DeleteBucketReplicationCommand();
    init_DeleteBucketTaggingCommand();
    init_DeleteBucketWebsiteCommand();
    init_DeleteObjectCommand();
    init_DeleteObjectsCommand();
    init_DeleteObjectTaggingCommand();
    init_DeletePublicAccessBlockCommand();
    init_GetBucketAccelerateConfigurationCommand();
    init_GetBucketAclCommand();
    init_GetBucketAnalyticsConfigurationCommand();
    init_GetBucketCorsCommand();
    init_GetBucketEncryptionCommand();
    init_GetBucketIntelligentTieringConfigurationCommand();
    init_GetBucketInventoryConfigurationCommand();
    init_GetBucketLifecycleConfigurationCommand();
    init_GetBucketLocationCommand();
    init_GetBucketLoggingCommand();
    init_GetBucketMetricsConfigurationCommand();
    init_GetBucketNotificationConfigurationCommand();
    init_GetBucketOwnershipControlsCommand();
    init_GetBucketPolicyCommand();
    init_GetBucketPolicyStatusCommand();
    init_GetBucketReplicationCommand();
    init_GetBucketRequestPaymentCommand();
    init_GetBucketTaggingCommand();
    init_GetBucketVersioningCommand();
    init_GetBucketWebsiteCommand();
    init_GetObjectAclCommand();
    init_GetObjectAttributesCommand();
    init_GetObjectCommand();
    init_GetObjectLegalHoldCommand();
    init_GetObjectLockConfigurationCommand();
    init_GetObjectRetentionCommand();
    init_GetObjectTaggingCommand();
    init_GetObjectTorrentCommand();
    init_GetPublicAccessBlockCommand();
    init_HeadBucketCommand();
    init_HeadObjectCommand();
    init_ListBucketAnalyticsConfigurationsCommand();
    init_ListBucketIntelligentTieringConfigurationsCommand();
    init_ListBucketInventoryConfigurationsCommand();
    init_ListBucketMetricsConfigurationsCommand();
    init_ListBucketsCommand();
    init_ListDirectoryBucketsCommand();
    init_ListMultipartUploadsCommand();
    init_ListObjectsCommand();
    init_ListObjectsV2Command();
    init_ListObjectVersionsCommand();
    init_ListPartsCommand();
    init_PutBucketAccelerateConfigurationCommand();
    init_PutBucketAclCommand();
    init_PutBucketAnalyticsConfigurationCommand();
    init_PutBucketCorsCommand();
    init_PutBucketEncryptionCommand();
    init_PutBucketIntelligentTieringConfigurationCommand();
    init_PutBucketInventoryConfigurationCommand();
    init_PutBucketLifecycleConfigurationCommand();
    init_PutBucketLoggingCommand();
    init_PutBucketMetricsConfigurationCommand();
    init_PutBucketNotificationConfigurationCommand();
    init_PutBucketOwnershipControlsCommand();
    init_PutBucketPolicyCommand();
    init_PutBucketReplicationCommand();
    init_PutBucketRequestPaymentCommand();
    init_PutBucketTaggingCommand();
    init_PutBucketVersioningCommand();
    init_PutBucketWebsiteCommand();
    init_PutObjectAclCommand();
    init_PutObjectCommand();
    init_PutObjectLegalHoldCommand();
    init_PutObjectLockConfigurationCommand();
    init_PutObjectRetentionCommand();
    init_PutObjectTaggingCommand();
    init_PutPublicAccessBlockCommand();
    init_RestoreObjectCommand();
    init_SelectObjectContentCommand();
    init_UploadPartCommand();
    init_UploadPartCopyCommand();
    init_WriteGetObjectResponseCommand();
    init_S3Client();
    commands = {
      AbortMultipartUploadCommand,
      CompleteMultipartUploadCommand,
      CopyObjectCommand,
      CreateBucketCommand,
      CreateMultipartUploadCommand,
      CreateSessionCommand,
      DeleteBucketCommand,
      DeleteBucketAnalyticsConfigurationCommand,
      DeleteBucketCorsCommand,
      DeleteBucketEncryptionCommand,
      DeleteBucketIntelligentTieringConfigurationCommand,
      DeleteBucketInventoryConfigurationCommand,
      DeleteBucketLifecycleCommand,
      DeleteBucketMetricsConfigurationCommand,
      DeleteBucketOwnershipControlsCommand,
      DeleteBucketPolicyCommand,
      DeleteBucketReplicationCommand,
      DeleteBucketTaggingCommand,
      DeleteBucketWebsiteCommand,
      DeleteObjectCommand,
      DeleteObjectsCommand,
      DeleteObjectTaggingCommand,
      DeletePublicAccessBlockCommand,
      GetBucketAccelerateConfigurationCommand,
      GetBucketAclCommand,
      GetBucketAnalyticsConfigurationCommand,
      GetBucketCorsCommand,
      GetBucketEncryptionCommand,
      GetBucketIntelligentTieringConfigurationCommand,
      GetBucketInventoryConfigurationCommand,
      GetBucketLifecycleConfigurationCommand,
      GetBucketLocationCommand,
      GetBucketLoggingCommand,
      GetBucketMetricsConfigurationCommand,
      GetBucketNotificationConfigurationCommand,
      GetBucketOwnershipControlsCommand,
      GetBucketPolicyCommand,
      GetBucketPolicyStatusCommand,
      GetBucketReplicationCommand,
      GetBucketRequestPaymentCommand,
      GetBucketTaggingCommand,
      GetBucketVersioningCommand,
      GetBucketWebsiteCommand,
      GetObjectCommand,
      GetObjectAclCommand,
      GetObjectAttributesCommand,
      GetObjectLegalHoldCommand,
      GetObjectLockConfigurationCommand,
      GetObjectRetentionCommand,
      GetObjectTaggingCommand,
      GetObjectTorrentCommand,
      GetPublicAccessBlockCommand,
      HeadBucketCommand,
      HeadObjectCommand,
      ListBucketAnalyticsConfigurationsCommand,
      ListBucketIntelligentTieringConfigurationsCommand,
      ListBucketInventoryConfigurationsCommand,
      ListBucketMetricsConfigurationsCommand,
      ListBucketsCommand,
      ListDirectoryBucketsCommand,
      ListMultipartUploadsCommand,
      ListObjectsCommand,
      ListObjectsV2Command,
      ListObjectVersionsCommand,
      ListPartsCommand,
      PutBucketAccelerateConfigurationCommand,
      PutBucketAclCommand,
      PutBucketAnalyticsConfigurationCommand,
      PutBucketCorsCommand,
      PutBucketEncryptionCommand,
      PutBucketIntelligentTieringConfigurationCommand,
      PutBucketInventoryConfigurationCommand,
      PutBucketLifecycleConfigurationCommand,
      PutBucketLoggingCommand,
      PutBucketMetricsConfigurationCommand,
      PutBucketNotificationConfigurationCommand,
      PutBucketOwnershipControlsCommand,
      PutBucketPolicyCommand,
      PutBucketReplicationCommand,
      PutBucketRequestPaymentCommand,
      PutBucketTaggingCommand,
      PutBucketVersioningCommand,
      PutBucketWebsiteCommand,
      PutObjectCommand,
      PutObjectAclCommand,
      PutObjectLegalHoldCommand,
      PutObjectLockConfigurationCommand,
      PutObjectRetentionCommand,
      PutObjectTaggingCommand,
      PutPublicAccessBlockCommand,
      RestoreObjectCommand,
      SelectObjectContentCommand,
      UploadPartCommand,
      UploadPartCopyCommand,
      WriteGetObjectResponseCommand
    };
    S3 = class extends S3Client {
    };
    createAggregatedClient(commands, S3);
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/commands/index.js
var init_commands = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/commands/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_AbortMultipartUploadCommand();
    init_CompleteMultipartUploadCommand();
    init_CopyObjectCommand();
    init_CreateBucketCommand();
    init_CreateMultipartUploadCommand();
    init_CreateSessionCommand();
    init_DeleteBucketAnalyticsConfigurationCommand();
    init_DeleteBucketCommand();
    init_DeleteBucketCorsCommand();
    init_DeleteBucketEncryptionCommand();
    init_DeleteBucketIntelligentTieringConfigurationCommand();
    init_DeleteBucketInventoryConfigurationCommand();
    init_DeleteBucketLifecycleCommand();
    init_DeleteBucketMetricsConfigurationCommand();
    init_DeleteBucketOwnershipControlsCommand();
    init_DeleteBucketPolicyCommand();
    init_DeleteBucketReplicationCommand();
    init_DeleteBucketTaggingCommand();
    init_DeleteBucketWebsiteCommand();
    init_DeleteObjectCommand();
    init_DeleteObjectTaggingCommand();
    init_DeleteObjectsCommand();
    init_DeletePublicAccessBlockCommand();
    init_GetBucketAccelerateConfigurationCommand();
    init_GetBucketAclCommand();
    init_GetBucketAnalyticsConfigurationCommand();
    init_GetBucketCorsCommand();
    init_GetBucketEncryptionCommand();
    init_GetBucketIntelligentTieringConfigurationCommand();
    init_GetBucketInventoryConfigurationCommand();
    init_GetBucketLifecycleConfigurationCommand();
    init_GetBucketLocationCommand();
    init_GetBucketLoggingCommand();
    init_GetBucketMetricsConfigurationCommand();
    init_GetBucketNotificationConfigurationCommand();
    init_GetBucketOwnershipControlsCommand();
    init_GetBucketPolicyCommand();
    init_GetBucketPolicyStatusCommand();
    init_GetBucketReplicationCommand();
    init_GetBucketRequestPaymentCommand();
    init_GetBucketTaggingCommand();
    init_GetBucketVersioningCommand();
    init_GetBucketWebsiteCommand();
    init_GetObjectAclCommand();
    init_GetObjectAttributesCommand();
    init_GetObjectCommand();
    init_GetObjectLegalHoldCommand();
    init_GetObjectLockConfigurationCommand();
    init_GetObjectRetentionCommand();
    init_GetObjectTaggingCommand();
    init_GetObjectTorrentCommand();
    init_GetPublicAccessBlockCommand();
    init_HeadBucketCommand();
    init_HeadObjectCommand();
    init_ListBucketAnalyticsConfigurationsCommand();
    init_ListBucketIntelligentTieringConfigurationsCommand();
    init_ListBucketInventoryConfigurationsCommand();
    init_ListBucketMetricsConfigurationsCommand();
    init_ListBucketsCommand();
    init_ListDirectoryBucketsCommand();
    init_ListMultipartUploadsCommand();
    init_ListObjectVersionsCommand();
    init_ListObjectsCommand();
    init_ListObjectsV2Command();
    init_ListPartsCommand();
    init_PutBucketAccelerateConfigurationCommand();
    init_PutBucketAclCommand();
    init_PutBucketAnalyticsConfigurationCommand();
    init_PutBucketCorsCommand();
    init_PutBucketEncryptionCommand();
    init_PutBucketIntelligentTieringConfigurationCommand();
    init_PutBucketInventoryConfigurationCommand();
    init_PutBucketLifecycleConfigurationCommand();
    init_PutBucketLoggingCommand();
    init_PutBucketMetricsConfigurationCommand();
    init_PutBucketNotificationConfigurationCommand();
    init_PutBucketOwnershipControlsCommand();
    init_PutBucketPolicyCommand();
    init_PutBucketReplicationCommand();
    init_PutBucketRequestPaymentCommand();
    init_PutBucketTaggingCommand();
    init_PutBucketVersioningCommand();
    init_PutBucketWebsiteCommand();
    init_PutObjectAclCommand();
    init_PutObjectCommand();
    init_PutObjectLegalHoldCommand();
    init_PutObjectLockConfigurationCommand();
    init_PutObjectRetentionCommand();
    init_PutObjectTaggingCommand();
    init_PutPublicAccessBlockCommand();
    init_RestoreObjectCommand();
    init_SelectObjectContentCommand();
    init_UploadPartCommand();
    init_UploadPartCopyCommand();
    init_WriteGetObjectResponseCommand();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/pagination/Interfaces.js
var init_Interfaces = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/pagination/Interfaces.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListDirectoryBucketsPaginator.js
var paginateListDirectoryBuckets;
var init_ListDirectoryBucketsPaginator = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListDirectoryBucketsPaginator.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es37();
    init_ListDirectoryBucketsCommand();
    init_S3Client();
    paginateListDirectoryBuckets = createPaginator(S3Client, ListDirectoryBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets");
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListObjectsV2Paginator.js
var paginateListObjectsV2;
var init_ListObjectsV2Paginator = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListObjectsV2Paginator.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es37();
    init_ListObjectsV2Command();
    init_S3Client();
    paginateListObjectsV2 = createPaginator(S3Client, ListObjectsV2Command, "ContinuationToken", "NextContinuationToken", "MaxKeys");
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListPartsPaginator.js
var paginateListParts;
var init_ListPartsPaginator = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/pagination/ListPartsPaginator.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es37();
    init_ListPartsCommand();
    init_S3Client();
    paginateListParts = createPaginator(S3Client, ListPartsCommand, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/pagination/index.js
var init_pagination2 = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/pagination/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_Interfaces();
    init_ListDirectoryBucketsPaginator();
    init_ListObjectsV2Paginator();
    init_ListPartsPaginator();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/utils/sleep.js
var init_sleep = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/utils/sleep.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/waiter.js
var WaiterState;
var init_waiter2 = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/waiter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function(WaiterState2) {
      WaiterState2["ABORTED"] = "ABORTED";
      WaiterState2["FAILURE"] = "FAILURE";
      WaiterState2["SUCCESS"] = "SUCCESS";
      WaiterState2["RETRY"] = "RETRY";
      WaiterState2["TIMEOUT"] = "TIMEOUT";
    })(WaiterState || (WaiterState = {}));
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/poller.js
var init_poller = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/poller.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_sleep();
    init_waiter2();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/utils/validate.js
var init_validate = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/utils/validate.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/utils/index.js
var init_utils3 = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/utils/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_sleep();
    init_validate();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/createWaiter.js
var init_createWaiter = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/createWaiter.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_poller();
    init_utils3();
    init_waiter2();
  }
});

// ../node_modules/@smithy/util-waiter/dist-es/index.js
var init_dist_es55 = __esm({
  "../node_modules/@smithy/util-waiter/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_createWaiter();
    init_waiter2();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketExists.js
var init_waitForBucketExists = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketExists.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es55();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketNotExists.js
var init_waitForBucketNotExists = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketNotExists.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es55();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectExists.js
var init_waitForObjectExists = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectExists.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es55();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectNotExists.js
var init_waitForObjectNotExists = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectNotExists.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es55();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/waiters/index.js
var init_waiters = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/waiters/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_waitForBucketExists();
    init_waitForBucketNotExists();
    init_waitForObjectExists();
    init_waitForObjectNotExists();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/models/index.js
var init_models = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/models/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_models_0();
    init_models_1();
  }
});

// ../node_modules/@aws-sdk/client-s3/dist-es/index.js
var init_dist_es56 = __esm({
  "../node_modules/@aws-sdk/client-s3/dist-es/index.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_S3Client();
    init_S3();
    init_commands();
    init_pagination2();
    init_waiters();
    init_models();
  }
});

// ../cf-utils/upload.js
async function uploadImage(ctx, bucketName, key, body, contentType) {
  const client = new S3Client({
    region: "auto",
    credentials: {
      accessKeyId: ctx.env.S3_ACCESS_KEY_ID,
      secretAccessKey: ctx.env.S3_SECRET_ACCESS_KEY
    },
    endpoint: ctx.env.S3_ENDPOINT,
    s3ForcePathStyle: true
  });
  try {
    const data = await client.send(
      new PutObjectCommand({
        Bucket: bucketName,
        Key: key,
        Body: body,
        ContentType: contentType,
        ACL: "public-read"
      })
    );
    console.log("Success", data);
    return data;
  } catch (err) {
    console.error("Error", err);
    throw new Error("Failed to upload image to S3");
  }
}
var init_upload = __esm({
  "../cf-utils/upload.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist_es56();
  }
});

// ../node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "../node_modules/crypt/crypt.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        // Bit-wise rotation left
        rotl: function(n2, b2) {
          return n2 << b2 | n2 >>> 32 - b2;
        },
        // Bit-wise rotation right
        rotr: function(n2, b2) {
          return n2 << 32 - b2 | n2 >>> b2;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n2) {
          if (n2.constructor == Number) {
            return crypt.rotl(n2, 8) & 16711935 | crypt.rotl(n2, 24) & 4278255360;
          }
          for (var i2 = 0; i2 < n2.length; i2++)
            n2[i2] = crypt.endian(n2[i2]);
          return n2;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n2) {
          for (var bytes = []; n2 > 0; n2--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i2 = 0, b2 = 0; i2 < bytes.length; i2++, b2 += 8)
            words[b2 >>> 5] |= bytes[i2] << 24 - b2 % 32;
          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b2 = 0; b2 < words.length * 32; b2 += 8)
            bytes.push(words[b2 >>> 5] >>> 24 - b2 % 32 & 255);
          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i2 = 0; i2 < bytes.length; i2++) {
            hex.push((bytes[i2] >>> 4).toString(16));
            hex.push((bytes[i2] & 15).toString(16));
          }
          return hex.join("");
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2)
            bytes.push(parseInt(hex.substr(c2, 2), 16));
          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i2 = 0; i2 < bytes.length; i2 += 3) {
            var triplet = bytes[i2] << 16 | bytes[i2 + 1] << 8 | bytes[i2 + 2];
            for (var j2 = 0; j2 < 4; j2++)
              if (i2 * 8 + j2 * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j2) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i2 = 0, imod4 = 0; i2 < base64.length; imod4 = ++i2 % 4) {
            if (imod4 == 0)
              continue;
            bytes.push((base64map.indexOf(base64.charAt(i2 - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i2)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module.exports = crypt;
    })();
  }
});

// ../node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "../node_modules/charenc/charenc.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i2 = 0; i2 < str.length; i2++)
            bytes.push(str.charCodeAt(i2) & 255);
          return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i2 = 0; i2 < bytes.length; i2++)
            str.push(String.fromCharCode(bytes[i2]));
          return str.join("");
        }
      }
    };
    module.exports = charenc;
  }
});

// ../node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "../node_modules/is-buffer/index.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// ../node_modules/md5/md5.js
var require_md5 = __commonJS({
  "../node_modules/md5/md5.js"(exports, module) {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md52 = function(message, options) {
        if (message.constructor == String)
          if (options && options.encoding === "binary")
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
          message = message.toString();
        var m2 = crypt.bytesToWords(message), l2 = message.length * 8, a2 = 1732584193, b2 = -271733879, c2 = -1732584194, d2 = 271733878;
        for (var i2 = 0; i2 < m2.length; i2++) {
          m2[i2] = (m2[i2] << 8 | m2[i2] >>> 24) & 16711935 | (m2[i2] << 24 | m2[i2] >>> 8) & 4278255360;
        }
        m2[l2 >>> 5] |= 128 << l2 % 32;
        m2[(l2 + 64 >>> 9 << 4) + 14] = l2;
        var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
        for (var i2 = 0; i2 < m2.length; i2 += 16) {
          var aa2 = a2, bb2 = b2, cc2 = c2, dd = d2;
          a2 = FF(a2, b2, c2, d2, m2[i2 + 0], 7, -680876936);
          d2 = FF(d2, a2, b2, c2, m2[i2 + 1], 12, -389564586);
          c2 = FF(c2, d2, a2, b2, m2[i2 + 2], 17, 606105819);
          b2 = FF(b2, c2, d2, a2, m2[i2 + 3], 22, -1044525330);
          a2 = FF(a2, b2, c2, d2, m2[i2 + 4], 7, -176418897);
          d2 = FF(d2, a2, b2, c2, m2[i2 + 5], 12, 1200080426);
          c2 = FF(c2, d2, a2, b2, m2[i2 + 6], 17, -1473231341);
          b2 = FF(b2, c2, d2, a2, m2[i2 + 7], 22, -45705983);
          a2 = FF(a2, b2, c2, d2, m2[i2 + 8], 7, 1770035416);
          d2 = FF(d2, a2, b2, c2, m2[i2 + 9], 12, -1958414417);
          c2 = FF(c2, d2, a2, b2, m2[i2 + 10], 17, -42063);
          b2 = FF(b2, c2, d2, a2, m2[i2 + 11], 22, -1990404162);
          a2 = FF(a2, b2, c2, d2, m2[i2 + 12], 7, 1804603682);
          d2 = FF(d2, a2, b2, c2, m2[i2 + 13], 12, -40341101);
          c2 = FF(c2, d2, a2, b2, m2[i2 + 14], 17, -1502002290);
          b2 = FF(b2, c2, d2, a2, m2[i2 + 15], 22, 1236535329);
          a2 = GG(a2, b2, c2, d2, m2[i2 + 1], 5, -165796510);
          d2 = GG(d2, a2, b2, c2, m2[i2 + 6], 9, -1069501632);
          c2 = GG(c2, d2, a2, b2, m2[i2 + 11], 14, 643717713);
          b2 = GG(b2, c2, d2, a2, m2[i2 + 0], 20, -373897302);
          a2 = GG(a2, b2, c2, d2, m2[i2 + 5], 5, -701558691);
          d2 = GG(d2, a2, b2, c2, m2[i2 + 10], 9, 38016083);
          c2 = GG(c2, d2, a2, b2, m2[i2 + 15], 14, -660478335);
          b2 = GG(b2, c2, d2, a2, m2[i2 + 4], 20, -405537848);
          a2 = GG(a2, b2, c2, d2, m2[i2 + 9], 5, 568446438);
          d2 = GG(d2, a2, b2, c2, m2[i2 + 14], 9, -1019803690);
          c2 = GG(c2, d2, a2, b2, m2[i2 + 3], 14, -187363961);
          b2 = GG(b2, c2, d2, a2, m2[i2 + 8], 20, 1163531501);
          a2 = GG(a2, b2, c2, d2, m2[i2 + 13], 5, -1444681467);
          d2 = GG(d2, a2, b2, c2, m2[i2 + 2], 9, -51403784);
          c2 = GG(c2, d2, a2, b2, m2[i2 + 7], 14, 1735328473);
          b2 = GG(b2, c2, d2, a2, m2[i2 + 12], 20, -1926607734);
          a2 = HH(a2, b2, c2, d2, m2[i2 + 5], 4, -378558);
          d2 = HH(d2, a2, b2, c2, m2[i2 + 8], 11, -2022574463);
          c2 = HH(c2, d2, a2, b2, m2[i2 + 11], 16, 1839030562);
          b2 = HH(b2, c2, d2, a2, m2[i2 + 14], 23, -35309556);
          a2 = HH(a2, b2, c2, d2, m2[i2 + 1], 4, -1530992060);
          d2 = HH(d2, a2, b2, c2, m2[i2 + 4], 11, 1272893353);
          c2 = HH(c2, d2, a2, b2, m2[i2 + 7], 16, -155497632);
          b2 = HH(b2, c2, d2, a2, m2[i2 + 10], 23, -1094730640);
          a2 = HH(a2, b2, c2, d2, m2[i2 + 13], 4, 681279174);
          d2 = HH(d2, a2, b2, c2, m2[i2 + 0], 11, -358537222);
          c2 = HH(c2, d2, a2, b2, m2[i2 + 3], 16, -722521979);
          b2 = HH(b2, c2, d2, a2, m2[i2 + 6], 23, 76029189);
          a2 = HH(a2, b2, c2, d2, m2[i2 + 9], 4, -640364487);
          d2 = HH(d2, a2, b2, c2, m2[i2 + 12], 11, -421815835);
          c2 = HH(c2, d2, a2, b2, m2[i2 + 15], 16, 530742520);
          b2 = HH(b2, c2, d2, a2, m2[i2 + 2], 23, -995338651);
          a2 = II(a2, b2, c2, d2, m2[i2 + 0], 6, -198630844);
          d2 = II(d2, a2, b2, c2, m2[i2 + 7], 10, 1126891415);
          c2 = II(c2, d2, a2, b2, m2[i2 + 14], 15, -1416354905);
          b2 = II(b2, c2, d2, a2, m2[i2 + 5], 21, -57434055);
          a2 = II(a2, b2, c2, d2, m2[i2 + 12], 6, 1700485571);
          d2 = II(d2, a2, b2, c2, m2[i2 + 3], 10, -1894986606);
          c2 = II(c2, d2, a2, b2, m2[i2 + 10], 15, -1051523);
          b2 = II(b2, c2, d2, a2, m2[i2 + 1], 21, -2054922799);
          a2 = II(a2, b2, c2, d2, m2[i2 + 8], 6, 1873313359);
          d2 = II(d2, a2, b2, c2, m2[i2 + 15], 10, -30611744);
          c2 = II(c2, d2, a2, b2, m2[i2 + 6], 15, -1560198380);
          b2 = II(b2, c2, d2, a2, m2[i2 + 13], 21, 1309151649);
          a2 = II(a2, b2, c2, d2, m2[i2 + 4], 6, -145523070);
          d2 = II(d2, a2, b2, c2, m2[i2 + 11], 10, -1120210379);
          c2 = II(c2, d2, a2, b2, m2[i2 + 2], 15, 718787259);
          b2 = II(b2, c2, d2, a2, m2[i2 + 9], 21, -343485551);
          a2 = a2 + aa2 >>> 0;
          b2 = b2 + bb2 >>> 0;
          c2 = c2 + cc2 >>> 0;
          d2 = d2 + dd >>> 0;
        }
        return crypt.endian([a2, b2, c2, d2]);
      };
      md52._ff = function(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 & c2 | ~b2 & d2) + (x2 >>> 0) + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      };
      md52._gg = function(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 & d2 | c2 & ~d2) + (x2 >>> 0) + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      };
      md52._hh = function(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (b2 ^ c2 ^ d2) + (x2 >>> 0) + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      };
      md52._ii = function(a2, b2, c2, d2, x2, s2, t2) {
        var n2 = a2 + (c2 ^ (b2 | ~d2)) + (x2 >>> 0) + t2;
        return (n2 << s2 | n2 >>> 32 - s2) + b2;
      };
      md52._blocksize = 16;
      md52._digestsize = 16;
      module.exports = function(message, options) {
        if (message === void 0 || message === null)
          throw new Error("Illegal argument " + message);
        var digestbytes = crypt.wordsToBytes(md52(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
    })();
  }
});

// api/generate_episode.js
async function onRequestPost(context) {
  const { request } = context;
  const json = await request.json();
  const topic = json.topic ?? "Generate episode";
  console.log(context.env.GOOGLE_API_KEY);
  const genai = new GoogleGenerativeAI(context.env.GOOGLE_API_KEY);
  const model = genai.getGenerativeModel({
    model: "gemini-1.5-flash-latest"
  });
  const prompt_parts = ["SYSTEM: " + RequestMD, "\n\nUSER: ", topic];
  const response = await model.generateContent(prompt_parts);
  const text = response.response.text().replace("```json", "").replace("\n```", "").trim();
  const script = JSON.parse(text);
  const url = md5(text);
  const { scripts_collection } = await GetMongo(context);
  for (const entry of script.timeline) {
    const action = entry.get("action");
    let character = action.character;
    if (character) {
      character = entry.character;
    }
    const dialogue = action.dialogue;
    if (dialogue && character) {
      console.log("Generating audio for character", character, dialogue);
      const hash = md5(dialogue);
      const fn = `${hash}.mp3`;
      const ttsv = ttsmap[character.toLowerCase()];
      const response2 = await fetch(
        "https://api.elevenlabs.io/v1/text-to-speech/" + ttsv.id,
        {
          headers: {
            "xi-api-key": context.env.ELEVENLABS_API_KEY
          },
          method: "POST",
          body: JSON.stringify({
            text: dialogue
          })
        }
      );
      const audio = await response2.blob();
      await uploadImage(context, context.env.S3_BUCKET_NAME, fn, audio, "audio/mp3");
      action.audio_file = fn;
      action.audio_cf = true;
    }
  }
  console.log("Updating entry");
  const res = await scripts_collection.updateOne(
    { _id: res.insertedId },
    { $set: { script } }
  );
  console.log("Done");
  for (const entry of script.timeline) {
    const action = entry.action;
    if (action.audio_s3) {
      action.audio_url = "https://bucket.housereaize.myapp.sh/" + action.audio_file;
    }
  }
  return Response.json({ _id: res.insertedId, script, url, views });
}
var import_md5;
var init_generate_episode = __esm({
  "api/generate_episode.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_mongodb();
    init_dist();
    init_request();
    init_ttsmap();
    init_upload();
    import_md5 = __toESM(require_md5());
  }
});

// api/latest-episodes.js
async function onRequestGet2(context) {
  const { scripts_collection } = await GetMongo(context);
  const episodes = await scripts_collection.aggregate([
    {
      $sort: {
        _id: -1
      }
    },
    {
      $limit: 5
    }
  ]);
  return Response.json(
    episodes.map((episode) => ({
      url: episode.url,
      title: episode.script.title,
      views: episode.views
    }))
  );
}
var init_latest_episodes = __esm({
  "api/latest-episodes.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_mongodb();
  }
});

// api/test.js
async function onRequestGet3(context) {
  const response = await fetch(
    "https://api.elevenlabs.io/v1/text-to-speech/ErXwobaYiN019PkySvjV",
    {
      method: "POST",
      headers: {
        "xi-api-key": context.env.ELEVENLABS_API_KEY,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        text: "blah"
      })
    }
  );
  const audio = await response.blob();
  await uploadImage(
    context,
    context.env.S3_BUCKET_NAME,
    "test.mp3",
    audio,
    "audio/mp3"
  );
  return new Response(audio, { "Content-Type": "audio/mp3", status: 200 });
}
var init_test = __esm({
  "api/test.js"() {
    init_functionsRoutes_0_6518097713399247();
    init_checked_fetch();
    init_modules_watch_stub();
    init_upload();
  }
});

// ../.wrangler/tmp/pages-I8KzLw/functionsRoutes-0.6518097713399247.mjs
var routes;
var init_functionsRoutes_0_6518097713399247 = __esm({
  "../.wrangler/tmp/pages-I8KzLw/functionsRoutes-0.6518097713399247.mjs"() {
    init_episodes();
    init_generate_episode();
    init_latest_episodes();
    init_test();
    routes = [
      {
        routePath: "/api/episodes",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet]
      },
      {
        routePath: "/api/generate_episode",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost]
      },
      {
        routePath: "/api/latest-episodes",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet2]
      },
      {
        routePath: "/api/test",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet3]
      }
    ];
  }
});

// ../.wrangler/tmp/bundle-a4mJSG/middleware-loader.entry.ts
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();

// ../.wrangler/tmp/bundle-a4mJSG/middleware-insertion-facade.js
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/wrangler/templates/pages-template-worker.ts
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();

// ../node_modules/path-to-regexp/dist.es2015/index.js
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j2 = i2 + 1;
      while (j2 < str.length) {
        var code2 = str.charCodeAt(j2);
        if (
          // `0-9`
          code2 >= 48 && code2 <= 57 || // `A-Z`
          code2 >= 65 && code2 <= 90 || // `a-z`
          code2 >= 97 && code2 <= 122 || // `_`
          code2 === 95
        ) {
          name += str[j2++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j2;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j2 = i2 + 1;
      if (str[j2] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j2));
      }
      while (j2 < str.length) {
        if (str[j2] === "\\") {
          pattern += str[j2++] + str[j2++];
          continue;
        }
        if (str[j2] === ")") {
          count--;
          if (count === 0) {
            j2++;
            break;
          }
        } else if (str[j2] === "(") {
          count++;
          if (str[j2 + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j2));
          }
        }
        pattern += str[j2++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j2;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a2 = options.prefixes, prefixes = _a2 === void 0 ? "./" : _a2;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a3 = tokens[i2], nextType = _a3.type, index = _a3.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.decode, decode2 = _a2 === void 0 ? function(x2) {
    return x2;
  } : _a2;
  return function(pathname) {
    var m2 = re.exec(pathname);
    if (!m2)
      return false;
    var path = m2[0], index = m2.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i3) {
      if (m2[i3] === void 0)
        return "continue";
      var key = keys[i3 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m2[i3].split(key.prefix + key.suffix).map(function(value) {
          return decode2(value, key);
        });
      } else {
        params[key.name] = decode2(m2[i3], key);
      }
    };
    for (var i2 = 1; i2 < m2.length; i2++) {
      _loop_1(i2);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.strict, strict = _a2 === void 0 ? false : _a2, _b = options.start, start = _b === void 0 ? true : _b, _c2 = options.end, end = _c2 === void 0 ? true : _c2, _d2 = options.encode, encode2 = _d2 === void 0 ? function(x2) {
    return x2;
  } : _d2, _e2 = options.delimiter, delimiter = _e2 === void 0 ? "/#?" : _e2, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i2 = 0, tokens_1 = tokens; _i2 < tokens_1.length; _i2++) {
    var token = tokens_1[_i2];
    if (typeof token === "string") {
      route += escapeString(encode2(token));
    } else {
      var prefix = escapeString(encode2(token.prefix));
      var suffix = escapeString(encode2(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
          } else {
            route += "(".concat(token.pattern, ")").concat(token.modifier);
          }
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// ../node_modules/wrangler/templates/pages-template-worker.ts
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = async (input, init) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: () => {
            isFailOpen = true;
          }
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    };
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = (response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
);

// ../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();
var drainBody = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
};
var middleware_ensure_req_body_drained_default = drainBody;

// ../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e2) {
    const error = reduceError(e2);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;

// ../.wrangler/tmp/bundle-a4mJSG/middleware-insertion-facade.js
pages_template_worker_default.middleware = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default,
  ...pages_template_worker_default.middleware ?? []
].filter(Boolean);
var middleware_insertion_facade_default = pages_template_worker_default;

// ../node_modules/wrangler/templates/middleware/common.ts
init_functionsRoutes_0_6518097713399247();
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// ../.wrangler/tmp/bundle-a4mJSG/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (worker.middleware === void 0 || worker.middleware.length === 0) {
    return worker;
  }
  for (const middleware of worker.middleware) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  };
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
function wrapWorkerEntrypoint(klass) {
  if (klass.middleware === void 0 || klass.middleware.length === 0) {
    return klass;
  }
  for (const middleware of klass.middleware) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  middleware_loader_entry_default as default
};
/*! Bundled license information:

bson/dist/bson.browser.esm.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=functionsWorker-0.08306548593859842.mjs.map
